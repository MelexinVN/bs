   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
 134               	.global	port_init
 136               	port_init:
   1:main.c        **** 
   2:main.c        **** #define F_CPU 8000000UL
   3:main.c        **** 
   4:main.c        **** #include <avr/io.h>
   5:main.c        **** #include <avr/interrupt.h>
   6:main.c        **** #include <util/delay.h>
   7:main.c        **** #include <avr/wdt.h>
   8:main.c        **** #include <stdio.h>
   9:main.c        **** #include <stdlib.h>
  10:main.c        **** #include <string.h>
  11:main.c        **** #include <stdint.h>
  12:main.c        **** #include <avr/boot.h>
  13:main.c        **** #include <avr/pgmspace.h>
  14:main.c        **** #include <avr/eeprom.h>
  15:main.c        **** #include "chipdef.h"
  16:main.c        **** 
  17:main.c        **** #define DISABLE_WDT_AT_STARTUP
  18:main.c        **** #define BUT_ADDR 		0x07				//адрес кнопки
  19:main.c        **** #define RESET 			0xFF				//команда сброса
  20:main.c        **** #define NOT_PUSHED 		0xFFFFFFFF			//сообщение "кнопка не нажата"
  21:main.c        **** 
  22:main.c        **** #define LED_Pin PORTD6			//пин светодиода
  23:main.c        **** #define LED_GPIO_Port PORTD		//порт светодиода
  24:main.c        **** #define IRQ_Pin PORTD2			//пин прерывания радиомодуля
  25:main.c        **** #define IRQ_GPIO_Port PORTD2	//порт прерывания радиомодуля
  26:main.c        **** #define CE_Pin PORTB0			//пин CE
  27:main.c        **** #define CE_GPIO_Port PORTB		//порт CE
  28:main.c        **** #define CSN_Pin PORTD7			//пин CSN
  29:main.c        **** #define CSN_GPIO_Port PORTD		//порт CSN
  30:main.c        **** 
  31:main.c        **** #define WAIT_VALUE 1000 //в мс
  32:main.c        **** 
  33:main.c        **** //------------------------------------------------
  34:main.c        **** #define CS_ON()			CSN_GPIO_Port&=~(1<<CSN_Pin)
  35:main.c        **** #define CS_OFF()		CSN_GPIO_Port|=(1<<CSN_Pin)
  36:main.c        **** #define CE_RESET()		CE_GPIO_Port&=~(1<<CE_Pin)
  37:main.c        **** #define CE_SET()		CE_GPIO_Port|=(1<<CE_Pin)
  38:main.c        **** 
  39:main.c        **** #define LED_ON()		LED_GPIO_Port|=(1<<LED_Pin)
  40:main.c        **** #define LED_OFF()		LED_GPIO_Port&=~(1<<LED_Pin)
  41:main.c        **** #define LED_TGL()		LED_GPIO_Port^=(1<<LED_Pin)
  42:main.c        **** //------------------------------------------------
  43:main.c        **** #define ACTIVATE 		0x50 //
  44:main.c        **** #define RD_RX_PLOAD		0x61 // Define RX payload register address
  45:main.c        **** #define WR_TX_PLOAD		0xA0 // Define TX payload register address
  46:main.c        **** #define FLUSH_TX 		0xE1
  47:main.c        **** #define FLUSH_RX 		0xE2
  48:main.c        **** //------------------------------------------------
  49:main.c        **** #define CONFIG 			0x00 //'Config' register address
  50:main.c        **** #define EN_AA 			0x01 //'Enable Auto Acknowledgment' register address
  51:main.c        **** #define EN_RXADDR 		0x02 //'Enabled RX addresses' register address
  52:main.c        **** #define SETUP_AW 		0x03 //'Setup address width' register address
  53:main.c        **** #define SETUP_RETR 		0x04 //'Setup Auto. Retrans' register address
  54:main.c        **** #define RF_CH 			0x05 //'RF channel' register address
  55:main.c        **** #define RF_SETUP 		0x06 //'RF setup' register address
  56:main.c        **** #define STATUS 			0x07 //'Status' register address
  57:main.c        **** #define OBSERVE_TX 		0x08 //'Transmit observe' register
  58:main.c        **** #define RX_ADDR_P0 		0x0A //'RX address pipe0' register address
  59:main.c        **** #define RX_ADDR_P1 		0x0B //'RX address pipe1' register address
  60:main.c        **** #define TX_ADDR 		0x10 //'TX address' register address
  61:main.c        **** #define RX_PW_P0 		0x11 //'RX payload width, pipe0' register address
  62:main.c        **** #define RX_PW_P1 		0x12 //'RX payload width, pipe1' register address
  63:main.c        **** #define FIFO_STATUS		0x17 //'FIFO Status Register' register address
  64:main.c        **** #define DYNPD 			0x1C
  65:main.c        **** #define FEATURE 		0x1D
  66:main.c        **** //------------------------------------------------
  67:main.c        **** #define PRIM_RX 		0x00 //RX/TX control (1: PRX, 0: PTX)
  68:main.c        **** #define PWR_UP 			0x01 //1: POWER UP, 0:POWER DOWN
  69:main.c        **** #define RX_DR 			0x40 //Data Ready RX FIFO interrupt
  70:main.c        **** #define TX_DS 			0x20 //Data Sent TX FIFO interrupt
  71:main.c        **** #define MAX_RT 			0x10 //Maximum number of TX retransmits interrupt
  72:main.c        **** //------------------------------------------------
  73:main.c        **** #define W_REGISTER 		0x20 //запись в регистр
  74:main.c        **** //------------------------------------------------
  75:main.c        **** #define TX_ADR_WIDTH 3						//размер адреса передачи
  76:main.c        **** #define TX_PLOAD_WIDTH 32					//размер полезной нагрузки
  77:main.c        **** //максимальное число байт, чтобы при добавлении новых функций не переделывать задержки
  78:main.c        **** 
  79:main.c        **** uint8_t TX_ADDRESS0[TX_ADR_WIDTH] = {0xb5,0xb5,0xa1};	//адрес 0
  80:main.c        **** uint8_t TX_ADDRESS1[TX_ADR_WIDTH] = {0xb7,0xb5,0xa1};	//адрес 1
  81:main.c        **** 
  82:main.c        **** uint8_t rx_buf[TX_PLOAD_WIDTH] = {0};				//буфер приема
  83:main.c        **** uint8_t tx_buf[TX_PLOAD_WIDTH] = {0};				//буфер передачи
  84:main.c        **** 
  85:main.c        **** volatile uint8_t f_rx = 0, f_tx = 0;				//флаги приема и передачи
  86:main.c        **** 
  87:main.c        **** uint8_t f_send;								//флаг отправки
  88:main.c        **** 
  89:main.c        **** uint8_t buf[20];							//буфер
  90:main.c        **** uint16_t address;
  91:main.c        **** uint8_t device, val;
  92:main.c        **** uint8_t f_wait = 0;
  93:main.c        **** 
  94:main.c        **** void nrf24_init(void);
  95:main.c        **** uint8_t NRF24_ReadReg(uint8_t addr);
  96:main.c        **** void NRF24_Read_Buf(uint8_t addr,uint8_t *pBuf,uint8_t bytes);
  97:main.c        **** uint8_t NRF24L01_Send(uint8_t *pBuf);
  98:main.c        **** void nrf24l01_receive(void);
  99:main.c        **** 
 100:main.c        **** uint8_t gBuffer[SPM_PAGESIZE];
 101:main.c        **** uint16_t address = 0;
 102:main.c        **** uint8_t device = 0, val;
 103:main.c        **** 
 104:main.c        **** void port_init(void)//Инициализация портов
 105:main.c        **** {
 138               	.LM0:
 139               	.LFBB1:
 140               	/* prologue: function */
 141               	/* frame size = 0 */
 142               	/* stack size = 0 */
 143               	.L__stack_usage = 0
 106:main.c        **** 	// Input/Output Ports initialization
 107:main.c        **** 	// Port B initialization
 108:main.c        **** 	// Function: Bit7=In Bit6=In Bit5=Out Bit4=In Bit3=Out Bit2=Out Bit1=In Bit0=Out
 109:main.c        **** 	DDRB=(0<<DDB7) | (0<<DDB6) | (1<<DDB5) | (0<<DDB4) | (1<<DDB3) | (1<<DDB2) | (0<<DDB1) | (1<<DDB0)
 145               	.LM1:
 146 0000 8DE2      		ldi r24,lo8(45)
 147 0002 87BB      		out 0x17,r24
 110:main.c        **** 	// State: Bit7=T Bit6=T Bit5=0 Bit4=T Bit3=0 Bit2=0 Bit1=T Bit0=0
 111:main.c        **** 	PORTB=(0<<PORTB7) | (0<<PORTB6) | (0<<PORTB5) | (0<<PORTB4) | (0<<PORTB3) | (0<<PORTB2) | (0<<PORT
 149               	.LM2:
 150 0004 81E0      		ldi r24,lo8(1)
 151 0006 88BB      		out 0x18,r24
 112:main.c        **** 
 113:main.c        **** 	// Port C initialization
 114:main.c        **** 	// Function: Bit6=In Bit5=In Bit4=In Bit3=In Bit2=In Bit1=In Bit0=In
 115:main.c        **** 	DDRC=(0<<DDC6) | (0<<DDC5) | (0<<DDC4) | (0<<DDC3) | (0<<DDC2) | (0<<DDC1) | (0<<DDC0);
 153               	.LM3:
 154 0008 14BA      		out 0x14,__zero_reg__
 116:main.c        **** 	// State: Bit6=T Bit5=T Bit4=T Bit3=T Bit2=T Bit1=T Bit0=T
 117:main.c        **** 	PORTC=(0<<PORTC6) | (0<<PORTC5) | (0<<PORTC4) | (0<<PORTC3) | (0<<PORTC2) | (0<<PORTC1) | (0<<PORT
 156               	.LM4:
 157 000a 15BA      		out 0x15,__zero_reg__
 118:main.c        **** 
 119:main.c        **** 	// Port D initialization
 120:main.c        **** 	// Function: Bit7=Out Bit6=Out Bit5=In Bit4=In Bit3=In Bit2=In Bit1=In Bit0=In
 121:main.c        **** 	DDRD=(1<<DDD7) | (1<<DDD6) | (0<<DDD5) | (0<<DDD4) | (0<<DDD3) | (0<<DDD2) | (0<<DDD1) | (0<<DDD0)
 159               	.LM5:
 160 000c 80EC      		ldi r24,lo8(-64)
 161 000e 81BB      		out 0x11,r24
 122:main.c        **** 	// State: Bit7=0 Bit6=0 Bit5=T Bit4=T Bit3=P Bit2=T Bit1=T Bit0=T
 123:main.c        **** 	PORTD=(1<<PORTD7) | (0<<PORTD6) | (0<<PORTD5) | (0<<PORTD4) | (1<<PORTD3) | (0<<PORTD2) | (0<<PORT
 163               	.LM6:
 164 0010 88E8      		ldi r24,lo8(-120)
 165 0012 82BB      		out 0x12,r24
 166 0014 0895      		ret
 168               	.Lscope1:
 170               	.global	spi_init
 172               	spi_init:
 124:main.c        **** }
 125:main.c        **** 
 126:main.c        **** //инициализация SPI
 127:main.c        **** void spi_init(void)
 128:main.c        **** {
 174               	.LM7:
 175               	.LFBB2:
 176               	/* prologue: function */
 177               	/* frame size = 0 */
 178               	/* stack size = 0 */
 179               	.L__stack_usage = 0
 129:main.c        **** 	DDRB |= ((1<<PORTB2)|(1<<PORTB3)|(1<<PORTB5)); //ножки SPI на выход
 181               	.LM8:
 182 0016 87B3      		in r24,0x17
 183 0018 8C62      		ori r24,lo8(44)
 184 001a 87BB      		out 0x17,r24
 130:main.c        **** 	PORTB &= ~((1<<PORTB2)|(1<<PORTB3)|(1<<PORTB5)); //низкий уровень
 186               	.LM9:
 187 001c 88B3      		in r24,0x18
 188 001e 837D      		andi r24,lo8(-45)
 189 0020 88BB      		out 0x18,r24
 131:main.c        **** 	SPCR=(0<<SPIE) | (1<<SPE) | (0<<DORD) | (1<<MSTR) | (0<<CPOL) | (0<<CPHA) | (0<<SPR1) | (0<<SPR0);
 191               	.LM10:
 192 0022 80E5      		ldi r24,lo8(80)
 193 0024 8DB9      		out 0xd,r24
 194 0026 0895      		ret
 196               	.Lscope2:
 199               	.global	spi_sendByte
 201               	spi_sendByte:
 132:main.c        **** }
 133:main.c        **** 
 134:main.c        **** //отправка байта
 135:main.c        **** void spi_sendByte(uint8_t byte)
 136:main.c        **** {
 203               	.LM11:
 204               	.LFBB3:
 205               	/* prologue: function */
 206               	/* frame size = 0 */
 207               	/* stack size = 0 */
 208               	.L__stack_usage = 0
 137:main.c        **** 	SPDR = byte;				//записываем байт в регистр
 210               	.LM12:
 211 0028 8FB9      		out 0xf,r24
 212               	.L4:
 138:main.c        **** 	while(!(SPSR & (1<<SPIF)));	//подождем пока данные передадутся
 214               	.LM13:
 215 002a 779B      		sbis 0xe,7
 216 002c 00C0      		rjmp .L4
 217               	/* epilogue start */
 139:main.c        **** }
 219               	.LM14:
 220 002e 0895      		ret
 222               	.Lscope3:
 225               	.global	spi_changeByte
 227               	spi_changeByte:
 140:main.c        **** 
 141:main.c        **** //прием/отправка байта
 142:main.c        **** uint8_t spi_changeByte(uint8_t byte)
 143:main.c        **** {
 229               	.LM15:
 230               	.LFBB4:
 231               	/* prologue: function */
 232               	/* frame size = 0 */
 233               	/* stack size = 0 */
 234               	.L__stack_usage = 0
 144:main.c        **** 	SPDR = byte;				//записываем байт в регистр
 236               	.LM16:
 237 0030 8FB9      		out 0xf,r24
 238               	.L8:
 145:main.c        **** 	while(!(SPSR & (1<<SPIF)));	//подождем пока данные передадутся (обменяются)
 240               	.LM17:
 241 0032 779B      		sbis 0xe,7
 242 0034 00C0      		rjmp .L8
 146:main.c        **** 	return SPDR;				//возвращаем принятое значение
 244               	.LM18:
 245 0036 8FB1      		in r24,0xf
 147:main.c        **** }
 247               	.LM19:
 248 0038 0895      		ret
 250               	.Lscope4:
 253               	.global	NRF24_ReadReg
 255               	NRF24_ReadReg:
 148:main.c        **** 
 149:main.c        **** //функция чтения регистра модуля
 150:main.c        **** uint8_t NRF24_ReadReg(uint8_t addr)
 151:main.c        **** {
 257               	.LM20:
 258               	.LFBB5:
 259 003a CF93      		push r28
 260               	/* prologue: function */
 261               	/* frame size = 0 */
 262               	/* stack size = 1 */
 263               	.L__stack_usage = 1
 264 003c C82F      		mov r28,r24
 152:main.c        **** 	uint8_t dt=0, cmd;								//переменные данных и команды
 153:main.c        **** 	CS_ON();											//ногу cs к земле
 266               	.LM21:
 267 003e 9798      		cbi 0x12,7
 154:main.c        **** 	dt = spi_changeByte(addr);						//Прием/отправкадайта адреса регистра
 269               	.LM22:
 270 0040 00D0      		rcall spi_changeByte
 155:main.c        **** 	//если адрес равен адрес регистра статус то и возварщаем его состояние
 156:main.c        **** 	if (addr!=STATUS)//а если не равен
 272               	.LM23:
 273 0042 C730      		cpi r28,lo8(7)
 274 0044 01F0      		breq .L11
 157:main.c        **** 	{
 158:main.c        **** 		cmd=0xFF;									//команда NOP для получения данных
 159:main.c        **** 		dt = spi_changeByte(cmd);					//
 276               	.LM24:
 277 0046 8FEF      		ldi r24,lo8(-1)
 278 0048 00D0      		rcall spi_changeByte
 279               	.L11:
 160:main.c        **** 	}
 161:main.c        **** 	CS_OFF();											//поднимаем ногу CS
 281               	.LM25:
 282 004a 979A      		sbi 0x12,7
 283               	/* epilogue start */
 162:main.c        **** 	return dt;	//возвращаемое значение
 163:main.c        **** }
 285               	.LM26:
 286 004c CF91      		pop r28
 287 004e 0895      		ret
 292               	.Lscope5:
 296               	.global	NRF24_WriteReg
 298               	NRF24_WriteReg:
 164:main.c        **** //------------------------------------------------
 165:main.c        **** //функция записи регистра в модуль
 166:main.c        **** void NRF24_WriteReg(uint8_t addr, uint8_t dt)
 167:main.c        **** {
 300               	.LM27:
 301               	.LFBB6:
 302 0050 CF93      		push r28
 303               	/* prologue: function */
 304               	/* frame size = 0 */
 305               	/* stack size = 1 */
 306               	.L__stack_usage = 1
 307 0052 C62F      		mov r28,r22
 168:main.c        **** 	addr |= W_REGISTER;//включим бит записи в адрес
 169:main.c        **** 	CS_ON();
 309               	.LM28:
 310 0054 9798      		cbi 0x12,7
 170:main.c        **** 	spi_sendByte(addr);									//
 312               	.LM29:
 313 0056 8062      		ori r24,lo8(32)
 314 0058 00D0      		rcall spi_sendByte
 171:main.c        **** 	spi_sendByte(dt);										//
 316               	.LM30:
 317 005a 8C2F      		mov r24,r28
 318 005c 00D0      		rcall spi_sendByte
 172:main.c        **** 	CS_OFF();
 320               	.LM31:
 321 005e 979A      		sbi 0x12,7
 322               	/* epilogue start */
 173:main.c        **** }
 324               	.LM32:
 325 0060 CF91      		pop r28
 326 0062 0895      		ret
 328               	.Lscope6:
 330               	.global	NRF24_ToggleFeatures
 332               	NRF24_ToggleFeatures:
 174:main.c        **** 
 175:main.c        **** //------------------------------------------------
 176:main.c        **** void NRF24_ToggleFeatures(void)							//активация команд R_RX_PL_WID, W_ACK_PAYLOAD и W_TX_PAYLOAD_
 177:main.c        **** {	//есть в даташите "без плюса"
 334               	.LM33:
 335               	.LFBB7:
 336               	/* prologue: function */
 337               	/* frame size = 0 */
 338               	/* stack size = 0 */
 339               	.L__stack_usage = 0
 178:main.c        **** 	uint8_t dt[1] = {ACTIVATE};
 179:main.c        **** 	CS_ON();
 341               	.LM34:
 342 0064 9798      		cbi 0x12,7
 180:main.c        **** 	spi_sendByte(dt[0]);
 344               	.LM35:
 345 0066 80E5      		ldi r24,lo8(80)
 346 0068 00D0      		rcall spi_sendByte
 347               	.LBB36:
 348               	.LBB37:
 350               	.Ltext1:
   1:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    All rights reserved.
   5:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
   6:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
   9:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  12:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      distribution.
  16:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  17:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  21:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  33:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /* $Id$ */
  34:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  35:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  38:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #  endif
  42:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  44:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <inttypes.h>
  45:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <math.h>
  47:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  48:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \file */
  49:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \code
  51:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     #include <util/delay.h>
  54:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \endcode
  55:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  56:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     used.
  60:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  61:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  70:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     routines linked into the application.
  78:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  79:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  83:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** */
  84:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  85:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
  89:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  90:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef F_CPU
  91:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \ingroup util_delay
  94:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \def F_CPU
  95:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  97:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 103:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     integer value.
 107:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****  */
 108:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 110:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 111:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 114:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 115:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #  include <math.h>
 119:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 120:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 121:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /**
 122:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \ingroup util_delay
 123:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 124:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 126:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 129:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 131:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 137:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 142:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    microseconds of delay.
 146:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 147:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    respectively.
 151:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 152:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \note
 153:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 154:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    not available to the compiler then.
 163:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 164:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****  */
 165:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** void
 166:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** _delay_ms(double __ms)
 167:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** {
 168:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	double __tmp ;
 169:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 173:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 176:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 179:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 182:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#else
 183:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		//round up by default
 184:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#endif
 186:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 187:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 189:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #else
 190:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	uint16_t __ticks;
 191:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	if (__tmp < 1.0)
 193:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks = 1;
 194:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	else if (__tmp > 65535)
 195:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	{
 196:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		while(__ticks)
 199:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		{
 200:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 			// wait 1/10 ms
 201:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 			__ticks --;
 203:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		}
 204:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		return;
 205:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	}
 206:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	else
 207:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks = (uint16_t)__tmp;
 208:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	_delay_loop_2(__ticks);
 209:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 210:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** }
 211:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 212:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /**
 213:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \ingroup util_delay
 214:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 215:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 217:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 218:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 220:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 222:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    will not be informed about this case.
 225:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 226:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflow results in
 229:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    no delay i.e., 0us.
 230:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 231:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __us
 234:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    microseconds of delay.
 235:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 236:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    respectively.
 240:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 241:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \note
 242:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 243:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 244:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 246:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 248:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 249:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    not available to the compiler then.
 252:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 253:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****  */
 254:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** void
 255:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** _delay_us(double __us)
 256:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** {
 257:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	double __tmp ;
 258:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   __STDC_HOSTED__
 261:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 262:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 265:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 268:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 271:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#else
 272:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		//round up by default
 273:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#endif
 275:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 276:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 352               	.LM36:
 353 006a 82E0      		ldi r24,lo8(2)
 354 006c 8A95      	1:	dec r24
 355 006e 01F4      		brne 1b
 356 0070 00C0      		rjmp .
 357               	.LBE37:
 358               	.LBE36:
 360               	.Ltext2:
 181:main.c        **** 	_delay_us(1);
 182:main.c        **** 	dt[0] = 0x73;
 183:main.c        **** 	spi_sendByte(dt[0]);
 362               	.LM37:
 363 0072 83E7      		ldi r24,lo8(115)
 364 0074 00D0      		rcall spi_sendByte
 184:main.c        **** 	CS_OFF();
 366               	.LM38:
 367 0076 979A      		sbi 0x12,7
 368 0078 0895      		ret
 370               	.Lscope7:
 374               	.global	NRF24_Read_Buf
 376               	NRF24_Read_Buf:
 185:main.c        **** }
 186:main.c        **** 
 187:main.c        **** //-----------------------------------------------
 188:main.c        **** void NRF24_Read_Buf(uint8_t addr,uint8_t *pBuf,uint8_t bytes)
 189:main.c        **** {//чтение буфера (несколько байт)
 378               	.LM39:
 379               	.LFBB8:
 380 007a EF92      		push r14
 381 007c FF92      		push r15
 382 007e 0F93      		push r16
 383 0080 1F93      		push r17
 384 0082 CF93      		push r28
 385 0084 DF93      		push r29
 386               	/* prologue: function */
 387               	/* frame size = 0 */
 388               	/* stack size = 6 */
 389               	.L__stack_usage = 6
 390 0086 182F      		mov r17,r24
 391 0088 062F      		mov r16,r22
 392 008a E72E      		mov r14,r23
 393 008c F42E      		mov r15,r20
 190:main.c        **** 	CS_ON();
 395               	.LM40:
 396 008e 9798      		cbi 0x12,7
 191:main.c        **** 	spi_sendByte(addr);
 398               	.LM41:
 399 0090 00D0      		rcall spi_sendByte
 400 0092 C02F      		mov r28,r16
 401 0094 DE2D      		mov r29,r14
 402 0096 CE01      		movw r24,r28
 403 0098 8F0D      		add r24,r15
 404 009a 911D      		adc r25,__zero_reg__
 405 009c 7C01      		movw r14,r24
 406               	.L18:
 407               	.LBB38:
 192:main.c        **** 	for (uint8_t i = 0 ; i < bytes ; i++) 		//для нужного количества байт
 409               	.LM42:
 410 009e CE15      		cp r28,r14
 411 00a0 DF05      		cpc r29,r15
 412 00a2 01F0      		breq .L20
 193:main.c        **** 	{																					//
 194:main.c        **** 		pBuf[i] = spi_changeByte(addr);
 414               	.LM43:
 415 00a4 812F      		mov r24,r17
 416 00a6 00D0      		rcall spi_changeByte
 417 00a8 8993      		st Y+,r24
 418 00aa 00C0      		rjmp .L18
 419               	.L20:
 420               	.LBE38:
 195:main.c        **** 	}
 196:main.c        **** 	CS_OFF();
 422               	.LM44:
 423 00ac 979A      		sbi 0x12,7
 424               	/* epilogue start */
 197:main.c        **** }
 426               	.LM45:
 427 00ae DF91      		pop r29
 428 00b0 CF91      		pop r28
 429 00b2 1F91      		pop r17
 430 00b4 0F91      		pop r16
 431 00b6 FF90      		pop r15
 432 00b8 EF90      		pop r14
 433 00ba 0895      		ret
 435               	.Lscope8:
 439               	.global	NRF24_Write_Buf
 441               	NRF24_Write_Buf:
 198:main.c        **** 
 199:main.c        **** //------------------------------------------------
 200:main.c        **** void NRF24_Write_Buf(uint8_t addr,uint8_t *pBuf,uint8_t bytes)
 201:main.c        **** {//запись буфера
 443               	.LM46:
 444               	.LFBB9:
 445 00bc FF92      		push r15
 446 00be 0F93      		push r16
 447 00c0 1F93      		push r17
 448 00c2 CF93      		push r28
 449 00c4 DF93      		push r29
 450               	/* prologue: function */
 451               	/* frame size = 0 */
 452               	/* stack size = 5 */
 453               	.L__stack_usage = 5
 454 00c6 F62E      		mov r15,r22
 455 00c8 072F      		mov r16,r23
 456 00ca 142F      		mov r17,r20
 202:main.c        **** 	addr |= W_REGISTER;//включим бит записи в адрес
 203:main.c        **** 	CS_ON();
 458               	.LM47:
 459 00cc 9798      		cbi 0x12,7
 204:main.c        **** 	spi_sendByte(addr);
 461               	.LM48:
 462 00ce 8062      		ori r24,lo8(32)
 463 00d0 00D0      		rcall spi_sendByte
 464               	.LBB39:
 465               	.LBB40:
 467               	.Ltext3:
 469               	.LM49:
 470 00d2 82E0      		ldi r24,lo8(2)
 471 00d4 8A95      	1:	dec r24
 472 00d6 01F4      		brne 1b
 473 00d8 00C0      		rjmp .
 474 00da CF2D      		mov r28,r15
 475 00dc D02F      		mov r29,r16
 476 00de CE01      		movw r24,r28
 477 00e0 810F      		add r24,r17
 478 00e2 911D      		adc r25,__zero_reg__
 479 00e4 8C01      		movw r16,r24
 480               	.L22:
 481               	.LBE40:
 482               	.LBE39:
 483               	.LBB41:
 485               	.Ltext4:
 205:main.c        **** 	_delay_us(1);
 206:main.c        **** 	for (uint8_t i = 0 ; i < bytes ; i++) 		//для нужного количества байт
 487               	.LM50:
 488 00e6 C017      		cp r28,r16
 489 00e8 D107      		cpc r29,r17
 490 00ea 01F0      		breq .L24
 207:main.c        **** 	{
 208:main.c        **** 		spi_sendByte(pBuf[i]);
 492               	.LM51:
 493 00ec 8991      		ld r24,Y+
 494 00ee 00D0      		rcall spi_sendByte
 495 00f0 00C0      		rjmp .L22
 496               	.L24:
 497               	.LBE41:
 209:main.c        **** 	}
 210:main.c        **** 	CS_OFF();
 499               	.LM52:
 500 00f2 979A      		sbi 0x12,7
 501               	/* epilogue start */
 211:main.c        **** }
 503               	.LM53:
 504 00f4 DF91      		pop r29
 505 00f6 CF91      		pop r28
 506 00f8 1F91      		pop r17
 507 00fa 0F91      		pop r16
 508 00fc FF90      		pop r15
 509 00fe 0895      		ret
 511               	.Lscope9:
 513               	.global	NRF24_FlushRX
 515               	NRF24_FlushRX:
 212:main.c        **** 
 213:main.c        **** //------------------------------------------------
 214:main.c        **** void NRF24_FlushRX(void)
 215:main.c        **** {//очистка буфера приема
 517               	.LM54:
 518               	.LFBB10:
 519               	/* prologue: function */
 520               	/* frame size = 0 */
 521               	/* stack size = 0 */
 522               	.L__stack_usage = 0
 216:main.c        **** 	uint8_t dt[1] = {FLUSH_RX};
 217:main.c        **** 	CS_ON();
 524               	.LM55:
 525 0100 9798      		cbi 0x12,7
 218:main.c        **** 	spi_sendByte(dt[0]);
 527               	.LM56:
 528 0102 82EE      		ldi r24,lo8(-30)
 529 0104 00D0      		rcall spi_sendByte
 530               	.LBB42:
 531               	.LBB43:
 533               	.Ltext5:
 535               	.LM57:
 536 0106 82E0      		ldi r24,lo8(2)
 537 0108 8A95      	1:	dec r24
 538 010a 01F4      		brne 1b
 539 010c 00C0      		rjmp .
 540               	.LBE43:
 541               	.LBE42:
 543               	.Ltext6:
 219:main.c        **** 	_delay_us(1); //пауза в микросекунду для завершения процесса
 220:main.c        **** 	CS_OFF();
 545               	.LM58:
 546 010e 979A      		sbi 0x12,7
 547 0110 0895      		ret
 549               	.Lscope10:
 551               	.global	NRF24_FlushTX
 553               	NRF24_FlushTX:
 221:main.c        **** }
 222:main.c        **** 
 223:main.c        **** //------------------------------------------------
 224:main.c        **** void NRF24_FlushTX(void)
 225:main.c        **** {//очистка буфера передачи
 555               	.LM59:
 556               	.LFBB11:
 557               	/* prologue: function */
 558               	/* frame size = 0 */
 559               	/* stack size = 0 */
 560               	.L__stack_usage = 0
 226:main.c        **** 	uint8_t dt[1] = {FLUSH_TX};
 227:main.c        **** 	CS_ON();
 562               	.LM60:
 563 0112 9798      		cbi 0x12,7
 228:main.c        **** 	spi_sendByte(dt[0]);
 565               	.LM61:
 566 0114 81EE      		ldi r24,lo8(-31)
 567 0116 00D0      		rcall spi_sendByte
 568               	.LBB44:
 569               	.LBB45:
 571               	.Ltext7:
 573               	.LM62:
 574 0118 82E0      		ldi r24,lo8(2)
 575 011a 8A95      	1:	dec r24
 576 011c 01F4      		brne 1b
 577 011e 00C0      		rjmp .
 578               	.LBE45:
 579               	.LBE44:
 581               	.Ltext8:
 229:main.c        **** 	_delay_us(1); //пауза в микросекунду для завершения процесса
 230:main.c        **** 	CS_OFF();
 583               	.LM63:
 584 0120 979A      		sbi 0x12,7
 585 0122 0895      		ret
 587               	.Lscope11:
 589               	.global	NRF24L01_RX_Mode
 591               	NRF24L01_RX_Mode:
 231:main.c        **** }
 232:main.c        **** 
 233:main.c        **** //------------------------------------------------
 234:main.c        **** void NRF24L01_RX_Mode(void)
 235:main.c        **** {//режим приемника
 593               	.LM64:
 594               	.LFBB12:
 595               	/* prologue: function */
 596               	/* frame size = 0 */
 597               	/* stack size = 0 */
 598               	.L__stack_usage = 0
 236:main.c        **** 	uint8_t regval=0x00;
 237:main.c        **** 	regval = NRF24_ReadReg(CONFIG);	//сохраняем значение регистра конфигурации
 600               	.LM65:
 601 0124 80E0      		ldi r24,0
 602 0126 00D0      		rcall NRF24_ReadReg
 238:main.c        **** 	//разбудим модуль и переведём его в режим приёмника, включив биты PWR_UP и PRIM_RX
 239:main.c        **** 	regval |= (1<<PWR_UP)|(1<<PRIM_RX);
 240:main.c        **** 	NRF24_WriteReg(CONFIG,regval);	//возвращаем значение регистра статуса
 604               	.LM66:
 605 0128 682F      		mov r22,r24
 606 012a 6360      		ori r22,lo8(3)
 607 012c 80E0      		ldi r24,0
 608 012e 00D0      		rcall NRF24_WriteReg
 241:main.c        **** 	
 242:main.c        **** 	NRF24_Write_Buf(TX_ADDR, TX_ADDRESS1, TX_ADR_WIDTH);		//записываем  адрес передатчика
 610               	.LM67:
 611 0130 43E0      		ldi r20,lo8(3)
 612 0132 60E0      		ldi r22,lo8(TX_ADDRESS1)
 613 0134 70E0      		ldi r23,hi8(TX_ADDRESS1)
 614 0136 80E1      		ldi r24,lo8(16)
 615 0138 00D0      		rcall NRF24_Write_Buf
 243:main.c        **** 	NRF24_Write_Buf(RX_ADDR_P0, TX_ADDRESS1, TX_ADR_WIDTH);	//записываем адрес приемника
 617               	.LM68:
 618 013a 43E0      		ldi r20,lo8(3)
 619 013c 60E0      		ldi r22,lo8(TX_ADDRESS1)
 620 013e 70E0      		ldi r23,hi8(TX_ADDRESS1)
 621 0140 8AE0      		ldi r24,lo8(10)
 622 0142 00D0      		rcall NRF24_Write_Buf
 244:main.c        **** 	
 245:main.c        **** 	CE_SET();
 624               	.LM69:
 625 0144 C09A      		sbi 0x18,0
 626               	.LBB46:
 627               	.LBB47:
 629               	.Ltext9:
 631               	.LM70:
 632 0146 8BE2      		ldi r24,lo8(299)
 633 0148 91E0      		ldi r25,hi8(299)
 634 014a 0197      	1:	sbiw r24,1
 635 014c 01F4      		brne 1b
 636 014e 00C0      		rjmp .
 637 0150 0000      		nop
 638               	.LBE47:
 639               	.LBE46:
 641               	.Ltext10:
 246:main.c        **** 	_delay_us(150); //Задержка минимум 130 мкс
 247:main.c        **** 	// Flush buffers
 248:main.c        **** 	NRF24_FlushRX();
 643               	.LM71:
 644 0152 00D0      		rcall NRF24_FlushRX
 249:main.c        **** 	NRF24_FlushTX();
 646               	.LM72:
 647 0154 00C0      		rjmp NRF24_FlushTX
 649               	.Lscope12:
 652               	.global	NRF24L01_TX_Mode
 654               	NRF24L01_TX_Mode:
 250:main.c        **** }
 251:main.c        **** 
 252:main.c        **** //------------------------------------------------
 253:main.c        **** void NRF24L01_TX_Mode(uint8_t *pBuf)
 254:main.c        **** {//режим передатчика
 656               	.LM73:
 657               	.LFBB13:
 658               	/* prologue: function */
 659               	/* frame size = 0 */
 660               	/* stack size = 0 */
 661               	.L__stack_usage = 0
 255:main.c        **** 	NRF24_Write_Buf(TX_ADDR, TX_ADDRESS0, TX_ADR_WIDTH);		//записываем адрес передатчика
 663               	.LM74:
 664 0156 43E0      		ldi r20,lo8(3)
 665 0158 60E0      		ldi r22,lo8(TX_ADDRESS0)
 666 015a 70E0      		ldi r23,hi8(TX_ADDRESS0)
 667 015c 80E1      		ldi r24,lo8(16)
 668 015e 00D0      		rcall NRF24_Write_Buf
 256:main.c        **** 	NRF24_Write_Buf(RX_ADDR_P0, TX_ADDRESS0, TX_ADR_WIDTH);	//записываем адрес приемника
 670               	.LM75:
 671 0160 43E0      		ldi r20,lo8(3)
 672 0162 60E0      		ldi r22,lo8(TX_ADDRESS0)
 673 0164 70E0      		ldi r23,hi8(TX_ADDRESS0)
 674 0166 8AE0      		ldi r24,lo8(10)
 675 0168 00D0      		rcall NRF24_Write_Buf
 257:main.c        **** 	CE_RESET();
 677               	.LM76:
 678 016a C098      		cbi 0x18,0
 258:main.c        **** 	// Flush buffers
 259:main.c        **** 	NRF24_FlushRX();
 680               	.LM77:
 681 016c 00D0      		rcall NRF24_FlushRX
 260:main.c        **** 	NRF24_FlushTX();
 683               	.LM78:
 684 016e 00C0      		rjmp NRF24_FlushTX
 686               	.Lscope13:
 690               	.global	NRF24_Transmit
 692               	NRF24_Transmit:
 261:main.c        **** }
 262:main.c        **** 
 263:main.c        **** //------------------------------------------------
 264:main.c        **** void NRF24_Transmit(uint8_t addr,uint8_t *pBuf,uint8_t bytes)
 265:main.c        **** {//передача данных в модуль
 694               	.LM79:
 695               	.LFBB14:
 696 0170 FF92      		push r15
 697 0172 0F93      		push r16
 698 0174 1F93      		push r17
 699 0176 CF93      		push r28
 700 0178 DF93      		push r29
 701               	/* prologue: function */
 702               	/* frame size = 0 */
 703               	/* stack size = 5 */
 704               	.L__stack_usage = 5
 705 017a F62E      		mov r15,r22
 706 017c 072F      		mov r16,r23
 707 017e 142F      		mov r17,r20
 266:main.c        **** 	CE_RESET();
 709               	.LM80:
 710 0180 C098      		cbi 0x18,0
 267:main.c        **** 	CS_ON();
 712               	.LM81:
 713 0182 9798      		cbi 0x12,7
 268:main.c        **** 	spi_sendByte(addr);
 715               	.LM82:
 716 0184 00D0      		rcall spi_sendByte
 717               	.LBB48:
 718               	.LBB49:
 720               	.Ltext11:
 722               	.LM83:
 723 0186 82E0      		ldi r24,lo8(2)
 724 0188 8A95      	1:	dec r24
 725 018a 01F4      		brne 1b
 726 018c 00C0      		rjmp .
 727 018e CF2D      		mov r28,r15
 728 0190 D02F      		mov r29,r16
 729 0192 CE01      		movw r24,r28
 730 0194 810F      		add r24,r17
 731 0196 911D      		adc r25,__zero_reg__
 732 0198 8C01      		movw r16,r24
 733               	.L30:
 734               	.LBE49:
 735               	.LBE48:
 736               	.LBB50:
 738               	.Ltext12:
 269:main.c        **** 	_delay_us(1); //пауза в микросекунду для завершения процесса
 270:main.c        **** 	for (uint8_t i = 0 ; i < bytes ; i++)
 740               	.LM84:
 741 019a C017      		cp r28,r16
 742 019c D107      		cpc r29,r17
 743 019e 01F0      		breq .L32
 271:main.c        **** 	{
 272:main.c        **** 		spi_sendByte(pBuf[i]);
 745               	.LM85:
 746 01a0 8991      		ld r24,Y+
 747 01a2 00D0      		rcall spi_sendByte
 748 01a4 00C0      		rjmp .L30
 749               	.L32:
 750               	.LBE50:
 273:main.c        **** 	}
 274:main.c        **** 	CS_OFF();
 752               	.LM86:
 753 01a6 979A      		sbi 0x12,7
 275:main.c        **** 	CE_SET();
 755               	.LM87:
 756 01a8 C09A      		sbi 0x18,0
 757               	/* epilogue start */
 276:main.c        **** }
 759               	.LM88:
 760 01aa DF91      		pop r29
 761 01ac CF91      		pop r28
 762 01ae 1F91      		pop r17
 763 01b0 0F91      		pop r16
 764 01b2 FF90      		pop r15
 765 01b4 0895      		ret
 767               	.Lscope14:
 770               	.global	NRF24L01_Send
 772               	NRF24L01_Send:
 277:main.c        **** 
 278:main.c        **** //------------------------------------------------
 279:main.c        **** uint8_t NRF24L01_Send(uint8_t *pBuf)
 280:main.c        **** {//отправка данных в эфир
 774               	.LM89:
 775               	.LFBB15:
 776 01b6 CF93      		push r28
 777 01b8 DF93      		push r29
 778               	/* prologue: function */
 779               	/* frame size = 0 */
 780               	/* stack size = 2 */
 781               	.L__stack_usage = 2
 782 01ba EC01      		movw r28,r24
 281:main.c        **** 	uint8_t regval=0x00;						//переменная для отправки в конфигурационный регистр
 282:main.c        **** 	NRF24L01_TX_Mode(pBuf);					//включаем режим передачи
 784               	.LM90:
 785 01bc 00D0      		rcall NRF24L01_TX_Mode
 283:main.c        **** 	regval = NRF24_ReadReg(CONFIG);	//сохраняем значения конфигурационного региста
 787               	.LM91:
 788 01be 80E0      		ldi r24,0
 789 01c0 00D0      		rcall NRF24_ReadReg
 790 01c2 8E7F      		andi r24,lo8(-2)
 284:main.c        **** 	//если модуль ушел в спящий режим, то разбудим его, включив бит PWR_UP и выключив PRIM_RX
 285:main.c        **** 	regval |= (1<<PWR_UP);
 286:main.c        **** 	regval &= ~(1<<PRIM_RX);
 287:main.c        **** 	NRF24_WriteReg(CONFIG,regval);//записываем новое значение конфигурационного регистра
 792               	.LM92:
 793 01c4 682F      		mov r22,r24
 794 01c6 6260      		ori r22,lo8(2)
 795 01c8 80E0      		ldi r24,0
 796 01ca 00D0      		rcall NRF24_WriteReg
 797               	.LBB51:
 798               	.LBB52:
 800               	.Ltext13:
 802               	.LM93:
 803 01cc 8BE2      		ldi r24,lo8(299)
 804 01ce 91E0      		ldi r25,hi8(299)
 805 01d0 0197      	1:	sbiw r24,1
 806 01d2 01F4      		brne 1b
 807 01d4 00C0      		rjmp .
 808 01d6 0000      		nop
 809               	.LBE52:
 810               	.LBE51:
 812               	.Ltext14:
 288:main.c        **** 	_delay_us(150); //Задержка минимум 130 мкс
 289:main.c        **** 	//Отправим данные в воздух
 290:main.c        **** 	NRF24_Transmit(WR_TX_PLOAD, pBuf, TX_PLOAD_WIDTH);//отправка данных
 814               	.LM94:
 815 01d8 40E2      		ldi r20,lo8(32)
 816 01da BE01      		movw r22,r28
 817 01dc 80EA      		ldi r24,lo8(-96)
 818 01de 00D0      		rcall NRF24_Transmit
 291:main.c        **** 	CE_SET();
 820               	.LM95:
 821 01e0 C09A      		sbi 0x18,0
 822               	.LBB53:
 823               	.LBB54:
 825               	.Ltext15:
 827               	.LM96:
 828 01e2 98E2      		ldi r25,lo8(40)
 829 01e4 9A95      	1:	dec r25
 830 01e6 01F4      		brne 1b
 831               	.LBE54:
 832               	.LBE53:
 834               	.Ltext16:
 292:main.c        **** 	_delay_us(15); //minimum 10us high pulse (Page 21)
 293:main.c        **** 	CE_RESET();
 836               	.LM97:
 837 01e8 C098      		cbi 0x18,0
 838               	.LBB55:
 839               	.LBB56:
 841               	.Ltext17:
 843               	.LM98:
 844 01ea 87EE      		ldi r24,lo8(999)
 845 01ec 93E0      		ldi r25,hi8(999)
 846 01ee 0197      	1:	sbiw r24,1
 847 01f0 01F4      		brne 1b
 848 01f2 00C0      		rjmp .
 849 01f4 0000      		nop
 850               	.LBE56:
 851               	.LBE55:
 853               	.Ltext18:
 294:main.c        **** 	_delay_us(500);
 295:main.c        **** 	NRF24L01_RX_Mode();				//переход в режим приема
 855               	.LM99:
 856 01f6 00D0      		rcall NRF24L01_RX_Mode
 296:main.c        **** 	return 0;
 297:main.c        **** }
 858               	.LM100:
 859 01f8 80E0      		ldi r24,0
 860               	/* epilogue start */
 861 01fa DF91      		pop r29
 862 01fc CF91      		pop r28
 863 01fe 0895      		ret
 865               	.Lscope15:
 867               	.global	nrf24_init
 869               	nrf24_init:
 298:main.c        **** 
 299:main.c        **** //------------------------------------------------
 300:main.c        **** void nrf24_init(void)
 301:main.c        **** {//инициализация
 871               	.LM101:
 872               	.LFBB16:
 873               	/* prologue: function */
 874               	/* frame size = 0 */
 875               	/* stack size = 0 */
 876               	.L__stack_usage = 0
 302:main.c        **** 	CE_RESET();							//опускаем к земле вывод ce
 878               	.LM102:
 879 0200 C098      		cbi 0x18,0
 880               	.LBB57:
 881               	.LBB58:
 883               	.Ltext19:
 885               	.LM103:
 886 0202 8FE0      		ldi r24,lo8(9999)
 887 0204 97E2      		ldi r25,hi8(9999)
 888 0206 0197      	1:	sbiw r24,1
 889 0208 01F4      		brne 1b
 890 020a 00C0      		rjmp .
 891 020c 0000      		nop
 892               	.LBE58:
 893               	.LBE57:
 895               	.Ltext20:
 303:main.c        **** 	_delay_us(5000);					//задержка 5 мс
 304:main.c        **** 	//записываем конфигурационный байт,
 305:main.c        **** 	NRF24_WriteReg(CONFIG, 0x0a);		// Set PWR_UP bit, enable CRC(1 byte) &Prim_RX:0 (Transmitter)
 897               	.LM104:
 898 020e 6AE0      		ldi r22,lo8(10)
 899 0210 80E0      		ldi r24,0
 900 0212 00D0      		rcall NRF24_WriteReg
 901               	.LBB59:
 902               	.LBB60:
 904               	.Ltext21:
 906               	.LM105:
 907 0214 8FE0      		ldi r24,lo8(9999)
 908 0216 97E2      		ldi r25,hi8(9999)
 909 0218 0197      	1:	sbiw r24,1
 910 021a 01F4      		brne 1b
 911 021c 00C0      		rjmp .
 912 021e 0000      		nop
 913               	.LBE60:
 914               	.LBE59:
 916               	.Ltext22:
 306:main.c        **** 	_delay_us(5000);
 307:main.c        **** 	NRF24_WriteReg(EN_AA, 0x00);		// Enable Pipe0
 918               	.LM106:
 919 0220 60E0      		ldi r22,0
 920 0222 81E0      		ldi r24,lo8(1)
 921 0224 00D0      		rcall NRF24_WriteReg
 308:main.c        **** 	NRF24_WriteReg(EN_RXADDR, 0x01);	// Enable Pipe0
 923               	.LM107:
 924 0226 61E0      		ldi r22,lo8(1)
 925 0228 82E0      		ldi r24,lo8(2)
 926 022a 00D0      		rcall NRF24_WriteReg
 309:main.c        **** 	NRF24_WriteReg(SETUP_AW, 0x01);		// Setup address width=3 bytes
 928               	.LM108:
 929 022c 61E0      		ldi r22,lo8(1)
 930 022e 83E0      		ldi r24,lo8(3)
 931 0230 00D0      		rcall NRF24_WriteReg
 310:main.c        **** 	NRF24_WriteReg(SETUP_RETR, 0x00);	// 1500us, 15 retrans
 933               	.LM109:
 934 0232 60E0      		ldi r22,0
 935 0234 84E0      		ldi r24,lo8(4)
 936 0236 00D0      		rcall NRF24_WriteReg
 311:main.c        **** 	NRF24_ToggleFeatures();				//активация команд
 938               	.LM110:
 939 0238 00D0      		rcall NRF24_ToggleFeatures
 312:main.c        **** 	NRF24_WriteReg(FEATURE, 0x07);			//установка стандартных значений регистра FEATURE
 941               	.LM111:
 942 023a 67E0      		ldi r22,lo8(7)
 943 023c 8DE1      		ldi r24,lo8(29)
 944 023e 00D0      		rcall NRF24_WriteReg
 313:main.c        **** 	NRF24_WriteReg(DYNPD, 0);			//отключение динамического размера полезной нагрузки
 946               	.LM112:
 947 0240 60E0      		ldi r22,0
 948 0242 8CE1      		ldi r24,lo8(28)
 949 0244 00D0      		rcall NRF24_WriteReg
 314:main.c        **** 	NRF24_WriteReg(STATUS, 0x70);		//Reset flags for IRQ
 951               	.LM113:
 952 0246 60E7      		ldi r22,lo8(112)
 953 0248 87E0      		ldi r24,lo8(7)
 954 024a 00D0      		rcall NRF24_WriteReg
 315:main.c        **** 	NRF24_WriteReg(RF_CH, 76);			// частота 2476 MHz
 956               	.LM114:
 957 024c 6CE4      		ldi r22,lo8(76)
 958 024e 85E0      		ldi r24,lo8(5)
 959 0250 00D0      		rcall NRF24_WriteReg
 316:main.c        **** 	NRF24_WriteReg(RF_SETUP, 0x06);		//TX_PWR:0dBm, Datarate:1Mbps
 961               	.LM115:
 962 0252 66E0      		ldi r22,lo8(6)
 963 0254 86E0      		ldi r24,lo8(6)
 964 0256 00D0      		rcall NRF24_WriteReg
 317:main.c        **** 	NRF24_Write_Buf(TX_ADDR, TX_ADDRESS0, TX_ADR_WIDTH);//запись адреса передачи
 966               	.LM116:
 967 0258 43E0      		ldi r20,lo8(3)
 968 025a 60E0      		ldi r22,lo8(TX_ADDRESS0)
 969 025c 70E0      		ldi r23,hi8(TX_ADDRESS0)
 970 025e 80E1      		ldi r24,lo8(16)
 971 0260 00D0      		rcall NRF24_Write_Buf
 318:main.c        **** 	NRF24_Write_Buf(RX_ADDR_P1, TX_ADDRESS0, TX_ADR_WIDTH);//запись адреса приема
 973               	.LM117:
 974 0262 43E0      		ldi r20,lo8(3)
 975 0264 60E0      		ldi r22,lo8(TX_ADDRESS0)
 976 0266 70E0      		ldi r23,hi8(TX_ADDRESS0)
 977 0268 8BE0      		ldi r24,lo8(11)
 978 026a 00D0      		rcall NRF24_Write_Buf
 319:main.c        **** 	NRF24_WriteReg(RX_PW_P0, TX_PLOAD_WIDTH); //Number of bytes in RX payload in data pipe 1
 980               	.LM118:
 981 026c 60E2      		ldi r22,lo8(32)
 982 026e 81E1      		ldi r24,lo8(17)
 983 0270 00D0      		rcall NRF24_WriteReg
 320:main.c        **** 	//пока уходим в режим приёмника
 321:main.c        **** 	NRF24L01_RX_Mode();					//режим приема
 985               	.LM119:
 986 0272 00D0      		rcall NRF24L01_RX_Mode
 322:main.c        **** 	LED_OFF();
 988               	.LM120:
 989 0274 9698      		cbi 0x12,6
 990 0276 0895      		ret
 992               	.Lscope16:
 994               	.global	nrf24_receive
 996               	nrf24_receive:
 323:main.c        **** }
 324:main.c        **** 
 325:main.c        **** //--------------------------------------------------
 326:main.c        **** void nrf24_receive(void)
 327:main.c        **** {
 998               	.LM121:
 999               	.LFBB17:
 1000               	/* prologue: function */
 1001               	/* frame size = 0 */
 1002               	/* stack size = 0 */
 1003               	.L__stack_usage = 0
 328:main.c        **** 	uint8_t status = 0x01;	//переменная статус
 329:main.c        **** 	status = NRF24_ReadReg(STATUS);	//чтение значения регистра статуса
 1005               	.LM122:
 1006 0278 87E0      		ldi r24,lo8(7)
 1007 027a 00D0      		rcall NRF24_ReadReg
 330:main.c        **** 	if(status & RX_DR)				//если есть данные на прием
 1009               	.LM123:
 1010 027c 86FF      		sbrs r24,6
 1011 027e 00C0      		rjmp .L35
 1012               	.LBB63:
 1013               	.LBB64:
 331:main.c        **** 	{
 332:main.c        **** 		NRF24_Read_Buf(RD_RX_PLOAD,rx_buf,TX_PLOAD_WIDTH);//чтение буфера
 1015               	.LM124:
 1016 0280 40E2      		ldi r20,lo8(32)
 1017 0282 60E0      		ldi r22,lo8(rx_buf)
 1018 0284 70E0      		ldi r23,hi8(rx_buf)
 1019 0286 81E6      		ldi r24,lo8(97)
 1020 0288 00D0      		rcall NRF24_Read_Buf
 333:main.c        **** 		NRF24_WriteReg(STATUS, 0x40);	//запись в регистр статуса 1 в шестой бит, обнуление остальных
 1022               	.LM125:
 1023 028a 60E4      		ldi r22,lo8(64)
 1024 028c 87E0      		ldi r24,lo8(7)
 1025 028e 00D0      		rcall NRF24_WriteReg
 334:main.c        **** 		f_rx = 1;						//поднимаем флаг приема
 1027               	.LM126:
 1028 0290 81E0      		ldi r24,lo8(1)
 1029 0292 8093 0000 		sts f_rx,r24
 1030               	.L35:
 1031 0296 0895      		ret
 1032               	.LBE64:
 1033               	.LBE63:
 1035               	.Lscope17:
 1036               		.section	.text.startup,"ax",@progbits
 1038               	.global	main
 1040               	main:
 335:main.c        **** 	}
 336:main.c        **** }
 337:main.c        **** 
 338:main.c        **** static inline void eraseFlash(void)
 339:main.c        **** {
 340:main.c        **** 	// erase only main section (bootloader protection)
 341:main.c        **** 	uint32_t addr = 0;
 342:main.c        **** 	while (APP_END > addr) 
 343:main.c        **** 	{
 344:main.c        **** 		boot_page_erase(addr);		// Perform page erase
 345:main.c        **** 		boot_spm_busy_wait();		// Wait until the memory is erased.
 346:main.c        **** 		addr += SPM_PAGESIZE;
 347:main.c        **** 	}
 348:main.c        **** 	boot_rww_enable();
 349:main.c        **** }
 350:main.c        **** 
 351:main.c        **** static inline uint16_t writeFlashPage(uint16_t waddr, pagebuf_t size)
 352:main.c        **** {
 353:main.c        **** 	uint32_t pagestart = (uint32_t)waddr<<1;
 354:main.c        **** 	uint32_t baddr = pagestart;
 355:main.c        **** 	uint16_t data;
 356:main.c        **** 	uint8_t *tmp = gBuffer;
 357:main.c        **** 
 358:main.c        **** 	do 
 359:main.c        **** 		{
 360:main.c        **** 		data = *tmp++;
 361:main.c        **** 		data |= *tmp++ << 8;
 362:main.c        **** 		boot_page_fill(baddr, data);	// call asm routine.
 363:main.c        **** 
 364:main.c        **** 		baddr += 2;			// Select next word in memory
 365:main.c        **** 		size -= 2;			// Reduce number of bytes to write by two
 366:main.c        **** 		} 
 367:main.c        **** 	while (size);				// Loop until all bytes written
 368:main.c        **** 
 369:main.c        **** 	boot_page_write(pagestart);
 370:main.c        **** 	boot_spm_busy_wait();
 371:main.c        **** 	boot_rww_enable();		// Re-enable the RWW section
 372:main.c        **** 
 373:main.c        **** 	return baddr>>1;
 374:main.c        **** }
 375:main.c        **** 
 376:main.c        **** static inline uint16_t writeEEpromPage(uint16_t address, pagebuf_t size)
 377:main.c        **** {
 378:main.c        **** 	uint8_t *tmp = gBuffer;
 379:main.c        **** 
 380:main.c        **** 	do 
 381:main.c        **** 		{
 382:main.c        **** 		eeprom_write_byte( (uint8_t*)address, *tmp++ );
 383:main.c        **** 		address++;			// Select next byte
 384:main.c        **** 		size--;				// Decreas number of bytes to write
 385:main.c        **** 		}
 386:main.c        **** 	while (size);				// Loop until all bytes written
 387:main.c        **** 
 388:main.c        **** 	//eeprom_busy_wait();
 389:main.c        **** 
 390:main.c        **** 	return address;
 391:main.c        **** }
 392:main.c        **** 
 393:main.c        **** static void (*jump_to_app)(void) = 0x0000;
 394:main.c        **** 
 395:main.c        **** int main(void)
 396:main.c        **** {
 1042               	.LM127:
 1043               	.LFBB18:
 1044               	/* prologue: function */
 1045               	/* frame size = 0 */
 1046               	/* stack size = 0 */
 1047               	.L__stack_usage = 0
 397:main.c        **** 	port_init();							//инициализация портов
 1049               	.LM128:
 1050 0000 00D0      		rcall port_init
 398:main.c        **** 	spi_init();								//инициализация SPI
 1052               	.LM129:
 1053 0002 00D0      		rcall spi_init
 399:main.c        **** 	nrf24_init();
 1055               	.LM130:
 1056 0004 00D0      		rcall nrf24_init
 400:main.c        **** 
 401:main.c        **** 	uint8_t blink_counter = 2;
 402:main.c        **** 	uint16_t load_pause = 0;
 403:main.c        **** 
 404:main.c        **** 	while (blink_counter)
 405:main.c        **** 	{
 406:main.c        **** 		LED_ON();
 1058               	.LM131:
 1059 0006 969A      		sbi 0x12,6
 1060               	.LBB79:
 1061               	.LBB80:
 1063               	.Ltext23:
 187:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 1065               	.LM132:
 1066 0008 2FE7      		ldi r18,lo8(79999)
 1067 000a 88E3      		ldi r24,hi8(79999)
 1068 000c 91E0      		ldi r25,hlo8(79999)
 1069 000e 2150      	1:	subi r18,1
 1070 0010 8040      		sbci r24,0
 1071 0012 9040      		sbci r25,0
 1072 0014 01F4      		brne 1b
 1073 0016 00C0      		rjmp .
 1074 0018 0000      		nop
 1075               	.LBE80:
 1076               	.LBE79:
 1078               	.Ltext24:
 407:main.c        **** 		_delay_ms(50);
 408:main.c        **** 		LED_OFF();
 1080               	.LM133:
 1081 001a 9698      		cbi 0x12,6
 1082               	.LBB82:
 1083               	.LBB83:
 1085               	.Ltext25:
 187:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 1087               	.LM134:
 1088 001c EFE7      		ldi r30,lo8(79999)
 1089 001e F8E3      		ldi r31,hi8(79999)
 1090 0020 21E0      		ldi r18,hlo8(79999)
 1091 0022 E150      	1:	subi r30,1
 1092 0024 F040      		sbci r31,0
 1093 0026 2040      		sbci r18,0
 1094 0028 01F4      		brne 1b
 1095 002a 00C0      		rjmp .
 1096 002c 0000      		nop
 1097               	.LBE83:
 1098               	.LBE82:
 1100               	.Ltext26:
 406:main.c        **** 		_delay_ms(50);
 1102               	.LM135:
 1103 002e 969A      		sbi 0x12,6
 1104               	.LBB85:
 1105               	.LBB81:
 1107               	.Ltext27:
 187:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 1109               	.LM136:
 1110 0030 8FE7      		ldi r24,lo8(79999)
 1111 0032 98E3      		ldi r25,hi8(79999)
 1112 0034 E1E0      		ldi r30,hlo8(79999)
 1113 0036 8150      	1:	subi r24,1
 1114 0038 9040      		sbci r25,0
 1115 003a E040      		sbci r30,0
 1116 003c 01F4      		brne 1b
 1117 003e 00C0      		rjmp .
 1118 0040 0000      		nop
 1119               	.LBE81:
 1120               	.LBE85:
 1122               	.Ltext28:
 1124               	.LM137:
 1125 0042 9698      		cbi 0x12,6
 1126               	.LBB86:
 1127               	.LBB84:
 1129               	.Ltext29:
 187:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 1131               	.LM138:
 1132 0044 FFE7      		ldi r31,lo8(79999)
 1133 0046 28E3      		ldi r18,hi8(79999)
 1134 0048 81E0      		ldi r24,hlo8(79999)
 1135 004a F150      	1:	subi r31,1
 1136 004c 2040      		sbci r18,0
 1137 004e 8040      		sbci r24,0
 1138 0050 01F4      		brne 1b
 1139 0052 00C0      		rjmp .
 1140 0054 0000      		nop
 1141 0056 E12C      		mov r14,__zero_reg__
 1142 0058 F12C      		mov r15,__zero_reg__
 1143 005a C0E0      		ldi r28,0
 1144 005c D0E0      		ldi r29,0
 1145               	.LBE84:
 1146               	.LBE86:
 1147               	.LBB87:
 1149               	.Ltext30:
 409:main.c        **** 		_delay_ms(50);
 410:main.c        **** 		blink_counter--;
 411:main.c        **** 	}
 412:main.c        **** 
 413:main.c        **** 	uint16_t cnt = 0;
 414:main.c        **** 
 415:main.c        **** 	//wdt_enable(WDTO_1S);
 416:main.c        **** 
 417:main.c        **** 	while (1) 
 418:main.c        **** 	{
 419:main.c        **** 		nrf24_receive();
 420:main.c        **** 
 421:main.c        **** 		if(f_rx == 1)						//если флаг приема поднят
 422:main.c        **** 		{
 423:main.c        **** 			if (rx_buf[0] == BUT_ADDR)		//если первый принятый байт совпадает с адресом кнопки
 424:main.c        **** 			{
 425:main.c        **** 				if (rx_buf[1] == 'J')
 426:main.c        **** 				{
 427:main.c        **** 					jump_to_app();
 428:main.c        **** 				}
 429:main.c        **** 
 430:main.c        **** 				if (rx_buf[1] == 'E')	
 431:main.c        **** 				{
 432:main.c        **** 					eraseFlash();
 433:main.c        **** 				}
 434:main.c        **** 
 435:main.c        **** 				if (rx_buf[1] == 'W')	
 436:main.c        **** 				{
 437:main.c        **** 					LED_ON();
 438:main.c        **** 					tx_buf[0] = BUT_ADDR;
 439:main.c        **** 					tx_buf[1] = 'W';
 440:main.c        **** 					NRF24L01_Send(tx_buf);
 441:main.c        **** 					f_wait = 1;
 442:main.c        **** 				}
 443:main.c        **** 
 444:main.c        **** 				if (rx_buf[1] == 'F')		//
 445:main.c        **** 				{
 446:main.c        **** 					LED_TGL();
 1151               	.LM139:
 1152 005e 90E4      		ldi r25,lo8(64)
 1153 0060 492E      		mov r4,r25
 1154               	.LBB88:
 1155               	.LBB89:
 362:main.c        **** 
 1157               	.LM140:
 1158 0062 5524      		clr r5
 1159 0064 5394      		inc r5
 1160 0066 6624      		clr r6
 1161 0068 6394      		inc r6
 369:main.c        **** 	boot_spm_busy_wait();
 1163               	.LM141:
 1164 006a 25E0      		ldi r18,lo8(5)
 1165 006c 322E      		mov r3,r18
 371:main.c        **** 
 1167               	.LM142:
 1168 006e 31E1      		ldi r19,lo8(17)
 1169 0070 232E      		mov r2,r19
 1170               	.LBE89:
 1171               	.LBE88:
 447:main.c        **** 					pagebuf_t size;
 448:main.c        **** 					size = rx_buf[2];
 449:main.c        **** 					address = rx_buf[3]; //
 450:main.c        **** 
 451:main.c        **** 					for (uint8_t i = 0; i < size; i++)
 452:main.c        **** 					{
 453:main.c        **** 						gBuffer[i] = rx_buf[i+4];
 454:main.c        **** 					}
 455:main.c        **** 
 456:main.c        **** 					writeFlashPage(address, size);
 457:main.c        **** 					//_delay_ms(100);
 458:main.c        **** 					tx_buf[0] = BUT_ADDR;
 1173               	.LM143:
 1174 0072 17E0      		ldi r17,lo8(7)
 459:main.c        **** 					tx_buf[1] = 'N';
 1176               	.LM144:
 1177 0074 0EE4      		ldi r16,lo8(78)
 1178               	.LBE87:
 1179               	.LBB93:
 1180               	.LBB94:
 344:main.c        **** 		boot_spm_busy_wait();		// Wait until the memory is erased.
 1182               	.LM145:
 1183 0076 43E0      		ldi r20,lo8(3)
 1184 0078 742E      		mov r7,r20
 1185               	.LBE94:
 1186               	.LBE93:
 427:main.c        **** 				}
 1188               	.LM146:
 1189 007a C12C      		mov r12,__zero_reg__
 1190 007c D12C      		mov r13,__zero_reg__
 1191               	.L41:
 419:main.c        **** 
 1193               	.LM147:
 1194 007e 00D0      		rcall nrf24_receive
 421:main.c        **** 		{
 1196               	.LM148:
 1197 0080 8091 0000 		lds r24,f_rx
 1198 0084 8130      		cpi r24,lo8(1)
 1199 0086 01F0      		breq .+2
 1200 0088 00C0      		rjmp .L42
 423:main.c        **** 			{
 1202               	.LM149:
 1203 008a 8091 0000 		lds r24,rx_buf
 1204 008e 8730      		cpi r24,lo8(7)
 1205 0090 01F0      		breq .+2
 1206 0092 00C0      		rjmp .L43
 425:main.c        **** 				{
 1208               	.LM150:
 1209 0094 8091 0000 		lds r24,rx_buf+1
 1210 0098 8A34      		cpi r24,lo8(74)
 1211 009a 01F4      		brne .L44
 427:main.c        **** 				}
 1213               	.LM151:
 1214 009c F601      		movw r30,r12
 1215 009e 0995      		icall
 1216               	.L44:
 430:main.c        **** 				{
 1218               	.LM152:
 1219 00a0 8091 0000 		lds r24,rx_buf+1
 1220 00a4 8534      		cpi r24,lo8(69)
 1221 00a6 01F4      		brne .L45
 1222 00a8 E0E0      		ldi r30,0
 1223 00aa F0E0      		ldi r31,0
 1224               	.L47:
 1225               	.LBB96:
 1226               	.LBB95:
 344:main.c        **** 		boot_spm_busy_wait();		// Wait until the memory is erased.
 1228               	.LM153:
 1229               	/* #APP */
 1230               	 ;  344 "main.c" 1
 1231 00ac 7092 5700 		sts 87, r7
 1232 00b0 E895      		spm
 1233               		
 1234               	 ;  0 "" 2
 1235               	/* #NOAPP */
 1236               	.L46:
 345:main.c        **** 		addr += SPM_PAGESIZE;
 1238               	.LM154:
 1239 00b2 07B6      		in __tmp_reg__,0x37
 1240 00b4 00FC      		sbrc __tmp_reg__,0
 1241 00b6 00C0      		rjmp .L46
 1242 00b8 E05C      		subi r30,-64
 1243 00ba FF4F      		sbci r31,-1
 342:main.c        **** 	{
 1245               	.LM155:
 1246 00bc E115      		cp r30,__zero_reg__
 1247 00be 28E1      		ldi r18,24
 1248 00c0 F207      		cpc r31,r18
 1249 00c2 01F4      		brne .L47
 348:main.c        **** }
 1251               	.LM156:
 1252               	/* #APP */
 1253               	 ;  348 "main.c" 1
 1254 00c4 2092 5700 		sts 87, r2
 1255 00c8 E895      		spm
 1256               		
 1257               	 ;  0 "" 2
 1258               	/* #NOAPP */
 1259 00ca 00C0      		rjmp .L48
 1260               	.L45:
 1261               	.LBE95:
 1262               	.LBE96:
 435:main.c        **** 				{
 1264               	.LM157:
 1265 00cc 8735      		cpi r24,lo8(87)
 1266 00ce 01F4      		brne .L48
 437:main.c        **** 					tx_buf[0] = BUT_ADDR;
 1268               	.LM158:
 1269 00d0 969A      		sbi 0x12,6
 438:main.c        **** 					tx_buf[1] = 'W';
 1271               	.LM159:
 1272 00d2 1093 0000 		sts tx_buf,r17
 439:main.c        **** 					NRF24L01_Send(tx_buf);
 1274               	.LM160:
 1275 00d6 8093 0000 		sts tx_buf+1,r24
 440:main.c        **** 					f_wait = 1;
 1277               	.LM161:
 1278 00da 80E0      		ldi r24,lo8(tx_buf)
 1279 00dc 90E0      		ldi r25,hi8(tx_buf)
 1280 00de 00D0      		rcall NRF24L01_Send
 441:main.c        **** 				}
 1282               	.LM162:
 1283 00e0 6092 0000 		sts f_wait,r6
 1284               	.L48:
 444:main.c        **** 				{
 1286               	.LM163:
 1287 00e4 8091 0000 		lds r24,rx_buf+1
 1288 00e8 8634      		cpi r24,lo8(70)
 1289 00ea 01F0      		breq .+2
 1290 00ec 00C0      		rjmp .L43
 1291               	.LBB97:
 446:main.c        **** 					pagebuf_t size;
 1293               	.LM164:
 1294 00ee 82B3      		in r24,0x12
 1295 00f0 8425      		eor r24,r4
 1296 00f2 82BB      		out 0x12,r24
 448:main.c        **** 					address = rx_buf[3]; //
 1298               	.LM165:
 1299 00f4 6091 0000 		lds r22,rx_buf+2
 449:main.c        **** 
 1301               	.LM166:
 1302 00f8 8091 0000 		lds r24,rx_buf+3
 1303 00fc 282F      		mov r18,r24
 1304 00fe 30E0      		ldi r19,0
 1305 0100 3093 0000 		sts address+1,r19
 1306 0104 2093 0000 		sts address,r18
 1307 0108 A0E0      		ldi r26,lo8(rx_buf+4)
 1308 010a B0E0      		ldi r27,hi8(rx_buf+4)
 1309               	.LBB91:
 451:main.c        **** 					{
 1311               	.LM167:
 1312 010c E0E0      		ldi r30,lo8(gBuffer)
 1313 010e F0E0      		ldi r31,hi8(gBuffer)
 1314 0110 90E0      		ldi r25,0
 1315               	.L49:
 451:main.c        **** 					{
 1317               	.LM168:
 1318 0112 9617      		cp r25,r22
 1319 0114 01F0      		breq .L60
 453:main.c        **** 					}
 1321               	.LM169:
 1322 0116 2D91      		ld r18,X+
 1323 0118 2193      		st Z+,r18
 451:main.c        **** 					{
 1325               	.LM170:
 1326 011a 9F5F      		subi r25,lo8(-(1))
 1327 011c 00C0      		rjmp .L49
 1328               	.L60:
 1329               	.LBE91:
 1330               	.LBB92:
 1331               	.LBB90:
 353:main.c        **** 	uint32_t baddr = pagestart;
 1333               	.LM171:
 1334 011e 90E0      		ldi r25,0
 1335 0120 A0E0      		ldi r26,0
 1336 0122 B0E0      		ldi r27,0
 1337 0124 4C01      		movw r8,r24
 1338 0126 5D01      		movw r10,r26
 1339 0128 880C      		lsl r8
 1340 012a 991C      		rol r9
 1341 012c AA1C      		rol r10
 1342 012e BB1C      		rol r11
 356:main.c        **** 
 1344               	.LM172:
 1345 0130 2091 0000 		lds r18,gBuffer
 1346 0134 A0E0      		ldi r26,lo8(gBuffer)
 1347 0136 B0E0      		ldi r27,hi8(gBuffer)
 1348 0138 A401      		movw r20,r8
 362:main.c        **** 
 1350               	.LM173:
 1351 013a C401      		movw r24,r8
 1352 013c 8050      		subi r24,lo8(gBuffer)
 1353 013e 9040      		sbci r25,hi8(gBuffer)
 1354               	.L52:
 1355 0140 FC01      		movw r30,r24
 1356 0142 EA0F      		add r30,r26
 1357 0144 FB1F      		adc r31,r27
 1358 0146 1196      		adiw r26,1
 1359 0148 7C91      		ld r23,X
 1360 014a 1197      		sbiw r26,1
 1361 014c 30E0      		ldi r19,0
 1362 014e 372B      		or r19,r23
 1363               	/* #APP */
 1364               	 ;  362 "main.c" 1
 1365 0150 0901      		movw  r0, r18
 1366 0152 5092 5700 		sts 87, r5
 1367 0156 E895      		spm
 1368 0158 1124      		clr  r1
 1369               		
 1370               	 ;  0 "" 2
 365:main.c        **** 		} 
 1372               	.LM174:
 1373               	/* #NOAPP */
 1374 015a 6250      		subi r22,lo8(-(-2))
 1375 015c 1296      		adiw r26,2
 367:main.c        **** 
 1377               	.LM175:
 1378 015e 6623      		tst r22
 1379 0160 01F0      		breq .L51
 361:main.c        **** 		boot_page_fill(baddr, data);	// call asm routine.
 1381               	.LM176:
 1382 0162 2C91      		ld r18,X
 1383 0164 00C0      		rjmp .L52
 1384               	.L51:
 369:main.c        **** 	boot_spm_busy_wait();
 1386               	.LM177:
 1387 0166 FA01      		movw r30,r20
 1388               	/* #APP */
 1389               	 ;  369 "main.c" 1
 1390 0168 3092 5700 		sts 87, r3
 1391 016c E895      		spm
 1392               		
 1393               	 ;  0 "" 2
 1394               	/* #NOAPP */
 1395               	.L53:
 370:main.c        **** 	boot_rww_enable();		// Re-enable the RWW section
 1397               	.LM178:
 1398 016e 07B6      		in __tmp_reg__,0x37
 1399 0170 00FC      		sbrc __tmp_reg__,0
 1400 0172 00C0      		rjmp .L53
 371:main.c        **** 
 1402               	.LM179:
 1403               	/* #APP */
 1404               	 ;  371 "main.c" 1
 1405 0174 2092 5700 		sts 87, r2
 1406 0178 E895      		spm
 1407               		
 1408               	 ;  0 "" 2
 1409               	/* #NOAPP */
 1410               	.LBE90:
 1411               	.LBE92:
 458:main.c        **** 					tx_buf[1] = 'N';
 1413               	.LM180:
 1414 017a 1093 0000 		sts tx_buf,r17
 1416               	.LM181:
 1417 017e 0093 0000 		sts tx_buf+1,r16
 460:main.c        **** 					NRF24L01_Send(tx_buf);
 1419               	.LM182:
 1420 0182 80E0      		ldi r24,lo8(tx_buf)
 1421 0184 90E0      		ldi r25,hi8(tx_buf)
 1422 0186 00D0      		rcall NRF24L01_Send
 461:main.c        **** 					load_pause = 0;
 1424               	.LM183:
 1425 0188 C0E0      		ldi r28,0
 1426 018a D0E0      		ldi r29,0
 1427               	.L43:
 1428               	.LBE97:
 462:main.c        **** 				}
 463:main.c        **** 
 464:main.c        **** 			}
 465:main.c        **** 
 466:main.c        **** 			f_rx = 0;						//опускаем флаг приема
 1430               	.LM184:
 1431 018c 1092 0000 		sts f_rx,__zero_reg__
 1432               	.L42:
 467:main.c        **** 		}
 468:main.c        **** 
 469:main.c        **** 		wdt_reset();
 1434               	.LM185:
 1435               	/* #APP */
 1436               	 ;  469 "main.c" 1
 1437 0190 A895      		wdr
 1438               	 ;  0 "" 2
 470:main.c        **** 
 471:main.c        **** 		if (!f_wait)
 1440               	.LM186:
 1441               	/* #NOAPP */
 1442 0192 8091 0000 		lds r24,f_wait
 1443 0196 8111      		cpse r24,__zero_reg__
 1444 0198 00C0      		rjmp .L54
 472:main.c        **** 		{
 473:main.c        **** 			if (cnt++ >= WAIT_VALUE) 
 1446               	.LM187:
 1447 019a 4701      		movw r8,r14
 1448 019c FFEF      		ldi r31,-1
 1449 019e 8F1A      		sub r8,r31
 1450 01a0 9F0A      		sbc r9,r31
 1451 01a2 28EE      		ldi r18,-24
 1452 01a4 E216      		cp r14,r18
 1453 01a6 23E0      		ldi r18,3
 1454 01a8 F206      		cpc r15,r18
 1455 01aa 00F0      		brlo .L55
 474:main.c        **** 			{
 475:main.c        **** 				jump_to_app();			// Jump to application sector
 1457               	.LM188:
 1458 01ac F601      		movw r30,r12
 1459 01ae 0995      		icall
 1460               	.L55:
 1461               	.LBB98:
 1462               	.LBB99:
 1464               	.Ltext31:
 187:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 1466               	.LM189:
 1467 01b0 8FEC      		ldi r24,lo8(1999)
 1468 01b2 97E0      		ldi r25,hi8(1999)
 1469 01b4 0197      	1:	sbiw r24,1
 1470 01b6 01F4      		brne 1b
 1471 01b8 00C0      		rjmp .
 1472 01ba 0000      		nop
 1473               	.LBE99:
 1474               	.LBE98:
 1476               	.Ltext32:
 473:main.c        **** 			{
 1478               	.LM190:
 1479 01bc 7401      		movw r14,r8
 1480 01be 00C0      		rjmp .L41
 1481               	.L54:
 476:main.c        **** 			}
 477:main.c        **** 			_delay_ms(1);		
 478:main.c        **** 		}
 479:main.c        **** 		else
 480:main.c        **** 		{
 481:main.c        **** 			load_pause++;
 1483               	.LM191:
 1484 01c0 2196      		adiw r28,1
 482:main.c        **** 			if (load_pause >= 1000)
 1486               	.LM192:
 1487 01c2 C83E      		cpi r28,-24
 1488 01c4 93E0      		ldi r25,3
 1489 01c6 D907      		cpc r29,r25
 1490 01c8 00F4      		brsh .+2
 1491 01ca 00C0      		rjmp .L41
 483:main.c        **** 			{
 484:main.c        **** 				tx_buf[0] = BUT_ADDR;
 1493               	.LM193:
 1494 01cc 1093 0000 		sts tx_buf,r17
 485:main.c        **** 				tx_buf[1] = 'N';
 1496               	.LM194:
 1497 01d0 0093 0000 		sts tx_buf+1,r16
 486:main.c        **** 				NRF24L01_Send(tx_buf);
 1499               	.LM195:
 1500 01d4 80E0      		ldi r24,lo8(tx_buf)
 1501 01d6 90E0      		ldi r25,hi8(tx_buf)
 1502 01d8 00D0      		rcall NRF24L01_Send
 1503               	.LBB100:
 1504               	.LBB101:
 1506               	.Ltext33:
 187:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 1508               	.LM196:
 1509 01da EFEC      		ldi r30,lo8(1999)
 1510 01dc F7E0      		ldi r31,hi8(1999)
 1511 01de 3197      	1:	sbiw r30,1
 1512 01e0 01F4      		brne 1b
 1513 01e2 00C0      		rjmp .
 1514 01e4 0000      		nop
 1515               	.LBE101:
 1516               	.LBE100:
 1518               	.Ltext34:
 487:main.c        **** 				_delay_ms(1);
 488:main.c        **** 				load_pause = 0;
 1520               	.LM197:
 1521 01e6 C0E0      		ldi r28,0
 1522 01e8 D0E0      		ldi r29,0
 1523 01ea 00C0      		rjmp .L41
 1543               	.Lscope18:
 1544               		.comm	gBuffer,64,1
 1545               	.global	f_wait
 1546               		.section .bss
 1549               	f_wait:
 1550 0000 00        		.zero	1
 1551               		.comm	val,1,1
 1552               	.global	device
 1555               	device:
 1556 0001 00        		.zero	1
 1557               	.global	address
 1560               	address:
 1561 0002 0000      		.zero	2
 1562               		.comm	buf,20,1
 1563               		.comm	f_send,1,1
 1564               	.global	f_tx
 1567               	f_tx:
 1568 0004 00        		.zero	1
 1569               	.global	f_rx
 1572               	f_rx:
 1573 0005 00        		.zero	1
 1574               	.global	tx_buf
 1577               	tx_buf:
 1578 0006 0000 0000 		.zero	32
 1578      0000 0000 
 1578      0000 0000 
 1578      0000 0000 
 1578      0000 0000 
 1579               	.global	rx_buf
 1582               	rx_buf:
 1583 0026 0000 0000 		.zero	32
 1583      0000 0000 
 1583      0000 0000 
 1583      0000 0000 
 1583      0000 0000 
 1584               	.global	TX_ADDRESS1
 1585               		.data
 1588               	TX_ADDRESS1:
 1589 0000 B7        		.byte	-73
 1590 0001 B5        		.byte	-75
 1591 0002 A1        		.byte	-95
 1592               	.global	TX_ADDRESS0
 1595               	TX_ADDRESS0:
 1596 0003 B5        		.byte	-75
 1597 0004 B5        		.byte	-75
 1598 0005 A1        		.byte	-95
 1612               		.text
 1614               	.Letext0:
 1615               		.ident	"GCC: (AVR_8_bit_GNU_Toolchain_3.6.2_1778) 5.4.0"
 1616               	.global __do_copy_data
 1617               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
C:\Users\vmelehin\AppData\Local\Temp\ccPcKmfc.s:2      *ABS*:0000003e __SP_H__
C:\Users\vmelehin\AppData\Local\Temp\ccPcKmfc.s:3      *ABS*:0000003d __SP_L__
C:\Users\vmelehin\AppData\Local\Temp\ccPcKmfc.s:4      *ABS*:0000003f __SREG__
C:\Users\vmelehin\AppData\Local\Temp\ccPcKmfc.s:5      *ABS*:00000000 __tmp_reg__
C:\Users\vmelehin\AppData\Local\Temp\ccPcKmfc.s:6      *ABS*:00000001 __zero_reg__
C:\Users\vmelehin\AppData\Local\Temp\ccPcKmfc.s:136    .text:00000000 port_init
C:\Users\vmelehin\AppData\Local\Temp\ccPcKmfc.s:172    .text:00000016 spi_init
C:\Users\vmelehin\AppData\Local\Temp\ccPcKmfc.s:201    .text:00000028 spi_sendByte
C:\Users\vmelehin\AppData\Local\Temp\ccPcKmfc.s:227    .text:00000030 spi_changeByte
C:\Users\vmelehin\AppData\Local\Temp\ccPcKmfc.s:255    .text:0000003a NRF24_ReadReg
C:\Users\vmelehin\AppData\Local\Temp\ccPcKmfc.s:298    .text:00000050 NRF24_WriteReg
C:\Users\vmelehin\AppData\Local\Temp\ccPcKmfc.s:332    .text:00000064 NRF24_ToggleFeatures
C:\Users\vmelehin\AppData\Local\Temp\ccPcKmfc.s:376    .text:0000007a NRF24_Read_Buf
C:\Users\vmelehin\AppData\Local\Temp\ccPcKmfc.s:441    .text:000000bc NRF24_Write_Buf
C:\Users\vmelehin\AppData\Local\Temp\ccPcKmfc.s:515    .text:00000100 NRF24_FlushRX
C:\Users\vmelehin\AppData\Local\Temp\ccPcKmfc.s:553    .text:00000112 NRF24_FlushTX
C:\Users\vmelehin\AppData\Local\Temp\ccPcKmfc.s:591    .text:00000124 NRF24L01_RX_Mode
C:\Users\vmelehin\AppData\Local\Temp\ccPcKmfc.s:1588   .data:00000000 TX_ADDRESS1
C:\Users\vmelehin\AppData\Local\Temp\ccPcKmfc.s:654    .text:00000156 NRF24L01_TX_Mode
C:\Users\vmelehin\AppData\Local\Temp\ccPcKmfc.s:1595   .data:00000003 TX_ADDRESS0
C:\Users\vmelehin\AppData\Local\Temp\ccPcKmfc.s:692    .text:00000170 NRF24_Transmit
C:\Users\vmelehin\AppData\Local\Temp\ccPcKmfc.s:772    .text:000001b6 NRF24L01_Send
C:\Users\vmelehin\AppData\Local\Temp\ccPcKmfc.s:869    .text:00000200 nrf24_init
C:\Users\vmelehin\AppData\Local\Temp\ccPcKmfc.s:996    .text:00000278 nrf24_receive
C:\Users\vmelehin\AppData\Local\Temp\ccPcKmfc.s:1582   .bss:00000026 rx_buf
C:\Users\vmelehin\AppData\Local\Temp\ccPcKmfc.s:1572   .bss:00000005 f_rx
C:\Users\vmelehin\AppData\Local\Temp\ccPcKmfc.s:1040   .text.startup:00000000 main
C:\Users\vmelehin\AppData\Local\Temp\ccPcKmfc.s:1577   .bss:00000006 tx_buf
C:\Users\vmelehin\AppData\Local\Temp\ccPcKmfc.s:1549   .bss:00000000 f_wait
C:\Users\vmelehin\AppData\Local\Temp\ccPcKmfc.s:1560   .bss:00000002 address
                            *COM*:00000040 gBuffer
                            *COM*:00000001 val
C:\Users\vmelehin\AppData\Local\Temp\ccPcKmfc.s:1555   .bss:00000001 device
                            *COM*:00000014 buf
                            *COM*:00000001 f_send
C:\Users\vmelehin\AppData\Local\Temp\ccPcKmfc.s:1567   .bss:00000004 f_tx

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
