   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
 134               	.global	port_init
 136               	port_init:
   1:main.c        **** 
   2:main.c        **** #define F_CPU 8000000UL
   3:main.c        **** 
   4:main.c        **** #include <avr/io.h>
   5:main.c        **** #include <avr/interrupt.h>
   6:main.c        **** #include <util/delay.h>
   7:main.c        **** #include <avr/wdt.h>
   8:main.c        **** #include <stdio.h>
   9:main.c        **** #include <stdlib.h>
  10:main.c        **** #include <string.h>
  11:main.c        **** #include <stdint.h>
  12:main.c        **** #include <avr/boot.h>
  13:main.c        **** #include <avr/pgmspace.h>
  14:main.c        **** #include <avr/eeprom.h>
  15:main.c        **** #include "chipdef.h"
  16:main.c        **** 
  17:main.c        **** #define BUT_ADDR 		0x07				//адрес кнопки
  18:main.c        **** #define RESET 			0xFF				//команда сброса
  19:main.c        **** #define NOT_PUSHED 		0xFFFFFFFF			//сообщение "кнопка не нажата"
  20:main.c        **** 
  21:main.c        **** #define LED_Pin PORTD6			//пин светодиода
  22:main.c        **** #define LED_GPIO_Port PORTD		//порт светодиода
  23:main.c        **** #define IRQ_Pin PORTD2			//пин прерывания радиомодуля
  24:main.c        **** #define IRQ_GPIO_Port PORTD2	//порт прерывания радиомодуля
  25:main.c        **** #define CE_Pin PORTB0			//пин CE
  26:main.c        **** #define CE_GPIO_Port PORTB		//порт CE
  27:main.c        **** #define CSN_Pin PORTD7			//пин CSN
  28:main.c        **** #define CSN_GPIO_Port PORTD		//порт CSN
  29:main.c        **** 
  30:main.c        **** #define WAIT_VALUE 1000 //в мс
  31:main.c        **** 
  32:main.c        **** //------------------------------------------------
  33:main.c        **** #define CS_ON()			CSN_GPIO_Port&=~(1<<CSN_Pin)
  34:main.c        **** #define CS_OFF()		CSN_GPIO_Port|=(1<<CSN_Pin)
  35:main.c        **** #define CE_RESET()		CE_GPIO_Port&=~(1<<CE_Pin)
  36:main.c        **** #define CE_SET()		CE_GPIO_Port|=(1<<CE_Pin)
  37:main.c        **** 
  38:main.c        **** #define LED_ON()		LED_GPIO_Port|=(1<<LED_Pin)
  39:main.c        **** #define LED_OFF()		LED_GPIO_Port&=~(1<<LED_Pin)
  40:main.c        **** #define LED_TGL()		LED_GPIO_Port^=(1<<LED_Pin)
  41:main.c        **** //------------------------------------------------
  42:main.c        **** #define ACTIVATE 		0x50 //
  43:main.c        **** #define RD_RX_PLOAD		0x61 // Define RX payload register address
  44:main.c        **** #define WR_TX_PLOAD		0xA0 // Define TX payload register address
  45:main.c        **** #define FLUSH_TX 		0xE1
  46:main.c        **** #define FLUSH_RX 		0xE2
  47:main.c        **** //------------------------------------------------
  48:main.c        **** #define CONFIG 			0x00 //'Config' register address
  49:main.c        **** #define EN_AA 			0x01 //'Enable Auto Acknowledgment' register address
  50:main.c        **** #define EN_RXADDR 		0x02 //'Enabled RX addresses' register address
  51:main.c        **** #define SETUP_AW 		0x03 //'Setup address width' register address
  52:main.c        **** #define SETUP_RETR 		0x04 //'Setup Auto. Retrans' register address
  53:main.c        **** #define RF_CH 			0x05 //'RF channel' register address
  54:main.c        **** #define RF_SETUP 		0x06 //'RF setup' register address
  55:main.c        **** #define STATUS 			0x07 //'Status' register address
  56:main.c        **** #define OBSERVE_TX 		0x08 //'Transmit observe' register
  57:main.c        **** #define RX_ADDR_P0 		0x0A //'RX address pipe0' register address
  58:main.c        **** #define RX_ADDR_P1 		0x0B //'RX address pipe1' register address
  59:main.c        **** #define TX_ADDR 		0x10 //'TX address' register address
  60:main.c        **** #define RX_PW_P0 		0x11 //'RX payload width, pipe0' register address
  61:main.c        **** #define RX_PW_P1 		0x12 //'RX payload width, pipe1' register address
  62:main.c        **** #define FIFO_STATUS		0x17 //'FIFO Status Register' register address
  63:main.c        **** #define DYNPD 			0x1C
  64:main.c        **** #define FEATURE 		0x1D
  65:main.c        **** //------------------------------------------------
  66:main.c        **** #define PRIM_RX 		0x00 //RX/TX control (1: PRX, 0: PTX)
  67:main.c        **** #define PWR_UP 			0x01 //1: POWER UP, 0:POWER DOWN
  68:main.c        **** #define RX_DR 			0x40 //Data Ready RX FIFO interrupt
  69:main.c        **** #define TX_DS 			0x20 //Data Sent TX FIFO interrupt
  70:main.c        **** #define MAX_RT 			0x10 //Maximum number of TX retransmits interrupt
  71:main.c        **** //------------------------------------------------
  72:main.c        **** #define W_REGISTER 		0x20 //запись в регистр
  73:main.c        **** //------------------------------------------------
  74:main.c        **** #define TX_ADR_WIDTH 3						//размер адреса передачи
  75:main.c        **** #define TX_PLOAD_WIDTH 32					//размер полезной нагрузки
  76:main.c        **** //максимальное число байт, чтобы при добавлении новых функций не переделывать задержки
  77:main.c        **** 
  78:main.c        **** uint8_t TX_ADDRESS0[TX_ADR_WIDTH] = {0xb5,0xb5,0xa1};	//адрес 0
  79:main.c        **** uint8_t TX_ADDRESS1[TX_ADR_WIDTH] = {0xb7,0xb5,0xa1};	//адрес 1
  80:main.c        **** 
  81:main.c        **** uint8_t rx_buf[TX_PLOAD_WIDTH] = {0};				//буфер приема
  82:main.c        **** uint8_t tx_buf[TX_PLOAD_WIDTH] = {0};				//буфер передачи
  83:main.c        **** 
  84:main.c        **** volatile uint8_t f_rx = 0, f_tx = 0;				//флаги приема и передачи
  85:main.c        **** 
  86:main.c        **** uint8_t f_send;								//флаг отправки
  87:main.c        **** 
  88:main.c        **** uint8_t buf[20];							//буфер
  89:main.c        **** uint8_t device, val;
  90:main.c        **** uint8_t f_wait = 0;
  91:main.c        **** 
  92:main.c        **** void nrf24_init(void);
  93:main.c        **** uint8_t NRF24_ReadReg(uint8_t addr);
  94:main.c        **** void NRF24_Read_Buf(uint8_t addr,uint8_t *pBuf,uint8_t bytes);
  95:main.c        **** uint8_t NRF24L01_Send(uint8_t *pBuf);
  96:main.c        **** void nrf24l01_receive(void);
  97:main.c        **** 
  98:main.c        **** uint8_t gBuffer[SPM_PAGESIZE];
  99:main.c        **** uint16_t address = 0;
 100:main.c        **** uint8_t device = 0, val;
 101:main.c        **** 
 102:main.c        **** void port_init(void)//Инициализация портов
 103:main.c        **** {
 138               	.LM0:
 139               	.LFBB1:
 140               	/* prologue: function */
 141               	/* frame size = 0 */
 142               	/* stack size = 0 */
 143               	.L__stack_usage = 0
 104:main.c        **** 	// Input/Output Ports initialization
 105:main.c        **** 	// Port B initialization
 106:main.c        **** 	// Function: Bit7=In Bit6=In Bit5=Out Bit4=In Bit3=Out Bit2=Out Bit1=In Bit0=Out
 107:main.c        **** 	DDRB=(0<<DDB7) | (0<<DDB6) | (1<<DDB5) | (0<<DDB4) | (1<<DDB3) | (1<<DDB2) | (0<<DDB1) | (1<<DDB0)
 145               	.LM1:
 146 0000 8DE2      		ldi r24,lo8(45)
 147 0002 87BB      		out 0x17,r24
 108:main.c        **** 	// State: Bit7=T Bit6=T Bit5=0 Bit4=T Bit3=0 Bit2=0 Bit1=T Bit0=0
 109:main.c        **** 	PORTB=(0<<PORTB7) | (0<<PORTB6) | (0<<PORTB5) | (0<<PORTB4) | (0<<PORTB3) | (0<<PORTB2) | (0<<PORT
 149               	.LM2:
 150 0004 81E0      		ldi r24,lo8(1)
 151 0006 88BB      		out 0x18,r24
 110:main.c        **** 
 111:main.c        **** 	// Port C initialization
 112:main.c        **** 	// Function: Bit6=In Bit5=In Bit4=In Bit3=In Bit2=In Bit1=In Bit0=In
 113:main.c        **** 	DDRC=(0<<DDC6) | (0<<DDC5) | (0<<DDC4) | (0<<DDC3) | (0<<DDC2) | (0<<DDC1) | (0<<DDC0);
 153               	.LM3:
 154 0008 14BA      		out 0x14,__zero_reg__
 114:main.c        **** 	// State: Bit6=T Bit5=T Bit4=T Bit3=T Bit2=T Bit1=T Bit0=T
 115:main.c        **** 	PORTC=(0<<PORTC6) | (0<<PORTC5) | (0<<PORTC4) | (0<<PORTC3) | (0<<PORTC2) | (0<<PORTC1) | (0<<PORT
 156               	.LM4:
 157 000a 15BA      		out 0x15,__zero_reg__
 116:main.c        **** 
 117:main.c        **** 	// Port D initialization
 118:main.c        **** 	// Function: Bit7=Out Bit6=Out Bit5=In Bit4=In Bit3=In Bit2=In Bit1=In Bit0=In
 119:main.c        **** 	DDRD=(1<<DDD7) | (1<<DDD6) | (0<<DDD5) | (0<<DDD4) | (0<<DDD3) | (0<<DDD2) | (0<<DDD1) | (0<<DDD0)
 159               	.LM5:
 160 000c 80EC      		ldi r24,lo8(-64)
 161 000e 81BB      		out 0x11,r24
 120:main.c        **** 	// State: Bit7=0 Bit6=0 Bit5=T Bit4=T Bit3=P Bit2=T Bit1=T Bit0=T
 121:main.c        **** 	PORTD=(1<<PORTD7) | (0<<PORTD6) | (0<<PORTD5) | (0<<PORTD4) | (1<<PORTD3) | (0<<PORTD2) | (0<<PORT
 163               	.LM6:
 164 0010 88E8      		ldi r24,lo8(-120)
 165 0012 82BB      		out 0x12,r24
 166 0014 0895      		ret
 168               	.Lscope1:
 170               	.global	spi_init
 172               	spi_init:
 122:main.c        **** }
 123:main.c        **** 
 124:main.c        **** //инициализация SPI
 125:main.c        **** void spi_init(void)
 126:main.c        **** {
 174               	.LM7:
 175               	.LFBB2:
 176               	/* prologue: function */
 177               	/* frame size = 0 */
 178               	/* stack size = 0 */
 179               	.L__stack_usage = 0
 127:main.c        **** 	DDRB |= ((1<<PORTB2)|(1<<PORTB3)|(1<<PORTB5)); //ножки SPI на выход
 181               	.LM8:
 182 0016 87B3      		in r24,0x17
 183 0018 8C62      		ori r24,lo8(44)
 184 001a 87BB      		out 0x17,r24
 128:main.c        **** 	PORTB &= ~((1<<PORTB2)|(1<<PORTB3)|(1<<PORTB5)); //низкий уровень
 186               	.LM9:
 187 001c 88B3      		in r24,0x18
 188 001e 837D      		andi r24,lo8(-45)
 189 0020 88BB      		out 0x18,r24
 129:main.c        **** 	SPCR=(0<<SPIE) | (1<<SPE) | (0<<DORD) | (1<<MSTR) | (0<<CPOL) | (0<<CPHA) | (0<<SPR1) | (0<<SPR0);
 191               	.LM10:
 192 0022 80E5      		ldi r24,lo8(80)
 193 0024 8DB9      		out 0xd,r24
 194 0026 0895      		ret
 196               	.Lscope2:
 199               	.global	spi_sendByte
 201               	spi_sendByte:
 130:main.c        **** }
 131:main.c        **** 
 132:main.c        **** //отправка байта
 133:main.c        **** void spi_sendByte(uint8_t byte)
 134:main.c        **** {
 203               	.LM11:
 204               	.LFBB3:
 205               	/* prologue: function */
 206               	/* frame size = 0 */
 207               	/* stack size = 0 */
 208               	.L__stack_usage = 0
 135:main.c        **** 	SPDR = byte;				//записываем байт в регистр
 210               	.LM12:
 211 0028 8FB9      		out 0xf,r24
 212               	.L4:
 136:main.c        **** 	while(!(SPSR & (1<<SPIF)));	//подождем пока данные передадутся
 214               	.LM13:
 215 002a 779B      		sbis 0xe,7
 216 002c 00C0      		rjmp .L4
 217               	/* epilogue start */
 137:main.c        **** }
 219               	.LM14:
 220 002e 0895      		ret
 222               	.Lscope3:
 225               	.global	spi_changeByte
 227               	spi_changeByte:
 138:main.c        **** 
 139:main.c        **** //прием/отправка байта
 140:main.c        **** uint8_t spi_changeByte(uint8_t byte)
 141:main.c        **** {
 229               	.LM15:
 230               	.LFBB4:
 231               	/* prologue: function */
 232               	/* frame size = 0 */
 233               	/* stack size = 0 */
 234               	.L__stack_usage = 0
 142:main.c        **** 	SPDR = byte;				//записываем байт в регистр
 236               	.LM16:
 237 0030 8FB9      		out 0xf,r24
 238               	.L8:
 143:main.c        **** 	while(!(SPSR & (1<<SPIF)));	//подождем пока данные передадутся (обменяются)
 240               	.LM17:
 241 0032 779B      		sbis 0xe,7
 242 0034 00C0      		rjmp .L8
 144:main.c        **** 	return SPDR;				//возвращаем принятое значение
 244               	.LM18:
 245 0036 8FB1      		in r24,0xf
 145:main.c        **** }
 247               	.LM19:
 248 0038 0895      		ret
 250               	.Lscope4:
 253               	.global	NRF24_ReadReg
 255               	NRF24_ReadReg:
 146:main.c        **** 
 147:main.c        **** //функция чтения регистра модуля
 148:main.c        **** uint8_t NRF24_ReadReg(uint8_t addr)
 149:main.c        **** {
 257               	.LM20:
 258               	.LFBB5:
 259 003a CF93      		push r28
 260               	/* prologue: function */
 261               	/* frame size = 0 */
 262               	/* stack size = 1 */
 263               	.L__stack_usage = 1
 264 003c C82F      		mov r28,r24
 150:main.c        **** 	uint8_t dt=0, cmd;								//переменные данных и команды
 151:main.c        **** 	CS_ON();											//ногу cs к земле
 266               	.LM21:
 267 003e 9798      		cbi 0x12,7
 152:main.c        **** 	dt = spi_changeByte(addr);						//Прием/отправкадайта адреса регистра
 269               	.LM22:
 270 0040 00D0      		rcall spi_changeByte
 153:main.c        **** 	//если адрес равен адрес регистра статус то и возварщаем его состояние
 154:main.c        **** 	if (addr!=STATUS)//а если не равен
 272               	.LM23:
 273 0042 C730      		cpi r28,lo8(7)
 274 0044 01F0      		breq .L11
 155:main.c        **** 	{
 156:main.c        **** 		cmd=0xFF;									//команда NOP для получения данных
 157:main.c        **** 		dt = spi_changeByte(cmd);					//
 276               	.LM24:
 277 0046 8FEF      		ldi r24,lo8(-1)
 278 0048 00D0      		rcall spi_changeByte
 279               	.L11:
 158:main.c        **** 	}
 159:main.c        **** 	CS_OFF();											//поднимаем ногу CS
 281               	.LM25:
 282 004a 979A      		sbi 0x12,7
 283               	/* epilogue start */
 160:main.c        **** 	return dt;	//возвращаемое значение
 161:main.c        **** }
 285               	.LM26:
 286 004c CF91      		pop r28
 287 004e 0895      		ret
 292               	.Lscope5:
 296               	.global	NRF24_WriteReg
 298               	NRF24_WriteReg:
 162:main.c        **** //------------------------------------------------
 163:main.c        **** //функция записи регистра в модуль
 164:main.c        **** void NRF24_WriteReg(uint8_t addr, uint8_t dt)
 165:main.c        **** {
 300               	.LM27:
 301               	.LFBB6:
 302 0050 CF93      		push r28
 303               	/* prologue: function */
 304               	/* frame size = 0 */
 305               	/* stack size = 1 */
 306               	.L__stack_usage = 1
 307 0052 C62F      		mov r28,r22
 166:main.c        **** 	addr |= W_REGISTER;//включим бит записи в адрес
 167:main.c        **** 	CS_ON();
 309               	.LM28:
 310 0054 9798      		cbi 0x12,7
 168:main.c        **** 	spi_sendByte(addr);									//
 312               	.LM29:
 313 0056 8062      		ori r24,lo8(32)
 314 0058 00D0      		rcall spi_sendByte
 169:main.c        **** 	spi_sendByte(dt);										//
 316               	.LM30:
 317 005a 8C2F      		mov r24,r28
 318 005c 00D0      		rcall spi_sendByte
 170:main.c        **** 	CS_OFF();
 320               	.LM31:
 321 005e 979A      		sbi 0x12,7
 322               	/* epilogue start */
 171:main.c        **** }
 324               	.LM32:
 325 0060 CF91      		pop r28
 326 0062 0895      		ret
 328               	.Lscope6:
 330               	.global	NRF24_ToggleFeatures
 332               	NRF24_ToggleFeatures:
 172:main.c        **** 
 173:main.c        **** //------------------------------------------------
 174:main.c        **** void NRF24_ToggleFeatures(void)							//активация команд R_RX_PL_WID, W_ACK_PAYLOAD и W_TX_PAYLOAD_
 175:main.c        **** {	//есть в даташите "без плюса"
 334               	.LM33:
 335               	.LFBB7:
 336               	/* prologue: function */
 337               	/* frame size = 0 */
 338               	/* stack size = 0 */
 339               	.L__stack_usage = 0
 176:main.c        **** 	uint8_t dt[1] = {ACTIVATE};
 177:main.c        **** 	CS_ON();
 341               	.LM34:
 342 0064 9798      		cbi 0x12,7
 178:main.c        **** 	spi_sendByte(dt[0]);
 344               	.LM35:
 345 0066 80E5      		ldi r24,lo8(80)
 346 0068 00D0      		rcall spi_sendByte
 347               	.LBB36:
 348               	.LBB37:
 350               	.Ltext1:
   1:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    All rights reserved.
   5:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
   6:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
   9:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  12:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      distribution.
  16:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  17:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  21:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  33:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /* $Id$ */
  34:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  35:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  38:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #  endif
  42:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  44:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <inttypes.h>
  45:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <math.h>
  47:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  48:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \file */
  49:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \code
  51:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     #include <util/delay.h>
  54:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \endcode
  55:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  56:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     used.
  60:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  61:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  70:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     routines linked into the application.
  78:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  79:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  83:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** */
  84:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  85:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
  89:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  90:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef F_CPU
  91:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \ingroup util_delay
  94:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \def F_CPU
  95:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  97:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 103:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     integer value.
 107:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****  */
 108:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 110:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 111:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 114:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 115:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #  include <math.h>
 119:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 120:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 121:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /**
 122:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \ingroup util_delay
 123:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 124:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 126:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 129:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 131:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 137:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 142:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    microseconds of delay.
 146:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 147:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    respectively.
 151:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 152:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \note
 153:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 154:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    not available to the compiler then.
 163:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 164:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****  */
 165:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** void
 166:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** _delay_ms(double __ms)
 167:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** {
 168:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	double __tmp ;
 169:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 173:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 176:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 179:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 182:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#else
 183:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		//round up by default
 184:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#endif
 186:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 187:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 189:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #else
 190:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	uint16_t __ticks;
 191:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	if (__tmp < 1.0)
 193:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks = 1;
 194:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	else if (__tmp > 65535)
 195:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	{
 196:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		while(__ticks)
 199:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		{
 200:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 			// wait 1/10 ms
 201:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 			__ticks --;
 203:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		}
 204:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		return;
 205:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	}
 206:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	else
 207:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks = (uint16_t)__tmp;
 208:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	_delay_loop_2(__ticks);
 209:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 210:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** }
 211:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 212:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /**
 213:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \ingroup util_delay
 214:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 215:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 217:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 218:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 220:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 222:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    will not be informed about this case.
 225:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 226:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflow results in
 229:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    no delay i.e., 0us.
 230:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 231:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __us
 234:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    microseconds of delay.
 235:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 236:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    respectively.
 240:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 241:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \note
 242:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 243:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 244:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 246:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 248:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 249:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    not available to the compiler then.
 252:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 253:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****  */
 254:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** void
 255:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** _delay_us(double __us)
 256:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** {
 257:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	double __tmp ;
 258:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   __STDC_HOSTED__
 261:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 262:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 265:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 268:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 271:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#else
 272:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		//round up by default
 273:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#endif
 275:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 276:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 352               	.LM36:
 353 006a 82E0      		ldi r24,lo8(2)
 354 006c 8A95      	1:	dec r24
 355 006e 01F4      		brne 1b
 356 0070 00C0      		rjmp .
 357               	.LBE37:
 358               	.LBE36:
 360               	.Ltext2:
 179:main.c        **** 	_delay_us(1);
 180:main.c        **** 	dt[0] = 0x73;
 181:main.c        **** 	spi_sendByte(dt[0]);
 362               	.LM37:
 363 0072 83E7      		ldi r24,lo8(115)
 364 0074 00D0      		rcall spi_sendByte
 182:main.c        **** 	CS_OFF();
 366               	.LM38:
 367 0076 979A      		sbi 0x12,7
 368 0078 0895      		ret
 370               	.Lscope7:
 374               	.global	NRF24_Read_Buf
 376               	NRF24_Read_Buf:
 183:main.c        **** }
 184:main.c        **** 
 185:main.c        **** //-----------------------------------------------
 186:main.c        **** void NRF24_Read_Buf(uint8_t addr,uint8_t *pBuf,uint8_t bytes)
 187:main.c        **** {//чтение буфера (несколько байт)
 378               	.LM39:
 379               	.LFBB8:
 380 007a EF92      		push r14
 381 007c FF92      		push r15
 382 007e 0F93      		push r16
 383 0080 1F93      		push r17
 384 0082 CF93      		push r28
 385 0084 DF93      		push r29
 386               	/* prologue: function */
 387               	/* frame size = 0 */
 388               	/* stack size = 6 */
 389               	.L__stack_usage = 6
 390 0086 182F      		mov r17,r24
 391 0088 062F      		mov r16,r22
 392 008a E72E      		mov r14,r23
 393 008c F42E      		mov r15,r20
 188:main.c        **** 	CS_ON();
 395               	.LM40:
 396 008e 9798      		cbi 0x12,7
 189:main.c        **** 	spi_sendByte(addr);
 398               	.LM41:
 399 0090 00D0      		rcall spi_sendByte
 400 0092 C02F      		mov r28,r16
 401 0094 DE2D      		mov r29,r14
 402 0096 CE01      		movw r24,r28
 403 0098 8F0D      		add r24,r15
 404 009a 911D      		adc r25,__zero_reg__
 405 009c 7C01      		movw r14,r24
 406               	.L18:
 407               	.LBB38:
 190:main.c        **** 	for (uint8_t i = 0 ; i < bytes ; i++) 		//для нужного количества байт
 409               	.LM42:
 410 009e CE15      		cp r28,r14
 411 00a0 DF05      		cpc r29,r15
 412 00a2 01F0      		breq .L20
 191:main.c        **** 	{																					//
 192:main.c        **** 		pBuf[i] = spi_changeByte(addr);
 414               	.LM43:
 415 00a4 812F      		mov r24,r17
 416 00a6 00D0      		rcall spi_changeByte
 417 00a8 8993      		st Y+,r24
 418 00aa 00C0      		rjmp .L18
 419               	.L20:
 420               	.LBE38:
 193:main.c        **** 	}
 194:main.c        **** 	CS_OFF();
 422               	.LM44:
 423 00ac 979A      		sbi 0x12,7
 424               	/* epilogue start */
 195:main.c        **** }
 426               	.LM45:
 427 00ae DF91      		pop r29
 428 00b0 CF91      		pop r28
 429 00b2 1F91      		pop r17
 430 00b4 0F91      		pop r16
 431 00b6 FF90      		pop r15
 432 00b8 EF90      		pop r14
 433 00ba 0895      		ret
 435               	.Lscope8:
 439               	.global	NRF24_Write_Buf
 441               	NRF24_Write_Buf:
 196:main.c        **** 
 197:main.c        **** //------------------------------------------------
 198:main.c        **** void NRF24_Write_Buf(uint8_t addr,uint8_t *pBuf,uint8_t bytes)
 199:main.c        **** {//запись буфера
 443               	.LM46:
 444               	.LFBB9:
 445 00bc FF92      		push r15
 446 00be 0F93      		push r16
 447 00c0 1F93      		push r17
 448 00c2 CF93      		push r28
 449 00c4 DF93      		push r29
 450               	/* prologue: function */
 451               	/* frame size = 0 */
 452               	/* stack size = 5 */
 453               	.L__stack_usage = 5
 454 00c6 F62E      		mov r15,r22
 455 00c8 072F      		mov r16,r23
 456 00ca 142F      		mov r17,r20
 200:main.c        **** 	addr |= W_REGISTER;//включим бит записи в адрес
 201:main.c        **** 	CS_ON();
 458               	.LM47:
 459 00cc 9798      		cbi 0x12,7
 202:main.c        **** 	spi_sendByte(addr);
 461               	.LM48:
 462 00ce 8062      		ori r24,lo8(32)
 463 00d0 00D0      		rcall spi_sendByte
 464               	.LBB39:
 465               	.LBB40:
 467               	.Ltext3:
 469               	.LM49:
 470 00d2 82E0      		ldi r24,lo8(2)
 471 00d4 8A95      	1:	dec r24
 472 00d6 01F4      		brne 1b
 473 00d8 00C0      		rjmp .
 474 00da CF2D      		mov r28,r15
 475 00dc D02F      		mov r29,r16
 476 00de CE01      		movw r24,r28
 477 00e0 810F      		add r24,r17
 478 00e2 911D      		adc r25,__zero_reg__
 479 00e4 8C01      		movw r16,r24
 480               	.L22:
 481               	.LBE40:
 482               	.LBE39:
 483               	.LBB41:
 485               	.Ltext4:
 203:main.c        **** 	_delay_us(1);
 204:main.c        **** 	for (uint8_t i = 0 ; i < bytes ; i++) 		//для нужного количества байт
 487               	.LM50:
 488 00e6 C017      		cp r28,r16
 489 00e8 D107      		cpc r29,r17
 490 00ea 01F0      		breq .L24
 205:main.c        **** 	{
 206:main.c        **** 		spi_sendByte(pBuf[i]);
 492               	.LM51:
 493 00ec 8991      		ld r24,Y+
 494 00ee 00D0      		rcall spi_sendByte
 495 00f0 00C0      		rjmp .L22
 496               	.L24:
 497               	.LBE41:
 207:main.c        **** 	}
 208:main.c        **** 	CS_OFF();
 499               	.LM52:
 500 00f2 979A      		sbi 0x12,7
 501               	/* epilogue start */
 209:main.c        **** }
 503               	.LM53:
 504 00f4 DF91      		pop r29
 505 00f6 CF91      		pop r28
 506 00f8 1F91      		pop r17
 507 00fa 0F91      		pop r16
 508 00fc FF90      		pop r15
 509 00fe 0895      		ret
 511               	.Lscope9:
 513               	.global	NRF24_FlushRX
 515               	NRF24_FlushRX:
 210:main.c        **** 
 211:main.c        **** //------------------------------------------------
 212:main.c        **** void NRF24_FlushRX(void)
 213:main.c        **** {//очистка буфера приема
 517               	.LM54:
 518               	.LFBB10:
 519               	/* prologue: function */
 520               	/* frame size = 0 */
 521               	/* stack size = 0 */
 522               	.L__stack_usage = 0
 214:main.c        **** 	uint8_t dt[1] = {FLUSH_RX};
 215:main.c        **** 	CS_ON();
 524               	.LM55:
 525 0100 9798      		cbi 0x12,7
 216:main.c        **** 	spi_sendByte(dt[0]);
 527               	.LM56:
 528 0102 82EE      		ldi r24,lo8(-30)
 529 0104 00D0      		rcall spi_sendByte
 530               	.LBB42:
 531               	.LBB43:
 533               	.Ltext5:
 535               	.LM57:
 536 0106 82E0      		ldi r24,lo8(2)
 537 0108 8A95      	1:	dec r24
 538 010a 01F4      		brne 1b
 539 010c 00C0      		rjmp .
 540               	.LBE43:
 541               	.LBE42:
 543               	.Ltext6:
 217:main.c        **** 	_delay_us(1); //пауза в микросекунду для завершения процесса
 218:main.c        **** 	CS_OFF();
 545               	.LM58:
 546 010e 979A      		sbi 0x12,7
 547 0110 0895      		ret
 549               	.Lscope10:
 551               	.global	NRF24_FlushTX
 553               	NRF24_FlushTX:
 219:main.c        **** }
 220:main.c        **** 
 221:main.c        **** //------------------------------------------------
 222:main.c        **** void NRF24_FlushTX(void)
 223:main.c        **** {//очистка буфера передачи
 555               	.LM59:
 556               	.LFBB11:
 557               	/* prologue: function */
 558               	/* frame size = 0 */
 559               	/* stack size = 0 */
 560               	.L__stack_usage = 0
 224:main.c        **** 	uint8_t dt[1] = {FLUSH_TX};
 225:main.c        **** 	CS_ON();
 562               	.LM60:
 563 0112 9798      		cbi 0x12,7
 226:main.c        **** 	spi_sendByte(dt[0]);
 565               	.LM61:
 566 0114 81EE      		ldi r24,lo8(-31)
 567 0116 00D0      		rcall spi_sendByte
 568               	.LBB44:
 569               	.LBB45:
 571               	.Ltext7:
 573               	.LM62:
 574 0118 82E0      		ldi r24,lo8(2)
 575 011a 8A95      	1:	dec r24
 576 011c 01F4      		brne 1b
 577 011e 00C0      		rjmp .
 578               	.LBE45:
 579               	.LBE44:
 581               	.Ltext8:
 227:main.c        **** 	_delay_us(1); //пауза в микросекунду для завершения процесса
 228:main.c        **** 	CS_OFF();
 583               	.LM63:
 584 0120 979A      		sbi 0x12,7
 585 0122 0895      		ret
 587               	.Lscope11:
 589               	.global	NRF24L01_RX_Mode
 591               	NRF24L01_RX_Mode:
 229:main.c        **** }
 230:main.c        **** 
 231:main.c        **** //------------------------------------------------
 232:main.c        **** void NRF24L01_RX_Mode(void)
 233:main.c        **** {//режим приемника
 593               	.LM64:
 594               	.LFBB12:
 595               	/* prologue: function */
 596               	/* frame size = 0 */
 597               	/* stack size = 0 */
 598               	.L__stack_usage = 0
 234:main.c        **** 	uint8_t regval=0x00;
 235:main.c        **** 	regval = NRF24_ReadReg(CONFIG);	//сохраняем значение регистра конфигурации
 600               	.LM65:
 601 0124 80E0      		ldi r24,0
 602 0126 00D0      		rcall NRF24_ReadReg
 236:main.c        **** 	//разбудим модуль и переведём его в режим приёмника, включив биты PWR_UP и PRIM_RX
 237:main.c        **** 	regval |= (1<<PWR_UP)|(1<<PRIM_RX);
 238:main.c        **** 	NRF24_WriteReg(CONFIG,regval);	//возвращаем значение регистра статуса
 604               	.LM66:
 605 0128 682F      		mov r22,r24
 606 012a 6360      		ori r22,lo8(3)
 607 012c 80E0      		ldi r24,0
 608 012e 00D0      		rcall NRF24_WriteReg
 239:main.c        **** 	
 240:main.c        **** 	NRF24_Write_Buf(TX_ADDR, TX_ADDRESS1, TX_ADR_WIDTH);		//записываем  адрес передатчика
 610               	.LM67:
 611 0130 43E0      		ldi r20,lo8(3)
 612 0132 60E0      		ldi r22,lo8(TX_ADDRESS1)
 613 0134 70E0      		ldi r23,hi8(TX_ADDRESS1)
 614 0136 80E1      		ldi r24,lo8(16)
 615 0138 00D0      		rcall NRF24_Write_Buf
 241:main.c        **** 	NRF24_Write_Buf(RX_ADDR_P0, TX_ADDRESS1, TX_ADR_WIDTH);	//записываем адрес приемника
 617               	.LM68:
 618 013a 43E0      		ldi r20,lo8(3)
 619 013c 60E0      		ldi r22,lo8(TX_ADDRESS1)
 620 013e 70E0      		ldi r23,hi8(TX_ADDRESS1)
 621 0140 8AE0      		ldi r24,lo8(10)
 622 0142 00D0      		rcall NRF24_Write_Buf
 242:main.c        **** 	
 243:main.c        **** 	CE_SET();
 624               	.LM69:
 625 0144 C09A      		sbi 0x18,0
 626               	.LBB46:
 627               	.LBB47:
 629               	.Ltext9:
 631               	.LM70:
 632 0146 8BE2      		ldi r24,lo8(299)
 633 0148 91E0      		ldi r25,hi8(299)
 634 014a 0197      	1:	sbiw r24,1
 635 014c 01F4      		brne 1b
 636 014e 00C0      		rjmp .
 637 0150 0000      		nop
 638               	.LBE47:
 639               	.LBE46:
 641               	.Ltext10:
 244:main.c        **** 	_delay_us(150); //Задержка минимум 130 мкс
 245:main.c        **** 	// Flush buffers
 246:main.c        **** 	NRF24_FlushRX();
 643               	.LM71:
 644 0152 00D0      		rcall NRF24_FlushRX
 247:main.c        **** 	NRF24_FlushTX();
 646               	.LM72:
 647 0154 00C0      		rjmp NRF24_FlushTX
 649               	.Lscope12:
 652               	.global	NRF24L01_TX_Mode
 654               	NRF24L01_TX_Mode:
 248:main.c        **** }
 249:main.c        **** 
 250:main.c        **** //------------------------------------------------
 251:main.c        **** void NRF24L01_TX_Mode(uint8_t *pBuf)
 252:main.c        **** {//режим передатчика
 656               	.LM73:
 657               	.LFBB13:
 658               	/* prologue: function */
 659               	/* frame size = 0 */
 660               	/* stack size = 0 */
 661               	.L__stack_usage = 0
 253:main.c        **** 	NRF24_Write_Buf(TX_ADDR, TX_ADDRESS0, TX_ADR_WIDTH);		//записываем адрес передатчика
 663               	.LM74:
 664 0156 43E0      		ldi r20,lo8(3)
 665 0158 60E0      		ldi r22,lo8(TX_ADDRESS0)
 666 015a 70E0      		ldi r23,hi8(TX_ADDRESS0)
 667 015c 80E1      		ldi r24,lo8(16)
 668 015e 00D0      		rcall NRF24_Write_Buf
 254:main.c        **** 	NRF24_Write_Buf(RX_ADDR_P0, TX_ADDRESS0, TX_ADR_WIDTH);	//записываем адрес приемника
 670               	.LM75:
 671 0160 43E0      		ldi r20,lo8(3)
 672 0162 60E0      		ldi r22,lo8(TX_ADDRESS0)
 673 0164 70E0      		ldi r23,hi8(TX_ADDRESS0)
 674 0166 8AE0      		ldi r24,lo8(10)
 675 0168 00D0      		rcall NRF24_Write_Buf
 255:main.c        **** 	CE_RESET();
 677               	.LM76:
 678 016a C098      		cbi 0x18,0
 256:main.c        **** 	// Flush buffers
 257:main.c        **** 	NRF24_FlushRX();
 680               	.LM77:
 681 016c 00D0      		rcall NRF24_FlushRX
 258:main.c        **** 	NRF24_FlushTX();
 683               	.LM78:
 684 016e 00C0      		rjmp NRF24_FlushTX
 686               	.Lscope13:
 690               	.global	NRF24_Transmit
 692               	NRF24_Transmit:
 259:main.c        **** }
 260:main.c        **** 
 261:main.c        **** //------------------------------------------------
 262:main.c        **** void NRF24_Transmit(uint8_t addr,uint8_t *pBuf,uint8_t bytes)
 263:main.c        **** {//передача данных в модуль
 694               	.LM79:
 695               	.LFBB14:
 696 0170 FF92      		push r15
 697 0172 0F93      		push r16
 698 0174 1F93      		push r17
 699 0176 CF93      		push r28
 700 0178 DF93      		push r29
 701               	/* prologue: function */
 702               	/* frame size = 0 */
 703               	/* stack size = 5 */
 704               	.L__stack_usage = 5
 705 017a F62E      		mov r15,r22
 706 017c 072F      		mov r16,r23
 707 017e 142F      		mov r17,r20
 264:main.c        **** 	CE_RESET();
 709               	.LM80:
 710 0180 C098      		cbi 0x18,0
 265:main.c        **** 	CS_ON();
 712               	.LM81:
 713 0182 9798      		cbi 0x12,7
 266:main.c        **** 	spi_sendByte(addr);
 715               	.LM82:
 716 0184 00D0      		rcall spi_sendByte
 717               	.LBB48:
 718               	.LBB49:
 720               	.Ltext11:
 722               	.LM83:
 723 0186 82E0      		ldi r24,lo8(2)
 724 0188 8A95      	1:	dec r24
 725 018a 01F4      		brne 1b
 726 018c 00C0      		rjmp .
 727 018e CF2D      		mov r28,r15
 728 0190 D02F      		mov r29,r16
 729 0192 CE01      		movw r24,r28
 730 0194 810F      		add r24,r17
 731 0196 911D      		adc r25,__zero_reg__
 732 0198 8C01      		movw r16,r24
 733               	.L30:
 734               	.LBE49:
 735               	.LBE48:
 736               	.LBB50:
 738               	.Ltext12:
 267:main.c        **** 	_delay_us(1); //пауза в микросекунду для завершения процесса
 268:main.c        **** 	for (uint8_t i = 0 ; i < bytes ; i++)
 740               	.LM84:
 741 019a C017      		cp r28,r16
 742 019c D107      		cpc r29,r17
 743 019e 01F0      		breq .L32
 269:main.c        **** 	{
 270:main.c        **** 		spi_sendByte(pBuf[i]);
 745               	.LM85:
 746 01a0 8991      		ld r24,Y+
 747 01a2 00D0      		rcall spi_sendByte
 748 01a4 00C0      		rjmp .L30
 749               	.L32:
 750               	.LBE50:
 271:main.c        **** 	}
 272:main.c        **** 	CS_OFF();
 752               	.LM86:
 753 01a6 979A      		sbi 0x12,7
 273:main.c        **** 	CE_SET();
 755               	.LM87:
 756 01a8 C09A      		sbi 0x18,0
 757               	/* epilogue start */
 274:main.c        **** }
 759               	.LM88:
 760 01aa DF91      		pop r29
 761 01ac CF91      		pop r28
 762 01ae 1F91      		pop r17
 763 01b0 0F91      		pop r16
 764 01b2 FF90      		pop r15
 765 01b4 0895      		ret
 767               	.Lscope14:
 770               	.global	NRF24L01_Send
 772               	NRF24L01_Send:
 275:main.c        **** 
 276:main.c        **** //------------------------------------------------
 277:main.c        **** uint8_t NRF24L01_Send(uint8_t *pBuf)
 278:main.c        **** {//отправка данных в эфир
 774               	.LM89:
 775               	.LFBB15:
 776 01b6 CF93      		push r28
 777 01b8 DF93      		push r29
 778               	/* prologue: function */
 779               	/* frame size = 0 */
 780               	/* stack size = 2 */
 781               	.L__stack_usage = 2
 782 01ba EC01      		movw r28,r24
 279:main.c        **** 	uint8_t regval=0x00;						//переменная для отправки в конфигурационный регистр
 280:main.c        **** 	NRF24L01_TX_Mode(pBuf);					//включаем режим передачи
 784               	.LM90:
 785 01bc 00D0      		rcall NRF24L01_TX_Mode
 281:main.c        **** 	regval = NRF24_ReadReg(CONFIG);	//сохраняем значения конфигурационного региста
 787               	.LM91:
 788 01be 80E0      		ldi r24,0
 789 01c0 00D0      		rcall NRF24_ReadReg
 790 01c2 8E7F      		andi r24,lo8(-2)
 282:main.c        **** 	//если модуль ушел в спящий режим, то разбудим его, включив бит PWR_UP и выключив PRIM_RX
 283:main.c        **** 	regval |= (1<<PWR_UP);
 284:main.c        **** 	regval &= ~(1<<PRIM_RX);
 285:main.c        **** 	NRF24_WriteReg(CONFIG,regval);//записываем новое значение конфигурационного регистра
 792               	.LM92:
 793 01c4 682F      		mov r22,r24
 794 01c6 6260      		ori r22,lo8(2)
 795 01c8 80E0      		ldi r24,0
 796 01ca 00D0      		rcall NRF24_WriteReg
 797               	.LBB51:
 798               	.LBB52:
 800               	.Ltext13:
 802               	.LM93:
 803 01cc 8BE2      		ldi r24,lo8(299)
 804 01ce 91E0      		ldi r25,hi8(299)
 805 01d0 0197      	1:	sbiw r24,1
 806 01d2 01F4      		brne 1b
 807 01d4 00C0      		rjmp .
 808 01d6 0000      		nop
 809               	.LBE52:
 810               	.LBE51:
 812               	.Ltext14:
 286:main.c        **** 	_delay_us(150); //Задержка минимум 130 мкс
 287:main.c        **** 	//Отправим данные в воздух
 288:main.c        **** 	NRF24_Transmit(WR_TX_PLOAD, pBuf, TX_PLOAD_WIDTH);//отправка данных
 814               	.LM94:
 815 01d8 40E2      		ldi r20,lo8(32)
 816 01da BE01      		movw r22,r28
 817 01dc 80EA      		ldi r24,lo8(-96)
 818 01de 00D0      		rcall NRF24_Transmit
 289:main.c        **** 	CE_SET();
 820               	.LM95:
 821 01e0 C09A      		sbi 0x18,0
 822               	.LBB53:
 823               	.LBB54:
 825               	.Ltext15:
 827               	.LM96:
 828 01e2 98E2      		ldi r25,lo8(40)
 829 01e4 9A95      	1:	dec r25
 830 01e6 01F4      		brne 1b
 831               	.LBE54:
 832               	.LBE53:
 834               	.Ltext16:
 290:main.c        **** 	_delay_us(15); //minimum 10us high pulse (Page 21)
 291:main.c        **** 	CE_RESET();
 836               	.LM97:
 837 01e8 C098      		cbi 0x18,0
 838               	.LBB55:
 839               	.LBB56:
 841               	.Ltext17:
 843               	.LM98:
 844 01ea 87EE      		ldi r24,lo8(999)
 845 01ec 93E0      		ldi r25,hi8(999)
 846 01ee 0197      	1:	sbiw r24,1
 847 01f0 01F4      		brne 1b
 848 01f2 00C0      		rjmp .
 849 01f4 0000      		nop
 850               	.LBE56:
 851               	.LBE55:
 853               	.Ltext18:
 292:main.c        **** 	_delay_us(500);
 293:main.c        **** 	NRF24L01_RX_Mode();				//переход в режим приема
 855               	.LM99:
 856 01f6 00D0      		rcall NRF24L01_RX_Mode
 294:main.c        **** 	return 0;
 295:main.c        **** }
 858               	.LM100:
 859 01f8 80E0      		ldi r24,0
 860               	/* epilogue start */
 861 01fa DF91      		pop r29
 862 01fc CF91      		pop r28
 863 01fe 0895      		ret
 865               	.Lscope15:
 867               	.global	nrf24_init
 869               	nrf24_init:
 296:main.c        **** 
 297:main.c        **** //------------------------------------------------
 298:main.c        **** void nrf24_init(void)
 299:main.c        **** {//инициализация
 871               	.LM101:
 872               	.LFBB16:
 873               	/* prologue: function */
 874               	/* frame size = 0 */
 875               	/* stack size = 0 */
 876               	.L__stack_usage = 0
 300:main.c        **** 	CE_RESET();							//опускаем к земле вывод ce
 878               	.LM102:
 879 0200 C098      		cbi 0x18,0
 880               	.LBB57:
 881               	.LBB58:
 883               	.Ltext19:
 885               	.LM103:
 886 0202 8FE0      		ldi r24,lo8(9999)
 887 0204 97E2      		ldi r25,hi8(9999)
 888 0206 0197      	1:	sbiw r24,1
 889 0208 01F4      		brne 1b
 890 020a 00C0      		rjmp .
 891 020c 0000      		nop
 892               	.LBE58:
 893               	.LBE57:
 895               	.Ltext20:
 301:main.c        **** 	_delay_us(5000);					//задержка 5 мс
 302:main.c        **** 	//записываем конфигурационный байт,
 303:main.c        **** 	NRF24_WriteReg(CONFIG, 0x0a);		// Set PWR_UP bit, enable CRC(1 byte) &Prim_RX:0 (Transmitter)
 897               	.LM104:
 898 020e 6AE0      		ldi r22,lo8(10)
 899 0210 80E0      		ldi r24,0
 900 0212 00D0      		rcall NRF24_WriteReg
 901               	.LBB59:
 902               	.LBB60:
 904               	.Ltext21:
 906               	.LM105:
 907 0214 8FE0      		ldi r24,lo8(9999)
 908 0216 97E2      		ldi r25,hi8(9999)
 909 0218 0197      	1:	sbiw r24,1
 910 021a 01F4      		brne 1b
 911 021c 00C0      		rjmp .
 912 021e 0000      		nop
 913               	.LBE60:
 914               	.LBE59:
 916               	.Ltext22:
 304:main.c        **** 	_delay_us(5000);
 305:main.c        **** 	NRF24_WriteReg(EN_AA, 0x00);		// Enable Pipe0
 918               	.LM106:
 919 0220 60E0      		ldi r22,0
 920 0222 81E0      		ldi r24,lo8(1)
 921 0224 00D0      		rcall NRF24_WriteReg
 306:main.c        **** 	NRF24_WriteReg(EN_RXADDR, 0x01);	// Enable Pipe0
 923               	.LM107:
 924 0226 61E0      		ldi r22,lo8(1)
 925 0228 82E0      		ldi r24,lo8(2)
 926 022a 00D0      		rcall NRF24_WriteReg
 307:main.c        **** 	NRF24_WriteReg(SETUP_AW, 0x01);		// Setup address width=3 bytes
 928               	.LM108:
 929 022c 61E0      		ldi r22,lo8(1)
 930 022e 83E0      		ldi r24,lo8(3)
 931 0230 00D0      		rcall NRF24_WriteReg
 308:main.c        **** 	NRF24_WriteReg(SETUP_RETR, 0x00);	// 1500us, 15 retrans
 933               	.LM109:
 934 0232 60E0      		ldi r22,0
 935 0234 84E0      		ldi r24,lo8(4)
 936 0236 00D0      		rcall NRF24_WriteReg
 309:main.c        **** 	NRF24_ToggleFeatures();				//активация команд
 938               	.LM110:
 939 0238 00D0      		rcall NRF24_ToggleFeatures
 310:main.c        **** 	NRF24_WriteReg(FEATURE, 0x07);			//установка стандартных значений регистра FEATURE
 941               	.LM111:
 942 023a 67E0      		ldi r22,lo8(7)
 943 023c 8DE1      		ldi r24,lo8(29)
 944 023e 00D0      		rcall NRF24_WriteReg
 311:main.c        **** 	NRF24_WriteReg(DYNPD, 0);			//отключение динамического размера полезной нагрузки
 946               	.LM112:
 947 0240 60E0      		ldi r22,0
 948 0242 8CE1      		ldi r24,lo8(28)
 949 0244 00D0      		rcall NRF24_WriteReg
 312:main.c        **** 	NRF24_WriteReg(STATUS, 0x70);		//Reset flags for IRQ
 951               	.LM113:
 952 0246 60E7      		ldi r22,lo8(112)
 953 0248 87E0      		ldi r24,lo8(7)
 954 024a 00D0      		rcall NRF24_WriteReg
 313:main.c        **** 	NRF24_WriteReg(RF_CH, 76);			// частота 2476 MHz
 956               	.LM114:
 957 024c 6CE4      		ldi r22,lo8(76)
 958 024e 85E0      		ldi r24,lo8(5)
 959 0250 00D0      		rcall NRF24_WriteReg
 314:main.c        **** 	NRF24_WriteReg(RF_SETUP, 0x06);		//TX_PWR:0dBm, Datarate:1Mbps
 961               	.LM115:
 962 0252 66E0      		ldi r22,lo8(6)
 963 0254 86E0      		ldi r24,lo8(6)
 964 0256 00D0      		rcall NRF24_WriteReg
 315:main.c        **** 	NRF24_Write_Buf(TX_ADDR, TX_ADDRESS0, TX_ADR_WIDTH);//запись адреса передачи
 966               	.LM116:
 967 0258 43E0      		ldi r20,lo8(3)
 968 025a 60E0      		ldi r22,lo8(TX_ADDRESS0)
 969 025c 70E0      		ldi r23,hi8(TX_ADDRESS0)
 970 025e 80E1      		ldi r24,lo8(16)
 971 0260 00D0      		rcall NRF24_Write_Buf
 316:main.c        **** 	NRF24_Write_Buf(RX_ADDR_P1, TX_ADDRESS0, TX_ADR_WIDTH);//запись адреса приема
 973               	.LM117:
 974 0262 43E0      		ldi r20,lo8(3)
 975 0264 60E0      		ldi r22,lo8(TX_ADDRESS0)
 976 0266 70E0      		ldi r23,hi8(TX_ADDRESS0)
 977 0268 8BE0      		ldi r24,lo8(11)
 978 026a 00D0      		rcall NRF24_Write_Buf
 317:main.c        **** 	NRF24_WriteReg(RX_PW_P0, TX_PLOAD_WIDTH); //Number of bytes in RX payload in data pipe 1
 980               	.LM118:
 981 026c 60E2      		ldi r22,lo8(32)
 982 026e 81E1      		ldi r24,lo8(17)
 983 0270 00D0      		rcall NRF24_WriteReg
 318:main.c        **** 	//пока уходим в режим приёмника
 319:main.c        **** 	NRF24L01_RX_Mode();					//режим приема
 985               	.LM119:
 986 0272 00D0      		rcall NRF24L01_RX_Mode
 320:main.c        **** 	LED_OFF();
 988               	.LM120:
 989 0274 9698      		cbi 0x12,6
 990 0276 0895      		ret
 992               	.Lscope16:
 994               	.global	nrf24_receive
 996               	nrf24_receive:
 321:main.c        **** }
 322:main.c        **** 
 323:main.c        **** //--------------------------------------------------
 324:main.c        **** void nrf24_receive(void)
 325:main.c        **** {
 998               	.LM121:
 999               	.LFBB17:
 1000               	/* prologue: function */
 1001               	/* frame size = 0 */
 1002               	/* stack size = 0 */
 1003               	.L__stack_usage = 0
 326:main.c        **** 	uint8_t status = 0x01;	//переменная статус
 327:main.c        **** 	status = NRF24_ReadReg(STATUS);	//чтение значения регистра статуса
 1005               	.LM122:
 1006 0278 87E0      		ldi r24,lo8(7)
 1007 027a 00D0      		rcall NRF24_ReadReg
 328:main.c        **** 	if(status & RX_DR)				//если есть данные на прием
 1009               	.LM123:
 1010 027c 86FF      		sbrs r24,6
 1011 027e 00C0      		rjmp .L35
 1012               	.LBB63:
 1013               	.LBB64:
 329:main.c        **** 	{
 330:main.c        **** 		NRF24_Read_Buf(RD_RX_PLOAD,rx_buf,TX_PLOAD_WIDTH);//чтение буфера
 1015               	.LM124:
 1016 0280 40E2      		ldi r20,lo8(32)
 1017 0282 60E0      		ldi r22,lo8(rx_buf)
 1018 0284 70E0      		ldi r23,hi8(rx_buf)
 1019 0286 81E6      		ldi r24,lo8(97)
 1020 0288 00D0      		rcall NRF24_Read_Buf
 331:main.c        **** 		NRF24_WriteReg(STATUS, 0x40);	//запись в регистр статуса 1 в шестой бит, обнуление остальных
 1022               	.LM125:
 1023 028a 60E4      		ldi r22,lo8(64)
 1024 028c 87E0      		ldi r24,lo8(7)
 1025 028e 00D0      		rcall NRF24_WriteReg
 332:main.c        **** 		f_rx = 1;						//поднимаем флаг приема
 1027               	.LM126:
 1028 0290 81E0      		ldi r24,lo8(1)
 1029 0292 8093 0000 		sts f_rx,r24
 1030               	.L35:
 1031 0296 0895      		ret
 1032               	.LBE64:
 1033               	.LBE63:
 1035               	.Lscope17:
 1036               		.section	.text.startup,"ax",@progbits
 1038               	.global	main
 1040               	main:
 333:main.c        **** 	}
 334:main.c        **** }
 335:main.c        **** 
 336:main.c        **** static inline void eraseFlash(void)
 337:main.c        **** {
 338:main.c        **** 	// erase only main section (bootloader protection)
 339:main.c        **** 	uint32_t addr = 0;
 340:main.c        **** 	while (APP_END > addr) 
 341:main.c        **** 	{
 342:main.c        **** 		boot_page_erase(addr);		// Perform page erase
 343:main.c        **** 		boot_spm_busy_wait();		// Wait until the memory is erased.
 344:main.c        **** 		addr += SPM_PAGESIZE;
 345:main.c        **** 	}
 346:main.c        **** 	boot_rww_enable();
 347:main.c        **** }
 348:main.c        **** 
 349:main.c        **** static inline uint16_t VerifyFlashPage(uint16_t waddr, pagebuf_t size)
 350:main.c        **** {
 351:main.c        **** 	uint32_t baddr = (uint32_t)waddr<<1;
 352:main.c        **** 	uint16_t data;
 353:main.c        **** 
 354:main.c        **** 	do
 355:main.c        **** 	{
 356:main.c        **** 		// don't read bootloader
 357:main.c        **** 		if ( baddr < APP_END )
 358:main.c        **** 		{
 359:main.c        **** 			data = pgm_read_word_near(baddr);
 360:main.c        **** 			//if (data != (gBuffer[1]<<8 | gBuffer[0])) LED_OFF();
 361:main.c        **** 			if (data ==  0xFFFF) LED_OFF();
 362:main.c        **** 		}
 363:main.c        **** 		else
 364:main.c        **** 		{
 365:main.c        **** 			data = 0xFFFF; // fake empty
 366:main.c        **** 		}
 367:main.c        **** 		baddr += 2;			// Select next word in memory
 368:main.c        **** 		size -= 2;			// Subtract two bytes from number of bytes to read
 369:main.c        **** 	}
 370:main.c        **** 	while (size);				// Repeat until block has been read
 371:main.c        **** 	return baddr>>1;
 372:main.c        **** }
 373:main.c        **** 
 374:main.c        **** static inline uint16_t writeFlashPage(uint16_t waddr, pagebuf_t size)
 375:main.c        **** {
 376:main.c        **** 	uint32_t pagestart = (uint32_t)waddr<<1;
 377:main.c        **** 	uint32_t baddr = pagestart;
 378:main.c        **** 	uint16_t data;
 379:main.c        **** 	uint8_t *tmp = gBuffer;
 380:main.c        **** 
 381:main.c        **** 	do 
 382:main.c        **** 	{
 383:main.c        **** 		data = *tmp++;
 384:main.c        **** 		data |= *tmp++ << 8;
 385:main.c        **** 		boot_page_fill(baddr, data);	// call asm routine.
 386:main.c        **** 
 387:main.c        **** 		baddr += 2;			// Select next word in memory
 388:main.c        **** 		size -= 2;			// Reduce number of bytes to write by two
 389:main.c        **** 	} 
 390:main.c        **** 	while (size);				// Loop until all bytes written
 391:main.c        **** 
 392:main.c        **** 	boot_page_write(pagestart);
 393:main.c        **** 	boot_spm_busy_wait();
 394:main.c        **** 	boot_rww_enable();		// Re-enable the RWW section
 395:main.c        **** 
 396:main.c        **** 	return baddr>>1;
 397:main.c        **** }
 398:main.c        **** 
 399:main.c        **** static inline uint16_t writeEEpromPage(uint16_t address, pagebuf_t size)
 400:main.c        **** {
 401:main.c        **** 	uint8_t *tmp = gBuffer;
 402:main.c        **** 
 403:main.c        **** 	do 
 404:main.c        **** 		{
 405:main.c        **** 		eeprom_write_byte( (uint8_t*)address, *tmp++ );
 406:main.c        **** 		address++;			// Select next byte
 407:main.c        **** 		size--;				// Decreas number of bytes to write
 408:main.c        **** 		}
 409:main.c        **** 	while (size);				// Loop until all bytes written
 410:main.c        **** 
 411:main.c        **** 	//eeprom_busy_wait();
 412:main.c        **** 
 413:main.c        **** 	return address;
 414:main.c        **** }
 415:main.c        **** 
 416:main.c        **** static void (*jump_to_app)(void) = 0x0000;
 417:main.c        **** 
 418:main.c        **** int main(void)
 419:main.c        **** {
 1042               	.LM127:
 1043               	.LFBB18:
 1044               	/* prologue: function */
 1045               	/* frame size = 0 */
 1046               	/* stack size = 0 */
 1047               	.L__stack_usage = 0
 420:main.c        **** 	port_init();							//инициализация портов
 1049               	.LM128:
 1050 0000 00D0      		rcall port_init
 421:main.c        **** 	spi_init();								//инициализация SPI
 1052               	.LM129:
 1053 0002 00D0      		rcall spi_init
 422:main.c        **** 	nrf24_init();
 1055               	.LM130:
 1056 0004 00D0      		rcall nrf24_init
 423:main.c        **** 
 424:main.c        **** 	uint8_t blink_counter = 2;
 425:main.c        **** 	uint16_t load_pause = 0;
 426:main.c        **** 
 427:main.c        **** 	while (blink_counter)
 428:main.c        **** 	{
 429:main.c        **** 		LED_ON();
 1058               	.LM131:
 1059 0006 969A      		sbi 0x12,6
 1060               	.LBB79:
 1061               	.LBB80:
 1063               	.Ltext23:
 187:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 1065               	.LM132:
 1066 0008 2FE7      		ldi r18,lo8(79999)
 1067 000a 88E3      		ldi r24,hi8(79999)
 1068 000c 91E0      		ldi r25,hlo8(79999)
 1069 000e 2150      	1:	subi r18,1
 1070 0010 8040      		sbci r24,0
 1071 0012 9040      		sbci r25,0
 1072 0014 01F4      		brne 1b
 1073 0016 00C0      		rjmp .
 1074 0018 0000      		nop
 1075               	.LBE80:
 1076               	.LBE79:
 1078               	.Ltext24:
 430:main.c        **** 		_delay_ms(50);
 431:main.c        **** 		LED_OFF();
 1080               	.LM133:
 1081 001a 9698      		cbi 0x12,6
 1082               	.LBB82:
 1083               	.LBB83:
 1085               	.Ltext25:
 187:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 1087               	.LM134:
 1088 001c EFE7      		ldi r30,lo8(79999)
 1089 001e F8E3      		ldi r31,hi8(79999)
 1090 0020 21E0      		ldi r18,hlo8(79999)
 1091 0022 E150      	1:	subi r30,1
 1092 0024 F040      		sbci r31,0
 1093 0026 2040      		sbci r18,0
 1094 0028 01F4      		brne 1b
 1095 002a 00C0      		rjmp .
 1096 002c 0000      		nop
 1097               	.LBE83:
 1098               	.LBE82:
 1100               	.Ltext26:
 429:main.c        **** 		_delay_ms(50);
 1102               	.LM135:
 1103 002e 969A      		sbi 0x12,6
 1104               	.LBB85:
 1105               	.LBB81:
 1107               	.Ltext27:
 187:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 1109               	.LM136:
 1110 0030 8FE7      		ldi r24,lo8(79999)
 1111 0032 98E3      		ldi r25,hi8(79999)
 1112 0034 E1E0      		ldi r30,hlo8(79999)
 1113 0036 8150      	1:	subi r24,1
 1114 0038 9040      		sbci r25,0
 1115 003a E040      		sbci r30,0
 1116 003c 01F4      		brne 1b
 1117 003e 00C0      		rjmp .
 1118 0040 0000      		nop
 1119               	.LBE81:
 1120               	.LBE85:
 1122               	.Ltext28:
 1124               	.LM137:
 1125 0042 9698      		cbi 0x12,6
 1126               	.LBB86:
 1127               	.LBB84:
 1129               	.Ltext29:
 187:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 1131               	.LM138:
 1132 0044 FFE7      		ldi r31,lo8(79999)
 1133 0046 28E3      		ldi r18,hi8(79999)
 1134 0048 81E0      		ldi r24,hlo8(79999)
 1135 004a F150      	1:	subi r31,1
 1136 004c 2040      		sbci r18,0
 1137 004e 8040      		sbci r24,0
 1138 0050 01F4      		brne 1b
 1139 0052 00C0      		rjmp .
 1140 0054 0000      		nop
 1141 0056 E12C      		mov r14,__zero_reg__
 1142 0058 F12C      		mov r15,__zero_reg__
 1143 005a C0E0      		ldi r28,0
 1144 005c D0E0      		ldi r29,0
 1145               	.LBE84:
 1146               	.LBE86:
 1147               	.LBB87:
 1148               	.LBB88:
 1149               	.LBB89:
 1151               	.Ltext30:
 385:main.c        **** 
 1153               	.LM139:
 1154 005e 5524      		clr r5
 1155 0060 5394      		inc r5
 1156 0062 6624      		clr r6
 1157 0064 6394      		inc r6
 392:main.c        **** 	boot_spm_busy_wait();
 1159               	.LM140:
 1160 0066 35E0      		ldi r19,lo8(5)
 1161 0068 A32E      		mov r10,r19
 394:main.c        **** 
 1163               	.LM141:
 1164 006a 41E1      		ldi r20,lo8(17)
 1165 006c B42E      		mov r11,r20
 1166               	.LBE89:
 1167               	.LBE88:
 432:main.c        **** 		_delay_ms(50);
 433:main.c        **** 		blink_counter--;
 434:main.c        **** 	}
 435:main.c        **** 
 436:main.c        **** 	uint16_t cnt = 0;
 437:main.c        **** 
 438:main.c        **** 	//wdt_enable(WDTO_1S);
 439:main.c        **** 
 440:main.c        **** 	while (1) 
 441:main.c        **** 	{
 442:main.c        **** 		nrf24_receive();
 443:main.c        **** 
 444:main.c        **** 		if(f_rx == 1)						//если флаг приема поднят
 445:main.c        **** 		{
 446:main.c        **** 			if (rx_buf[0] == BUT_ADDR)		//если первый принятый байт совпадает с адресом кнопки
 447:main.c        **** 			{
 448:main.c        **** 				if (rx_buf[1] == 'J')
 449:main.c        **** 				{
 450:main.c        **** 					jump_to_app();
 451:main.c        **** 				}
 452:main.c        **** 
 453:main.c        **** 				if (rx_buf[1] == 'E')	
 454:main.c        **** 				{
 455:main.c        **** 					eraseFlash();
 456:main.c        **** 				}
 457:main.c        **** 
 458:main.c        **** 				if (rx_buf[1] == 'W')	
 459:main.c        **** 				{
 460:main.c        **** 					LED_ON();
 461:main.c        **** 					tx_buf[0] = BUT_ADDR;
 462:main.c        **** 					tx_buf[1] = 'W';
 463:main.c        **** 					NRF24L01_Send(tx_buf);
 464:main.c        **** 					f_wait = 1;
 465:main.c        **** 				}
 466:main.c        **** 
 467:main.c        **** 				if (rx_buf[1] == 'F')		//
 468:main.c        **** 				{
 469:main.c        **** 					//LED_TGL();
 470:main.c        **** 					pagebuf_t size;
 471:main.c        **** 					size = rx_buf[2];
 472:main.c        **** 					address = (uint16_t)(rx_buf[4] << 8 | rx_buf[3]); //
 473:main.c        **** 
 474:main.c        **** 					for (uint8_t i = 0; i < size; i++)
 475:main.c        **** 					{
 476:main.c        **** 						gBuffer[i] = rx_buf[i+5];
 477:main.c        **** 					}
 478:main.c        **** 					//_delay_ms(100);
 479:main.c        **** 					writeFlashPage(address, size);
 480:main.c        **** 					//_delay_ms(100);
 481:main.c        **** 					//VerifyFlashPage(address, size);
 482:main.c        **** 
 483:main.c        **** 					tx_buf[0] = BUT_ADDR;
 1169               	.LM142:
 1170 006e 17E0      		ldi r17,lo8(7)
 484:main.c        **** 					tx_buf[1] = 'N';
 1172               	.LM143:
 1173 0070 0EE4      		ldi r16,lo8(78)
 1174               	.LBE87:
 1175               	.LBB93:
 1176               	.LBB94:
 342:main.c        **** 		boot_spm_busy_wait();		// Wait until the memory is erased.
 1178               	.LM144:
 1179 0072 53E0      		ldi r21,lo8(3)
 1180 0074 752E      		mov r7,r21
 1181               	.LBE94:
 1182               	.LBE93:
 450:main.c        **** 				}
 1184               	.LM145:
 1185 0076 C12C      		mov r12,__zero_reg__
 1186 0078 D12C      		mov r13,__zero_reg__
 1187               	.L41:
 442:main.c        **** 
 1189               	.LM146:
 1190 007a 00D0      		rcall nrf24_receive
 444:main.c        **** 		{
 1192               	.LM147:
 1193 007c 8091 0000 		lds r24,f_rx
 1194 0080 8130      		cpi r24,lo8(1)
 1195 0082 01F0      		breq .+2
 1196 0084 00C0      		rjmp .L42
 446:main.c        **** 			{
 1198               	.LM148:
 1199 0086 8091 0000 		lds r24,rx_buf
 1200 008a 8730      		cpi r24,lo8(7)
 1201 008c 01F0      		breq .+2
 1202 008e 00C0      		rjmp .L43
 448:main.c        **** 				{
 1204               	.LM149:
 1205 0090 8091 0000 		lds r24,rx_buf+1
 1206 0094 8A34      		cpi r24,lo8(74)
 1207 0096 01F4      		brne .L44
 450:main.c        **** 				}
 1209               	.LM150:
 1210 0098 F601      		movw r30,r12
 1211 009a 0995      		icall
 1212               	.L44:
 453:main.c        **** 				{
 1214               	.LM151:
 1215 009c 8091 0000 		lds r24,rx_buf+1
 1216 00a0 8534      		cpi r24,lo8(69)
 1217 00a2 01F4      		brne .L45
 1218 00a4 E0E0      		ldi r30,0
 1219 00a6 F0E0      		ldi r31,0
 1220               	.L47:
 1221               	.LBB96:
 1222               	.LBB95:
 342:main.c        **** 		boot_spm_busy_wait();		// Wait until the memory is erased.
 1224               	.LM152:
 1225               	/* #APP */
 1226               	 ;  342 "main.c" 1
 1227 00a8 7092 5700 		sts 87, r7
 1228 00ac E895      		spm
 1229               		
 1230               	 ;  0 "" 2
 1231               	/* #NOAPP */
 1232               	.L46:
 343:main.c        **** 		addr += SPM_PAGESIZE;
 1234               	.LM153:
 1235 00ae 07B6      		in __tmp_reg__,0x37
 1236 00b0 00FC      		sbrc __tmp_reg__,0
 1237 00b2 00C0      		rjmp .L46
 1238 00b4 E05C      		subi r30,-64
 1239 00b6 FF4F      		sbci r31,-1
 340:main.c        **** 	{
 1241               	.LM154:
 1242 00b8 E115      		cp r30,__zero_reg__
 1243 00ba 28E1      		ldi r18,24
 1244 00bc F207      		cpc r31,r18
 1245 00be 01F4      		brne .L47
 346:main.c        **** }
 1247               	.LM155:
 1248               	/* #APP */
 1249               	 ;  346 "main.c" 1
 1250 00c0 B092 5700 		sts 87, r11
 1251 00c4 E895      		spm
 1252               		
 1253               	 ;  0 "" 2
 1254               	/* #NOAPP */
 1255 00c6 00C0      		rjmp .L48
 1256               	.L45:
 1257               	.LBE95:
 1258               	.LBE96:
 458:main.c        **** 				{
 1260               	.LM156:
 1261 00c8 8735      		cpi r24,lo8(87)
 1262 00ca 01F4      		brne .L48
 460:main.c        **** 					tx_buf[0] = BUT_ADDR;
 1264               	.LM157:
 1265 00cc 969A      		sbi 0x12,6
 461:main.c        **** 					tx_buf[1] = 'W';
 1267               	.LM158:
 1268 00ce 1093 0000 		sts tx_buf,r17
 462:main.c        **** 					NRF24L01_Send(tx_buf);
 1270               	.LM159:
 1271 00d2 8093 0000 		sts tx_buf+1,r24
 463:main.c        **** 					f_wait = 1;
 1273               	.LM160:
 1274 00d6 80E0      		ldi r24,lo8(tx_buf)
 1275 00d8 90E0      		ldi r25,hi8(tx_buf)
 1276 00da 00D0      		rcall NRF24L01_Send
 464:main.c        **** 				}
 1278               	.LM161:
 1279 00dc 6092 0000 		sts f_wait,r6
 1280               	.L48:
 467:main.c        **** 				{
 1282               	.LM162:
 1283 00e0 8091 0000 		lds r24,rx_buf+1
 1284 00e4 8634      		cpi r24,lo8(70)
 1285 00e6 01F0      		breq .+2
 1286 00e8 00C0      		rjmp .L43
 1287               	.LBB97:
 471:main.c        **** 					address = (uint16_t)(rx_buf[4] << 8 | rx_buf[3]); //
 1289               	.LM163:
 1290 00ea C091 0000 		lds r28,rx_buf+2
 1291 00ee 8091 0000 		lds r24,rx_buf+3
 1292 00f2 9091 0000 		lds r25,rx_buf+3+1
 472:main.c        **** 
 1294               	.LM164:
 1295 00f6 9093 0000 		sts address+1,r25
 1296 00fa 8093 0000 		sts address,r24
 1297 00fe A0E0      		ldi r26,lo8(rx_buf+5)
 1298 0100 B0E0      		ldi r27,hi8(rx_buf+5)
 1299               	.LBB91:
 474:main.c        **** 					{
 1301               	.LM165:
 1302 0102 E0E0      		ldi r30,lo8(gBuffer)
 1303 0104 F0E0      		ldi r31,hi8(gBuffer)
 1304 0106 20E0      		ldi r18,0
 1305               	.L49:
 474:main.c        **** 					{
 1307               	.LM166:
 1308 0108 2C17      		cp r18,r28
 1309 010a 01F0      		breq .L60
 476:main.c        **** 					}
 1311               	.LM167:
 1312 010c 3D91      		ld r19,X+
 1313 010e 3193      		st Z+,r19
 474:main.c        **** 					{
 1315               	.LM168:
 1316 0110 2F5F      		subi r18,lo8(-(1))
 1317 0112 00C0      		rjmp .L49
 1318               	.L60:
 1319               	.LBE91:
 1320               	.LBB92:
 1321               	.LBB90:
 376:main.c        **** 	uint32_t baddr = pagestart;
 1323               	.LM169:
 1324 0114 A0E0      		ldi r26,0
 1325 0116 B0E0      		ldi r27,0
 1326 0118 BC01      		movw r22,r24
 1327 011a CD01      		movw r24,r26
 1328 011c 660F      		lsl r22
 1329 011e 771F      		rol r23
 1330 0120 881F      		rol r24
 1331 0122 991F      		rol r25
 379:main.c        **** 
 1333               	.LM170:
 1334 0124 2091 0000 		lds r18,gBuffer
 1335 0128 A0E0      		ldi r26,lo8(gBuffer)
 1336 012a B0E0      		ldi r27,hi8(gBuffer)
 1337 012c AB01      		movw r20,r22
 385:main.c        **** 
 1339               	.LM171:
 1340 012e CB01      		movw r24,r22
 1341 0130 8050      		subi r24,lo8(gBuffer)
 1342 0132 9040      		sbci r25,hi8(gBuffer)
 1343               	.L52:
 1344 0134 FC01      		movw r30,r24
 1345 0136 EA0F      		add r30,r26
 1346 0138 FB1F      		adc r31,r27
 1347 013a 1196      		adiw r26,1
 1348 013c 6C91      		ld r22,X
 1349 013e 1197      		sbiw r26,1
 1350 0140 30E0      		ldi r19,0
 1351 0142 362B      		or r19,r22
 1352               	/* #APP */
 1353               	 ;  385 "main.c" 1
 1354 0144 0901      		movw  r0, r18
 1355 0146 5092 5700 		sts 87, r5
 1356 014a E895      		spm
 1357 014c 1124      		clr  r1
 1358               		
 1359               	 ;  0 "" 2
 388:main.c        **** 	} 
 1361               	.LM172:
 1362               	/* #NOAPP */
 1363 014e C250      		subi r28,lo8(-(-2))
 1364 0150 1296      		adiw r26,2
 390:main.c        **** 
 1366               	.LM173:
 1367 0152 CC23      		tst r28
 1368 0154 01F0      		breq .L51
 384:main.c        **** 		boot_page_fill(baddr, data);	// call asm routine.
 1370               	.LM174:
 1371 0156 2C91      		ld r18,X
 1372 0158 00C0      		rjmp .L52
 1373               	.L51:
 392:main.c        **** 	boot_spm_busy_wait();
 1375               	.LM175:
 1376 015a FA01      		movw r30,r20
 1377               	/* #APP */
 1378               	 ;  392 "main.c" 1
 1379 015c A092 5700 		sts 87, r10
 1380 0160 E895      		spm
 1381               		
 1382               	 ;  0 "" 2
 1383               	/* #NOAPP */
 1384               	.L53:
 393:main.c        **** 	boot_rww_enable();		// Re-enable the RWW section
 1386               	.LM176:
 1387 0162 07B6      		in __tmp_reg__,0x37
 1388 0164 00FC      		sbrc __tmp_reg__,0
 1389 0166 00C0      		rjmp .L53
 394:main.c        **** 
 1391               	.LM177:
 1392               	/* #APP */
 1393               	 ;  394 "main.c" 1
 1394 0168 B092 5700 		sts 87, r11
 1395 016c E895      		spm
 1396               		
 1397               	 ;  0 "" 2
 1398               	/* #NOAPP */
 1399               	.LBE90:
 1400               	.LBE92:
 483:main.c        **** 					tx_buf[1] = 'N';
 1402               	.LM178:
 1403 016e 1093 0000 		sts tx_buf,r17
 1405               	.LM179:
 1406 0172 0093 0000 		sts tx_buf+1,r16
 485:main.c        **** 					NRF24L01_Send(tx_buf);
 1408               	.LM180:
 1409 0176 80E0      		ldi r24,lo8(tx_buf)
 1410 0178 90E0      		ldi r25,hi8(tx_buf)
 1411 017a 00D0      		rcall NRF24L01_Send
 486:main.c        **** 					load_pause = 0;
 1413               	.LM181:
 1414 017c C0E0      		ldi r28,0
 1415 017e D0E0      		ldi r29,0
 1416               	.L43:
 1417               	.LBE97:
 487:main.c        **** 				}
 488:main.c        **** 
 489:main.c        **** 			}
 490:main.c        **** 
 491:main.c        **** 			f_rx = 0;						//опускаем флаг приема
 1419               	.LM182:
 1420 0180 1092 0000 		sts f_rx,__zero_reg__
 1421               	.L42:
 492:main.c        **** 		}
 493:main.c        **** 
 494:main.c        **** 		wdt_reset();
 1423               	.LM183:
 1424               	/* #APP */
 1425               	 ;  494 "main.c" 1
 1426 0184 A895      		wdr
 1427               	 ;  0 "" 2
 495:main.c        **** 
 496:main.c        **** 		if (!f_wait)
 1429               	.LM184:
 1430               	/* #NOAPP */
 1431 0186 8091 0000 		lds r24,f_wait
 1432 018a 8111      		cpse r24,__zero_reg__
 1433 018c 00C0      		rjmp .L54
 497:main.c        **** 		{
 498:main.c        **** 			if (cnt++ >= WAIT_VALUE) 
 1435               	.LM185:
 1436 018e 4701      		movw r8,r14
 1437 0190 FFEF      		ldi r31,-1
 1438 0192 8F1A      		sub r8,r31
 1439 0194 9F0A      		sbc r9,r31
 1440 0196 28EE      		ldi r18,-24
 1441 0198 E216      		cp r14,r18
 1442 019a 23E0      		ldi r18,3
 1443 019c F206      		cpc r15,r18
 1444 019e 00F0      		brlo .L55
 499:main.c        **** 			{
 500:main.c        **** 				jump_to_app();			// Jump to application sector
 1446               	.LM186:
 1447 01a0 F601      		movw r30,r12
 1448 01a2 0995      		icall
 1449               	.L55:
 1450               	.LBB98:
 1451               	.LBB99:
 1453               	.Ltext31:
 187:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 1455               	.LM187:
 1456 01a4 8FEC      		ldi r24,lo8(1999)
 1457 01a6 97E0      		ldi r25,hi8(1999)
 1458 01a8 0197      	1:	sbiw r24,1
 1459 01aa 01F4      		brne 1b
 1460 01ac 00C0      		rjmp .
 1461 01ae 0000      		nop
 1462               	.LBE99:
 1463               	.LBE98:
 1465               	.Ltext32:
 498:main.c        **** 			{
 1467               	.LM188:
 1468 01b0 7401      		movw r14,r8
 1469 01b2 00C0      		rjmp .L41
 1470               	.L54:
 501:main.c        **** 			}
 502:main.c        **** 			_delay_ms(1);		
 503:main.c        **** 		}
 504:main.c        **** 		else
 505:main.c        **** 		{
 506:main.c        **** 			load_pause++;
 1472               	.LM189:
 1473 01b4 2196      		adiw r28,1
 507:main.c        **** 			if (load_pause >= 10000)
 1475               	.LM190:
 1476 01b6 C031      		cpi r28,16
 1477 01b8 97E2      		ldi r25,39
 1478 01ba D907      		cpc r29,r25
 1479 01bc 00F4      		brsh .+2
 1480 01be 00C0      		rjmp .L41
 508:main.c        **** 			{
 509:main.c        **** 				tx_buf[0] = BUT_ADDR;
 1482               	.LM191:
 1483 01c0 1093 0000 		sts tx_buf,r17
 510:main.c        **** 				tx_buf[1] = 'N';
 1485               	.LM192:
 1486 01c4 0093 0000 		sts tx_buf+1,r16
 511:main.c        **** 				NRF24L01_Send(tx_buf);
 1488               	.LM193:
 1489 01c8 80E0      		ldi r24,lo8(tx_buf)
 1490 01ca 90E0      		ldi r25,hi8(tx_buf)
 1491 01cc 00D0      		rcall NRF24L01_Send
 1492               	.LBB100:
 1493               	.LBB101:
 1495               	.Ltext33:
 187:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 1497               	.LM194:
 1498 01ce EFEC      		ldi r30,lo8(1999)
 1499 01d0 F7E0      		ldi r31,hi8(1999)
 1500 01d2 3197      	1:	sbiw r30,1
 1501 01d4 01F4      		brne 1b
 1502 01d6 00C0      		rjmp .
 1503 01d8 0000      		nop
 1504               	.LBE101:
 1505               	.LBE100:
 1507               	.Ltext34:
 512:main.c        **** 				_delay_ms(1);
 513:main.c        **** 				load_pause = 0;
 1509               	.LM195:
 1510 01da C0E0      		ldi r28,0
 1511 01dc D0E0      		ldi r29,0
 1512 01de 00C0      		rjmp .L41
 1532               	.Lscope18:
 1533               	.global	address
 1534               		.section .bss
 1537               	address:
 1538 0000 0000      		.zero	2
 1539               		.comm	gBuffer,64,1
 1540               	.global	f_wait
 1543               	f_wait:
 1544 0002 00        		.zero	1
 1545               		.comm	val,1,1
 1546               	.global	device
 1549               	device:
 1550 0003 00        		.zero	1
 1551               		.comm	buf,20,1
 1552               		.comm	f_send,1,1
 1553               	.global	f_tx
 1556               	f_tx:
 1557 0004 00        		.zero	1
 1558               	.global	f_rx
 1561               	f_rx:
 1562 0005 00        		.zero	1
 1563               	.global	tx_buf
 1566               	tx_buf:
 1567 0006 0000 0000 		.zero	32
 1567      0000 0000 
 1567      0000 0000 
 1567      0000 0000 
 1567      0000 0000 
 1568               	.global	rx_buf
 1571               	rx_buf:
 1572 0026 0000 0000 		.zero	32
 1572      0000 0000 
 1572      0000 0000 
 1572      0000 0000 
 1572      0000 0000 
 1573               	.global	TX_ADDRESS1
 1574               		.data
 1577               	TX_ADDRESS1:
 1578 0000 B7        		.byte	-73
 1579 0001 B5        		.byte	-75
 1580 0002 A1        		.byte	-95
 1581               	.global	TX_ADDRESS0
 1584               	TX_ADDRESS0:
 1585 0003 B5        		.byte	-75
 1586 0004 B5        		.byte	-75
 1587 0005 A1        		.byte	-95
 1601               		.text
 1603               	.Letext0:
 1604               		.ident	"GCC: (AVR_8_bit_GNU_Toolchain_3.6.2_1778) 5.4.0"
 1605               	.global __do_copy_data
 1606               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
C:\Users\vmelehin\AppData\Local\Temp\ccVqJMQD.s:2      *ABS*:0000003e __SP_H__
C:\Users\vmelehin\AppData\Local\Temp\ccVqJMQD.s:3      *ABS*:0000003d __SP_L__
C:\Users\vmelehin\AppData\Local\Temp\ccVqJMQD.s:4      *ABS*:0000003f __SREG__
C:\Users\vmelehin\AppData\Local\Temp\ccVqJMQD.s:5      *ABS*:00000000 __tmp_reg__
C:\Users\vmelehin\AppData\Local\Temp\ccVqJMQD.s:6      *ABS*:00000001 __zero_reg__
C:\Users\vmelehin\AppData\Local\Temp\ccVqJMQD.s:136    .text:00000000 port_init
C:\Users\vmelehin\AppData\Local\Temp\ccVqJMQD.s:172    .text:00000016 spi_init
C:\Users\vmelehin\AppData\Local\Temp\ccVqJMQD.s:201    .text:00000028 spi_sendByte
C:\Users\vmelehin\AppData\Local\Temp\ccVqJMQD.s:227    .text:00000030 spi_changeByte
C:\Users\vmelehin\AppData\Local\Temp\ccVqJMQD.s:255    .text:0000003a NRF24_ReadReg
C:\Users\vmelehin\AppData\Local\Temp\ccVqJMQD.s:298    .text:00000050 NRF24_WriteReg
C:\Users\vmelehin\AppData\Local\Temp\ccVqJMQD.s:332    .text:00000064 NRF24_ToggleFeatures
C:\Users\vmelehin\AppData\Local\Temp\ccVqJMQD.s:376    .text:0000007a NRF24_Read_Buf
C:\Users\vmelehin\AppData\Local\Temp\ccVqJMQD.s:441    .text:000000bc NRF24_Write_Buf
C:\Users\vmelehin\AppData\Local\Temp\ccVqJMQD.s:515    .text:00000100 NRF24_FlushRX
C:\Users\vmelehin\AppData\Local\Temp\ccVqJMQD.s:553    .text:00000112 NRF24_FlushTX
C:\Users\vmelehin\AppData\Local\Temp\ccVqJMQD.s:591    .text:00000124 NRF24L01_RX_Mode
C:\Users\vmelehin\AppData\Local\Temp\ccVqJMQD.s:1577   .data:00000000 TX_ADDRESS1
C:\Users\vmelehin\AppData\Local\Temp\ccVqJMQD.s:654    .text:00000156 NRF24L01_TX_Mode
C:\Users\vmelehin\AppData\Local\Temp\ccVqJMQD.s:1584   .data:00000003 TX_ADDRESS0
C:\Users\vmelehin\AppData\Local\Temp\ccVqJMQD.s:692    .text:00000170 NRF24_Transmit
C:\Users\vmelehin\AppData\Local\Temp\ccVqJMQD.s:772    .text:000001b6 NRF24L01_Send
C:\Users\vmelehin\AppData\Local\Temp\ccVqJMQD.s:869    .text:00000200 nrf24_init
C:\Users\vmelehin\AppData\Local\Temp\ccVqJMQD.s:996    .text:00000278 nrf24_receive
C:\Users\vmelehin\AppData\Local\Temp\ccVqJMQD.s:1571   .bss:00000026 rx_buf
C:\Users\vmelehin\AppData\Local\Temp\ccVqJMQD.s:1561   .bss:00000005 f_rx
C:\Users\vmelehin\AppData\Local\Temp\ccVqJMQD.s:1040   .text.startup:00000000 main
C:\Users\vmelehin\AppData\Local\Temp\ccVqJMQD.s:1566   .bss:00000006 tx_buf
C:\Users\vmelehin\AppData\Local\Temp\ccVqJMQD.s:1543   .bss:00000002 f_wait
C:\Users\vmelehin\AppData\Local\Temp\ccVqJMQD.s:1537   .bss:00000000 address
                            *COM*:00000040 gBuffer
                            *COM*:00000001 val
C:\Users\vmelehin\AppData\Local\Temp\ccVqJMQD.s:1549   .bss:00000003 device
                            *COM*:00000014 buf
                            *COM*:00000001 f_send
C:\Users\vmelehin\AppData\Local\Temp\ccVqJMQD.s:1556   .bss:00000004 f_tx

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
