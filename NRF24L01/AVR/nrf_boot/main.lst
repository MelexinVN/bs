   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
 134               	.global	port_init
 136               	port_init:
   1:main.c        **** 
   2:main.c        **** #define F_CPU 8000000UL
   3:main.c        **** 
   4:main.c        **** #include <avr/io.h>
   5:main.c        **** #include <avr/interrupt.h>
   6:main.c        **** #include <util/delay.h>
   7:main.c        **** #include <avr/wdt.h>
   8:main.c        **** #include <stdio.h>
   9:main.c        **** #include <stdlib.h>
  10:main.c        **** #include <string.h>
  11:main.c        **** #include <stdint.h>
  12:main.c        **** #include <avr/boot.h>
  13:main.c        **** #include <avr/pgmspace.h>
  14:main.c        **** #include <avr/eeprom.h>
  15:main.c        **** #include "chipdef.h"
  16:main.c        **** 
  17:main.c        **** #define DISABLE_WDT_AT_STARTUP
  18:main.c        **** #define BUT_ADDR 		0x07				//адрес кнопки
  19:main.c        **** #define RESET 			0xFF				//команда сброса
  20:main.c        **** #define NOT_PUSHED 		0xFFFFFFFF			//сообщение "кнопка не нажата"
  21:main.c        **** 
  22:main.c        **** #define LED_Pin PORTD6			//пин светодиода
  23:main.c        **** #define LED_GPIO_Port PORTD		//порт светодиода
  24:main.c        **** #define IRQ_Pin PORTD2			//пин прерывания радиомодуля
  25:main.c        **** #define IRQ_GPIO_Port PORTD2	//порт прерывания радиомодуля
  26:main.c        **** #define CE_Pin PORTB0			//пин CE
  27:main.c        **** #define CE_GPIO_Port PORTB		//порт CE
  28:main.c        **** #define CSN_Pin PORTD7			//пин CSN
  29:main.c        **** #define CSN_GPIO_Port PORTD		//порт CSN
  30:main.c        **** 
  31:main.c        **** #define EXIT_WDT_TIME   WDTO_250MS
  32:main.c        **** 
  33:main.c        **** #define WAIT_VALUE 500 //в мс
  34:main.c        **** 
  35:main.c        **** //------------------------------------------------
  36:main.c        **** #define CS_ON()			CSN_GPIO_Port&=~(1<<CSN_Pin)
  37:main.c        **** #define CS_OFF()		CSN_GPIO_Port|=(1<<CSN_Pin)
  38:main.c        **** #define CE_RESET()		CE_GPIO_Port&=~(1<<CE_Pin)
  39:main.c        **** #define CE_SET()		CE_GPIO_Port|=(1<<CE_Pin)
  40:main.c        **** #define IRQ()			IRQ_Pin&(1<<IRQ_Pin)
  41:main.c        **** #define LED_ON()		LED_GPIO_Port|=(1<<LED_Pin)
  42:main.c        **** #define LED_OFF()		LED_GPIO_Port&=~(1<<LED_Pin)
  43:main.c        **** //------------------------------------------------
  44:main.c        **** #define ACTIVATE 		0x50 //
  45:main.c        **** #define RD_RX_PLOAD		0x61 // Define RX payload register address
  46:main.c        **** #define WR_TX_PLOAD		0xA0 // Define TX payload register address
  47:main.c        **** #define FLUSH_TX 		0xE1
  48:main.c        **** #define FLUSH_RX 		0xE2
  49:main.c        **** //------------------------------------------------
  50:main.c        **** #define CONFIG 			0x00 //'Config' register address
  51:main.c        **** #define EN_AA 			0x01 //'Enable Auto Acknowledgment' register address
  52:main.c        **** #define EN_RXADDR 		0x02 //'Enabled RX addresses' register address
  53:main.c        **** #define SETUP_AW 		0x03 //'Setup address width' register address
  54:main.c        **** #define SETUP_RETR 		0x04 //'Setup Auto. Retrans' register address
  55:main.c        **** #define RF_CH 			0x05 //'RF channel' register address
  56:main.c        **** #define RF_SETUP 		0x06 //'RF setup' register address
  57:main.c        **** #define STATUS 			0x07 //'Status' register address
  58:main.c        **** #define OBSERVE_TX 		0x08 //'Transmit observe' register
  59:main.c        **** #define RX_ADDR_P0 		0x0A //'RX address pipe0' register address
  60:main.c        **** #define RX_ADDR_P1 		0x0B //'RX address pipe1' register address
  61:main.c        **** #define TX_ADDR 		0x10 //'TX address' register address
  62:main.c        **** #define RX_PW_P0 		0x11 //'RX payload width, pipe0' register address
  63:main.c        **** #define RX_PW_P1 		0x12 //'RX payload width, pipe1' register address
  64:main.c        **** #define FIFO_STATUS		0x17 //'FIFO Status Register' register address
  65:main.c        **** #define DYNPD 			0x1C
  66:main.c        **** #define FEATURE 		0x1D
  67:main.c        **** //------------------------------------------------
  68:main.c        **** #define PRIM_RX 		0x00 //RX/TX control (1: PRX, 0: PTX)
  69:main.c        **** #define PWR_UP 			0x01 //1: POWER UP, 0:POWER DOWN
  70:main.c        **** #define RX_DR 			0x40 //Data Ready RX FIFO interrupt
  71:main.c        **** #define TX_DS 			0x20 //Data Sent TX FIFO interrupt
  72:main.c        **** #define MAX_RT 			0x10 //Maximum number of TX retransmits interrupt
  73:main.c        **** //------------------------------------------------
  74:main.c        **** #define W_REGISTER 		0x20 //запись в регистр
  75:main.c        **** //------------------------------------------------
  76:main.c        **** #define TX_ADR_WIDTH 3						//размер адреса передачи
  77:main.c        **** #define TX_PLOAD_WIDTH 32					//размер полезной нагрузки
  78:main.c        **** //максимальное число байт, чтобы при добавлении новых функций не переделывать задержки
  79:main.c        **** 
  80:main.c        **** uint8_t TX_ADDRESS0[TX_ADR_WIDTH] = {0xb5,0xb5,0xa1};	//адрес 0
  81:main.c        **** uint8_t TX_ADDRESS1[TX_ADR_WIDTH] = {0xb7,0xb5,0xa1};	//адрес 1
  82:main.c        **** 
  83:main.c        **** uint8_t rx_buf[TX_PLOAD_WIDTH] = {0};				//буфер приема
  84:main.c        **** uint8_t tx_buf[TX_PLOAD_WIDTH] = {0};				//буфер передачи
  85:main.c        **** 
  86:main.c        **** volatile uint8_t f_rx = 0, f_tx = 0;				//флаги приема и передачи
  87:main.c        **** 
  88:main.c        **** uint8_t f_send;								//флаг отправки
  89:main.c        **** 
  90:main.c        **** uint8_t buf[20];							//буфер
  91:main.c        **** uint16_t address;
  92:main.c        **** uint8_t device, val;
  93:main.c        **** uint8_t f_wait = 0;
  94:main.c        **** 
  95:main.c        **** void nrf24_init(void);
  96:main.c        **** uint8_t NRF24_ReadReg(uint8_t addr);
  97:main.c        **** void NRF24_Read_Buf(uint8_t addr,uint8_t *pBuf,uint8_t bytes);
  98:main.c        **** uint8_t NRF24L01_Send(uint8_t *pBuf);
  99:main.c        **** void nrf24l01_receive(void);
 100:main.c        **** void IRQ_Callback(void);
 101:main.c        **** 
 102:main.c        **** uint8_t gBuffer[SPM_PAGESIZE];
 103:main.c        **** uint16_t address = 0;
 104:main.c        **** uint8_t device = 0, val;
 105:main.c        **** 
 106:main.c        **** void port_init(void)//Инициализация портов
 107:main.c        **** {
 138               	.LM0:
 139               	.LFBB1:
 140               	/* prologue: function */
 141               	/* frame size = 0 */
 142               	/* stack size = 0 */
 143               	.L__stack_usage = 0
 108:main.c        **** 	// Input/Output Ports initialization
 109:main.c        **** 	// Port B initialization
 110:main.c        **** 	// Function: Bit7=In Bit6=In Bit5=Out Bit4=In Bit3=Out Bit2=Out Bit1=In Bit0=Out
 111:main.c        **** 	DDRB=(0<<DDB7) | (0<<DDB6) | (1<<DDB5) | (0<<DDB4) | (1<<DDB3) | (1<<DDB2) | (0<<DDB1) | (1<<DDB0)
 145               	.LM1:
 146 0000 8DE2      		ldi r24,lo8(45)
 147 0002 87BB      		out 0x17,r24
 112:main.c        **** 	// State: Bit7=T Bit6=T Bit5=0 Bit4=T Bit3=0 Bit2=0 Bit1=T Bit0=0
 113:main.c        **** 	PORTB=(0<<PORTB7) | (0<<PORTB6) | (0<<PORTB5) | (0<<PORTB4) | (0<<PORTB3) | (0<<PORTB2) | (0<<PORT
 149               	.LM2:
 150 0004 81E0      		ldi r24,lo8(1)
 151 0006 88BB      		out 0x18,r24
 114:main.c        **** 
 115:main.c        **** 	// Port C initialization
 116:main.c        **** 	// Function: Bit6=In Bit5=In Bit4=In Bit3=In Bit2=In Bit1=In Bit0=In
 117:main.c        **** 	DDRC=(0<<DDC6) | (0<<DDC5) | (0<<DDC4) | (0<<DDC3) | (0<<DDC2) | (0<<DDC1) | (0<<DDC0);
 153               	.LM3:
 154 0008 14BA      		out 0x14,__zero_reg__
 118:main.c        **** 	// State: Bit6=T Bit5=T Bit4=T Bit3=T Bit2=T Bit1=T Bit0=T
 119:main.c        **** 	PORTC=(0<<PORTC6) | (0<<PORTC5) | (0<<PORTC4) | (0<<PORTC3) | (0<<PORTC2) | (0<<PORTC1) | (0<<PORT
 156               	.LM4:
 157 000a 15BA      		out 0x15,__zero_reg__
 120:main.c        **** 
 121:main.c        **** 	// Port D initialization
 122:main.c        **** 	// Function: Bit7=Out Bit6=Out Bit5=In Bit4=In Bit3=In Bit2=In Bit1=In Bit0=In
 123:main.c        **** 	DDRD=(1<<DDD7) | (1<<DDD6) | (0<<DDD5) | (0<<DDD4) | (0<<DDD3) | (0<<DDD2) | (0<<DDD1) | (0<<DDD0)
 159               	.LM5:
 160 000c 80EC      		ldi r24,lo8(-64)
 161 000e 81BB      		out 0x11,r24
 124:main.c        **** 	// State: Bit7=0 Bit6=0 Bit5=T Bit4=T Bit3=P Bit2=T Bit1=T Bit0=T
 125:main.c        **** 	PORTD=(1<<PORTD7) | (0<<PORTD6) | (0<<PORTD5) | (0<<PORTD4) | (1<<PORTD3) | (0<<PORTD2) | (0<<PORT
 163               	.LM6:
 164 0010 88E8      		ldi r24,lo8(-120)
 165 0012 82BB      		out 0x12,r24
 166 0014 0895      		ret
 168               	.Lscope1:
 170               	.global	spi_init
 172               	spi_init:
 126:main.c        **** }
 127:main.c        **** 
 128:main.c        **** //инициализация SPI
 129:main.c        **** void spi_init(void)
 130:main.c        **** {
 174               	.LM7:
 175               	.LFBB2:
 176               	/* prologue: function */
 177               	/* frame size = 0 */
 178               	/* stack size = 0 */
 179               	.L__stack_usage = 0
 131:main.c        **** 	DDRB |= ((1<<PORTB2)|(1<<PORTB3)|(1<<PORTB5)); //ножки SPI на выход
 181               	.LM8:
 182 0016 87B3      		in r24,0x17
 183 0018 8C62      		ori r24,lo8(44)
 184 001a 87BB      		out 0x17,r24
 132:main.c        **** 	PORTB &= ~((1<<PORTB2)|(1<<PORTB3)|(1<<PORTB5)); //низкий уровень
 186               	.LM9:
 187 001c 88B3      		in r24,0x18
 188 001e 837D      		andi r24,lo8(-45)
 189 0020 88BB      		out 0x18,r24
 133:main.c        **** 	SPCR=(0<<SPIE) | (1<<SPE) | (0<<DORD) | (1<<MSTR) | (0<<CPOL) | (0<<CPHA) | (0<<SPR1) | (0<<SPR0);
 191               	.LM10:
 192 0022 80E5      		ldi r24,lo8(80)
 193 0024 8DB9      		out 0xd,r24
 194 0026 0895      		ret
 196               	.Lscope2:
 199               	.global	spi_sendByte
 201               	spi_sendByte:
 134:main.c        **** }
 135:main.c        **** 
 136:main.c        **** //отправка байта
 137:main.c        **** void spi_sendByte(uint8_t byte)
 138:main.c        **** {
 203               	.LM11:
 204               	.LFBB3:
 205               	/* prologue: function */
 206               	/* frame size = 0 */
 207               	/* stack size = 0 */
 208               	.L__stack_usage = 0
 139:main.c        **** 	SPDR = byte;				//записываем байт в регистр
 210               	.LM12:
 211 0028 8FB9      		out 0xf,r24
 212               	.L4:
 140:main.c        **** 	while(!(SPSR & (1<<SPIF)));	//подождем пока данные передадутся
 214               	.LM13:
 215 002a 779B      		sbis 0xe,7
 216 002c 00C0      		rjmp .L4
 217               	/* epilogue start */
 141:main.c        **** }
 219               	.LM14:
 220 002e 0895      		ret
 222               	.Lscope3:
 225               	.global	spi_changeByte
 227               	spi_changeByte:
 142:main.c        **** 
 143:main.c        **** //прием/отправка байта
 144:main.c        **** uint8_t spi_changeByte(uint8_t byte)
 145:main.c        **** {
 229               	.LM15:
 230               	.LFBB4:
 231               	/* prologue: function */
 232               	/* frame size = 0 */
 233               	/* stack size = 0 */
 234               	.L__stack_usage = 0
 146:main.c        **** 	SPDR = byte;				//записываем байт в регистр
 236               	.LM16:
 237 0030 8FB9      		out 0xf,r24
 238               	.L8:
 147:main.c        **** 	while(!(SPSR & (1<<SPIF)));	//подождем пока данные передадутся (обменяются)
 240               	.LM17:
 241 0032 779B      		sbis 0xe,7
 242 0034 00C0      		rjmp .L8
 148:main.c        **** 	return SPDR;				//возвращаем принятое значение
 244               	.LM18:
 245 0036 8FB1      		in r24,0xf
 149:main.c        **** }
 247               	.LM19:
 248 0038 0895      		ret
 250               	.Lscope4:
 253               	.global	NRF24_ReadReg
 255               	NRF24_ReadReg:
 150:main.c        **** 
 151:main.c        **** //функция чтения регистра модуля
 152:main.c        **** uint8_t NRF24_ReadReg(uint8_t addr)
 153:main.c        **** {
 257               	.LM20:
 258               	.LFBB5:
 259 003a CF93      		push r28
 260               	/* prologue: function */
 261               	/* frame size = 0 */
 262               	/* stack size = 1 */
 263               	.L__stack_usage = 1
 264 003c C82F      		mov r28,r24
 154:main.c        **** 	uint8_t dt=0, cmd;								//переменные данных и команды
 155:main.c        **** 	CS_ON();											//ногу cs к земле
 266               	.LM21:
 267 003e 9798      		cbi 0x12,7
 156:main.c        **** 	dt = spi_changeByte(addr);						//Прием/отправкадайта адреса регистра
 269               	.LM22:
 270 0040 00D0      		rcall spi_changeByte
 157:main.c        **** 	//если адрес равен адрес регистра статус то и возварщаем его состояние
 158:main.c        **** 	if (addr!=STATUS)//а если не равен
 272               	.LM23:
 273 0042 C730      		cpi r28,lo8(7)
 274 0044 01F0      		breq .L11
 159:main.c        **** 	{
 160:main.c        **** 		cmd=0xFF;									//команда NOP для получения данных
 161:main.c        **** 		dt = spi_changeByte(cmd);					//
 276               	.LM24:
 277 0046 8FEF      		ldi r24,lo8(-1)
 278 0048 00D0      		rcall spi_changeByte
 279               	.L11:
 162:main.c        **** 	}
 163:main.c        **** 	CS_OFF();											//поднимаем ногу CS
 281               	.LM25:
 282 004a 979A      		sbi 0x12,7
 283               	/* epilogue start */
 164:main.c        **** 	return dt;	//возвращаемое значение
 165:main.c        **** }
 285               	.LM26:
 286 004c CF91      		pop r28
 287 004e 0895      		ret
 292               	.Lscope5:
 296               	.global	NRF24_WriteReg
 298               	NRF24_WriteReg:
 166:main.c        **** //------------------------------------------------
 167:main.c        **** //функция записи регистра в модуль
 168:main.c        **** void NRF24_WriteReg(uint8_t addr, uint8_t dt)
 169:main.c        **** {
 300               	.LM27:
 301               	.LFBB6:
 302 0050 CF93      		push r28
 303               	/* prologue: function */
 304               	/* frame size = 0 */
 305               	/* stack size = 1 */
 306               	.L__stack_usage = 1
 307 0052 C62F      		mov r28,r22
 170:main.c        **** 	addr |= W_REGISTER;//включим бит записи в адрес
 171:main.c        **** 	CS_ON();
 309               	.LM28:
 310 0054 9798      		cbi 0x12,7
 172:main.c        **** 	spi_sendByte(addr);									//
 312               	.LM29:
 313 0056 8062      		ori r24,lo8(32)
 314 0058 00D0      		rcall spi_sendByte
 173:main.c        **** 	spi_sendByte(dt);										//
 316               	.LM30:
 317 005a 8C2F      		mov r24,r28
 318 005c 00D0      		rcall spi_sendByte
 174:main.c        **** 	CS_OFF();
 320               	.LM31:
 321 005e 979A      		sbi 0x12,7
 322               	/* epilogue start */
 175:main.c        **** }
 324               	.LM32:
 325 0060 CF91      		pop r28
 326 0062 0895      		ret
 328               	.Lscope6:
 330               	.global	NRF24_ToggleFeatures
 332               	NRF24_ToggleFeatures:
 176:main.c        **** 
 177:main.c        **** //------------------------------------------------
 178:main.c        **** void NRF24_ToggleFeatures(void)							//активация команд R_RX_PL_WID, W_ACK_PAYLOAD и W_TX_PAYLOAD_
 179:main.c        **** {	//есть в даташите "без плюса"
 334               	.LM33:
 335               	.LFBB7:
 336               	/* prologue: function */
 337               	/* frame size = 0 */
 338               	/* stack size = 0 */
 339               	.L__stack_usage = 0
 180:main.c        **** 	uint8_t dt[1] = {ACTIVATE};
 181:main.c        **** 	CS_ON();
 341               	.LM34:
 342 0064 9798      		cbi 0x12,7
 182:main.c        **** 	spi_sendByte(dt[0]);
 344               	.LM35:
 345 0066 80E5      		ldi r24,lo8(80)
 346 0068 00D0      		rcall spi_sendByte
 347               	.LBB30:
 348               	.LBB31:
 350               	.Ltext1:
   1:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    All rights reserved.
   5:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
   6:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
   9:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  12:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      distribution.
  16:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  17:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  21:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  33:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /* $Id$ */
  34:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  35:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  38:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #  endif
  42:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  44:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <inttypes.h>
  45:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <math.h>
  47:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  48:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \file */
  49:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \code
  51:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     #include <util/delay.h>
  54:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \endcode
  55:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  56:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     used.
  60:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  61:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  70:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     routines linked into the application.
  78:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  79:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  83:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** */
  84:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  85:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
  89:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  90:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef F_CPU
  91:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \ingroup util_delay
  94:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \def F_CPU
  95:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  97:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 103:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     integer value.
 107:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****  */
 108:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 110:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 111:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 114:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 115:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #  include <math.h>
 119:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 120:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 121:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /**
 122:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \ingroup util_delay
 123:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 124:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 126:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 129:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 131:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 137:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 142:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    microseconds of delay.
 146:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 147:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    respectively.
 151:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 152:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \note
 153:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 154:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    not available to the compiler then.
 163:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 164:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****  */
 165:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** void
 166:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** _delay_ms(double __ms)
 167:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** {
 168:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	double __tmp ;
 169:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 173:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 176:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 179:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 182:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#else
 183:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		//round up by default
 184:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#endif
 186:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 187:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 189:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #else
 190:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	uint16_t __ticks;
 191:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	if (__tmp < 1.0)
 193:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks = 1;
 194:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	else if (__tmp > 65535)
 195:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	{
 196:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		while(__ticks)
 199:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		{
 200:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 			// wait 1/10 ms
 201:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 			__ticks --;
 203:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		}
 204:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		return;
 205:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	}
 206:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	else
 207:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks = (uint16_t)__tmp;
 208:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	_delay_loop_2(__ticks);
 209:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 210:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** }
 211:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 212:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /**
 213:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \ingroup util_delay
 214:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 215:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 217:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 218:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 220:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 222:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    will not be informed about this case.
 225:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 226:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflow results in
 229:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    no delay i.e., 0us.
 230:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 231:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __us
 234:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    microseconds of delay.
 235:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 236:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    respectively.
 240:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 241:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \note
 242:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 243:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 244:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 246:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 248:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 249:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    not available to the compiler then.
 252:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 253:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****  */
 254:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** void
 255:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** _delay_us(double __us)
 256:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** {
 257:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	double __tmp ;
 258:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   __STDC_HOSTED__
 261:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 262:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 265:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 268:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 271:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#else
 272:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		//round up by default
 273:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#endif
 275:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 276:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 352               	.LM36:
 353 006a 82E0      		ldi r24,lo8(2)
 354 006c 8A95      	1:	dec r24
 355 006e 01F4      		brne 1b
 356 0070 00C0      		rjmp .
 357               	.LBE31:
 358               	.LBE30:
 360               	.Ltext2:
 183:main.c        **** 	_delay_us(1);
 184:main.c        **** 	dt[0] = 0x73;
 185:main.c        **** 	spi_sendByte(dt[0]);
 362               	.LM37:
 363 0072 83E7      		ldi r24,lo8(115)
 364 0074 00D0      		rcall spi_sendByte
 186:main.c        **** 	CS_OFF();
 366               	.LM38:
 367 0076 979A      		sbi 0x12,7
 368 0078 0895      		ret
 370               	.Lscope7:
 374               	.global	NRF24_Read_Buf
 376               	NRF24_Read_Buf:
 187:main.c        **** }
 188:main.c        **** 
 189:main.c        **** //-----------------------------------------------
 190:main.c        **** void NRF24_Read_Buf(uint8_t addr,uint8_t *pBuf,uint8_t bytes)
 191:main.c        **** {//чтение буфера (несколько байт)
 378               	.LM39:
 379               	.LFBB8:
 380 007a EF92      		push r14
 381 007c FF92      		push r15
 382 007e 0F93      		push r16
 383 0080 1F93      		push r17
 384 0082 CF93      		push r28
 385 0084 DF93      		push r29
 386               	/* prologue: function */
 387               	/* frame size = 0 */
 388               	/* stack size = 6 */
 389               	.L__stack_usage = 6
 390 0086 182F      		mov r17,r24
 391 0088 062F      		mov r16,r22
 392 008a E72E      		mov r14,r23
 393 008c F42E      		mov r15,r20
 192:main.c        **** 	CS_ON();
 395               	.LM40:
 396 008e 9798      		cbi 0x12,7
 193:main.c        **** 	spi_sendByte(addr);
 398               	.LM41:
 399 0090 00D0      		rcall spi_sendByte
 400 0092 C02F      		mov r28,r16
 401 0094 DE2D      		mov r29,r14
 402 0096 CE01      		movw r24,r28
 403 0098 8F0D      		add r24,r15
 404 009a 911D      		adc r25,__zero_reg__
 405 009c 7C01      		movw r14,r24
 406               	.L18:
 407               	.LBB32:
 194:main.c        **** 	for (uint8_t i = 0 ; i < bytes ; i++) 		//для нужного количества байт
 409               	.LM42:
 410 009e CE15      		cp r28,r14
 411 00a0 DF05      		cpc r29,r15
 412 00a2 01F0      		breq .L20
 195:main.c        **** 	{																					//
 196:main.c        **** 		pBuf[i] = spi_changeByte(addr);
 414               	.LM43:
 415 00a4 812F      		mov r24,r17
 416 00a6 00D0      		rcall spi_changeByte
 417 00a8 8993      		st Y+,r24
 418 00aa 00C0      		rjmp .L18
 419               	.L20:
 420               	.LBE32:
 197:main.c        **** 	}
 198:main.c        **** 	CS_OFF();
 422               	.LM44:
 423 00ac 979A      		sbi 0x12,7
 424               	/* epilogue start */
 199:main.c        **** }
 426               	.LM45:
 427 00ae DF91      		pop r29
 428 00b0 CF91      		pop r28
 429 00b2 1F91      		pop r17
 430 00b4 0F91      		pop r16
 431 00b6 FF90      		pop r15
 432 00b8 EF90      		pop r14
 433 00ba 0895      		ret
 435               	.Lscope8:
 439               	.global	NRF24_Write_Buf
 441               	NRF24_Write_Buf:
 200:main.c        **** 
 201:main.c        **** //------------------------------------------------
 202:main.c        **** void NRF24_Write_Buf(uint8_t addr,uint8_t *pBuf,uint8_t bytes)
 203:main.c        **** {//запись буфера
 443               	.LM46:
 444               	.LFBB9:
 445 00bc FF92      		push r15
 446 00be 0F93      		push r16
 447 00c0 1F93      		push r17
 448 00c2 CF93      		push r28
 449 00c4 DF93      		push r29
 450               	/* prologue: function */
 451               	/* frame size = 0 */
 452               	/* stack size = 5 */
 453               	.L__stack_usage = 5
 454 00c6 F62E      		mov r15,r22
 455 00c8 072F      		mov r16,r23
 456 00ca 142F      		mov r17,r20
 204:main.c        **** 	addr |= W_REGISTER;//включим бит записи в адрес
 205:main.c        **** 	CS_ON();
 458               	.LM47:
 459 00cc 9798      		cbi 0x12,7
 206:main.c        **** 	spi_sendByte(addr);
 461               	.LM48:
 462 00ce 8062      		ori r24,lo8(32)
 463 00d0 00D0      		rcall spi_sendByte
 464               	.LBB33:
 465               	.LBB34:
 467               	.Ltext3:
 469               	.LM49:
 470 00d2 82E0      		ldi r24,lo8(2)
 471 00d4 8A95      	1:	dec r24
 472 00d6 01F4      		brne 1b
 473 00d8 00C0      		rjmp .
 474 00da CF2D      		mov r28,r15
 475 00dc D02F      		mov r29,r16
 476 00de CE01      		movw r24,r28
 477 00e0 810F      		add r24,r17
 478 00e2 911D      		adc r25,__zero_reg__
 479 00e4 8C01      		movw r16,r24
 480               	.L22:
 481               	.LBE34:
 482               	.LBE33:
 483               	.LBB35:
 485               	.Ltext4:
 207:main.c        **** 	_delay_us(1);
 208:main.c        **** 	for (uint8_t i = 0 ; i < bytes ; i++) 		//для нужного количества байт
 487               	.LM50:
 488 00e6 C017      		cp r28,r16
 489 00e8 D107      		cpc r29,r17
 490 00ea 01F0      		breq .L24
 209:main.c        **** 	{
 210:main.c        **** 		spi_sendByte(pBuf[i]);
 492               	.LM51:
 493 00ec 8991      		ld r24,Y+
 494 00ee 00D0      		rcall spi_sendByte
 495 00f0 00C0      		rjmp .L22
 496               	.L24:
 497               	.LBE35:
 211:main.c        **** 	}
 212:main.c        **** 	CS_OFF();
 499               	.LM52:
 500 00f2 979A      		sbi 0x12,7
 501               	/* epilogue start */
 213:main.c        **** }
 503               	.LM53:
 504 00f4 DF91      		pop r29
 505 00f6 CF91      		pop r28
 506 00f8 1F91      		pop r17
 507 00fa 0F91      		pop r16
 508 00fc FF90      		pop r15
 509 00fe 0895      		ret
 511               	.Lscope9:
 513               	.global	NRF24_FlushRX
 515               	NRF24_FlushRX:
 214:main.c        **** 
 215:main.c        **** //------------------------------------------------
 216:main.c        **** void NRF24_FlushRX(void)
 217:main.c        **** {//очистка буфера приема
 517               	.LM54:
 518               	.LFBB10:
 519               	/* prologue: function */
 520               	/* frame size = 0 */
 521               	/* stack size = 0 */
 522               	.L__stack_usage = 0
 218:main.c        **** 	uint8_t dt[1] = {FLUSH_RX};
 219:main.c        **** 	CS_ON();
 524               	.LM55:
 525 0100 9798      		cbi 0x12,7
 220:main.c        **** 	spi_sendByte(dt[0]);
 527               	.LM56:
 528 0102 82EE      		ldi r24,lo8(-30)
 529 0104 00D0      		rcall spi_sendByte
 530               	.LBB36:
 531               	.LBB37:
 533               	.Ltext5:
 535               	.LM57:
 536 0106 82E0      		ldi r24,lo8(2)
 537 0108 8A95      	1:	dec r24
 538 010a 01F4      		brne 1b
 539 010c 00C0      		rjmp .
 540               	.LBE37:
 541               	.LBE36:
 543               	.Ltext6:
 221:main.c        **** 	_delay_us(1); //пауза в микросекунду для завершения процесса
 222:main.c        **** 	CS_OFF();
 545               	.LM58:
 546 010e 979A      		sbi 0x12,7
 547 0110 0895      		ret
 549               	.Lscope10:
 551               	.global	NRF24_FlushTX
 553               	NRF24_FlushTX:
 223:main.c        **** }
 224:main.c        **** 
 225:main.c        **** //------------------------------------------------
 226:main.c        **** void NRF24_FlushTX(void)
 227:main.c        **** {//очистка буфера передачи
 555               	.LM59:
 556               	.LFBB11:
 557               	/* prologue: function */
 558               	/* frame size = 0 */
 559               	/* stack size = 0 */
 560               	.L__stack_usage = 0
 228:main.c        **** 	uint8_t dt[1] = {FLUSH_TX};
 229:main.c        **** 	CS_ON();
 562               	.LM60:
 563 0112 9798      		cbi 0x12,7
 230:main.c        **** 	spi_sendByte(dt[0]);
 565               	.LM61:
 566 0114 81EE      		ldi r24,lo8(-31)
 567 0116 00D0      		rcall spi_sendByte
 568               	.LBB38:
 569               	.LBB39:
 571               	.Ltext7:
 573               	.LM62:
 574 0118 82E0      		ldi r24,lo8(2)
 575 011a 8A95      	1:	dec r24
 576 011c 01F4      		brne 1b
 577 011e 00C0      		rjmp .
 578               	.LBE39:
 579               	.LBE38:
 581               	.Ltext8:
 231:main.c        **** 	_delay_us(1); //пауза в микросекунду для завершения процесса
 232:main.c        **** 	CS_OFF();
 583               	.LM63:
 584 0120 979A      		sbi 0x12,7
 585 0122 0895      		ret
 587               	.Lscope11:
 589               	.global	NRF24L01_RX_Mode
 591               	NRF24L01_RX_Mode:
 233:main.c        **** }
 234:main.c        **** 
 235:main.c        **** //------------------------------------------------
 236:main.c        **** void NRF24L01_RX_Mode(void)
 237:main.c        **** {//режим приемника
 593               	.LM64:
 594               	.LFBB12:
 595               	/* prologue: function */
 596               	/* frame size = 0 */
 597               	/* stack size = 0 */
 598               	.L__stack_usage = 0
 238:main.c        **** 	uint8_t regval=0x00;
 239:main.c        **** 	regval = NRF24_ReadReg(CONFIG);	//сохраняем значение регистра конфигурации
 600               	.LM65:
 601 0124 80E0      		ldi r24,0
 602 0126 00D0      		rcall NRF24_ReadReg
 240:main.c        **** 	//разбудим модуль и переведём его в режим приёмника, включив биты PWR_UP и PRIM_RX
 241:main.c        **** 	regval |= (1<<PWR_UP)|(1<<PRIM_RX);
 242:main.c        **** 	NRF24_WriteReg(CONFIG,regval);	//возвращаем значение регистра статуса
 604               	.LM66:
 605 0128 682F      		mov r22,r24
 606 012a 6360      		ori r22,lo8(3)
 607 012c 80E0      		ldi r24,0
 608 012e 00D0      		rcall NRF24_WriteReg
 243:main.c        **** 	
 244:main.c        **** 	NRF24_Write_Buf(TX_ADDR, TX_ADDRESS1, TX_ADR_WIDTH);		//записываем  адрес передатчика
 610               	.LM67:
 611 0130 43E0      		ldi r20,lo8(3)
 612 0132 60E0      		ldi r22,lo8(TX_ADDRESS1)
 613 0134 70E0      		ldi r23,hi8(TX_ADDRESS1)
 614 0136 80E1      		ldi r24,lo8(16)
 615 0138 00D0      		rcall NRF24_Write_Buf
 245:main.c        **** 	NRF24_Write_Buf(RX_ADDR_P0, TX_ADDRESS1, TX_ADR_WIDTH);	//записываем адрес приемника
 617               	.LM68:
 618 013a 43E0      		ldi r20,lo8(3)
 619 013c 60E0      		ldi r22,lo8(TX_ADDRESS1)
 620 013e 70E0      		ldi r23,hi8(TX_ADDRESS1)
 621 0140 8AE0      		ldi r24,lo8(10)
 622 0142 00D0      		rcall NRF24_Write_Buf
 246:main.c        **** 	
 247:main.c        **** 	CE_SET();
 624               	.LM69:
 625 0144 C09A      		sbi 0x18,0
 626               	.LBB40:
 627               	.LBB41:
 629               	.Ltext9:
 631               	.LM70:
 632 0146 8BE2      		ldi r24,lo8(299)
 633 0148 91E0      		ldi r25,hi8(299)
 634 014a 0197      	1:	sbiw r24,1
 635 014c 01F4      		brne 1b
 636 014e 00C0      		rjmp .
 637 0150 0000      		nop
 638               	.LBE41:
 639               	.LBE40:
 641               	.Ltext10:
 248:main.c        **** 	_delay_us(150); //Задержка минимум 130 мкс
 249:main.c        **** 	// Flush buffers
 250:main.c        **** 	NRF24_FlushRX();
 643               	.LM71:
 644 0152 00D0      		rcall NRF24_FlushRX
 251:main.c        **** 	NRF24_FlushTX();
 646               	.LM72:
 647 0154 00C0      		rjmp NRF24_FlushTX
 649               	.Lscope12:
 652               	.global	NRF24L01_TX_Mode
 654               	NRF24L01_TX_Mode:
 252:main.c        **** }
 253:main.c        **** 
 254:main.c        **** //------------------------------------------------
 255:main.c        **** void NRF24L01_TX_Mode(uint8_t *pBuf)
 256:main.c        **** {//режим передатчика
 656               	.LM73:
 657               	.LFBB13:
 658               	/* prologue: function */
 659               	/* frame size = 0 */
 660               	/* stack size = 0 */
 661               	.L__stack_usage = 0
 257:main.c        **** 	NRF24_Write_Buf(TX_ADDR, TX_ADDRESS0, TX_ADR_WIDTH);		//записываем адрес передатчика
 663               	.LM74:
 664 0156 43E0      		ldi r20,lo8(3)
 665 0158 60E0      		ldi r22,lo8(TX_ADDRESS0)
 666 015a 70E0      		ldi r23,hi8(TX_ADDRESS0)
 667 015c 80E1      		ldi r24,lo8(16)
 668 015e 00D0      		rcall NRF24_Write_Buf
 258:main.c        **** 	NRF24_Write_Buf(RX_ADDR_P0, TX_ADDRESS0, TX_ADR_WIDTH);	//записываем адрес приемника
 670               	.LM75:
 671 0160 43E0      		ldi r20,lo8(3)
 672 0162 60E0      		ldi r22,lo8(TX_ADDRESS0)
 673 0164 70E0      		ldi r23,hi8(TX_ADDRESS0)
 674 0166 8AE0      		ldi r24,lo8(10)
 675 0168 00D0      		rcall NRF24_Write_Buf
 259:main.c        **** 	CE_RESET();
 677               	.LM76:
 678 016a C098      		cbi 0x18,0
 260:main.c        **** 	// Flush buffers
 261:main.c        **** 	NRF24_FlushRX();
 680               	.LM77:
 681 016c 00D0      		rcall NRF24_FlushRX
 262:main.c        **** 	NRF24_FlushTX();
 683               	.LM78:
 684 016e 00C0      		rjmp NRF24_FlushTX
 686               	.Lscope13:
 690               	.global	NRF24_Transmit
 692               	NRF24_Transmit:
 263:main.c        **** }
 264:main.c        **** 
 265:main.c        **** //------------------------------------------------
 266:main.c        **** void NRF24_Transmit(uint8_t addr,uint8_t *pBuf,uint8_t bytes)
 267:main.c        **** {//передача данных в модуль
 694               	.LM79:
 695               	.LFBB14:
 696 0170 FF92      		push r15
 697 0172 0F93      		push r16
 698 0174 1F93      		push r17
 699 0176 CF93      		push r28
 700 0178 DF93      		push r29
 701               	/* prologue: function */
 702               	/* frame size = 0 */
 703               	/* stack size = 5 */
 704               	.L__stack_usage = 5
 705 017a F62E      		mov r15,r22
 706 017c 072F      		mov r16,r23
 707 017e 142F      		mov r17,r20
 268:main.c        **** 	CE_RESET();
 709               	.LM80:
 710 0180 C098      		cbi 0x18,0
 269:main.c        **** 	CS_ON();
 712               	.LM81:
 713 0182 9798      		cbi 0x12,7
 270:main.c        **** 	spi_sendByte(addr);
 715               	.LM82:
 716 0184 00D0      		rcall spi_sendByte
 717               	.LBB42:
 718               	.LBB43:
 720               	.Ltext11:
 722               	.LM83:
 723 0186 82E0      		ldi r24,lo8(2)
 724 0188 8A95      	1:	dec r24
 725 018a 01F4      		brne 1b
 726 018c 00C0      		rjmp .
 727 018e CF2D      		mov r28,r15
 728 0190 D02F      		mov r29,r16
 729 0192 CE01      		movw r24,r28
 730 0194 810F      		add r24,r17
 731 0196 911D      		adc r25,__zero_reg__
 732 0198 8C01      		movw r16,r24
 733               	.L30:
 734               	.LBE43:
 735               	.LBE42:
 736               	.LBB44:
 738               	.Ltext12:
 271:main.c        **** 	_delay_us(1); //пауза в микросекунду для завершения процесса
 272:main.c        **** 	for (uint8_t i = 0 ; i < bytes ; i++)
 740               	.LM84:
 741 019a C017      		cp r28,r16
 742 019c D107      		cpc r29,r17
 743 019e 01F0      		breq .L32
 273:main.c        **** 	{
 274:main.c        **** 		spi_sendByte(pBuf[i]);
 745               	.LM85:
 746 01a0 8991      		ld r24,Y+
 747 01a2 00D0      		rcall spi_sendByte
 748 01a4 00C0      		rjmp .L30
 749               	.L32:
 750               	.LBE44:
 275:main.c        **** 	}
 276:main.c        **** 	CS_OFF();
 752               	.LM86:
 753 01a6 979A      		sbi 0x12,7
 277:main.c        **** 	CE_SET();
 755               	.LM87:
 756 01a8 C09A      		sbi 0x18,0
 757               	/* epilogue start */
 278:main.c        **** }
 759               	.LM88:
 760 01aa DF91      		pop r29
 761 01ac CF91      		pop r28
 762 01ae 1F91      		pop r17
 763 01b0 0F91      		pop r16
 764 01b2 FF90      		pop r15
 765 01b4 0895      		ret
 767               	.Lscope14:
 770               	.global	NRF24L01_Send
 772               	NRF24L01_Send:
 279:main.c        **** 
 280:main.c        **** //------------------------------------------------
 281:main.c        **** uint8_t NRF24L01_Send(uint8_t *pBuf)
 282:main.c        **** {//отправка данных в эфир
 774               	.LM89:
 775               	.LFBB15:
 776 01b6 CF93      		push r28
 777 01b8 DF93      		push r29
 778               	/* prologue: function */
 779               	/* frame size = 0 */
 780               	/* stack size = 2 */
 781               	.L__stack_usage = 2
 782 01ba EC01      		movw r28,r24
 283:main.c        **** 	uint8_t regval=0x00;						//переменная для отправки в конфигурационный регистр
 284:main.c        **** 	NRF24L01_TX_Mode(pBuf);					//включаем режим передачи
 784               	.LM90:
 785 01bc 00D0      		rcall NRF24L01_TX_Mode
 285:main.c        **** 	regval = NRF24_ReadReg(CONFIG);	//сохраняем значения конфигурационного региста
 787               	.LM91:
 788 01be 80E0      		ldi r24,0
 789 01c0 00D0      		rcall NRF24_ReadReg
 790 01c2 8E7F      		andi r24,lo8(-2)
 286:main.c        **** 	//если модуль ушел в спящий режим, то разбудим его, включив бит PWR_UP и выключив PRIM_RX
 287:main.c        **** 	regval |= (1<<PWR_UP);
 288:main.c        **** 	regval &= ~(1<<PRIM_RX);
 289:main.c        **** 	NRF24_WriteReg(CONFIG,regval);//записываем новое значение конфигурационного регистра
 792               	.LM92:
 793 01c4 682F      		mov r22,r24
 794 01c6 6260      		ori r22,lo8(2)
 795 01c8 80E0      		ldi r24,0
 796 01ca 00D0      		rcall NRF24_WriteReg
 797               	.LBB45:
 798               	.LBB46:
 800               	.Ltext13:
 802               	.LM93:
 803 01cc 8BE2      		ldi r24,lo8(299)
 804 01ce 91E0      		ldi r25,hi8(299)
 805 01d0 0197      	1:	sbiw r24,1
 806 01d2 01F4      		brne 1b
 807 01d4 00C0      		rjmp .
 808 01d6 0000      		nop
 809               	.LBE46:
 810               	.LBE45:
 812               	.Ltext14:
 290:main.c        **** 	_delay_us(150); //Задержка минимум 130 мкс
 291:main.c        **** 	//Отправим данные в воздух
 292:main.c        **** 	NRF24_Transmit(WR_TX_PLOAD, pBuf, TX_PLOAD_WIDTH);//отправка данных
 814               	.LM94:
 815 01d8 40E2      		ldi r20,lo8(32)
 816 01da BE01      		movw r22,r28
 817 01dc 80EA      		ldi r24,lo8(-96)
 818 01de 00D0      		rcall NRF24_Transmit
 293:main.c        **** 	CE_SET();
 820               	.LM95:
 821 01e0 C09A      		sbi 0x18,0
 822               	.LBB47:
 823               	.LBB48:
 825               	.Ltext15:
 827               	.LM96:
 828 01e2 98E2      		ldi r25,lo8(40)
 829 01e4 9A95      	1:	dec r25
 830 01e6 01F4      		brne 1b
 831               	.LBE48:
 832               	.LBE47:
 834               	.Ltext16:
 294:main.c        **** 	_delay_us(15); //minimum 10us high pulse (Page 21)
 295:main.c        **** 	CE_RESET();
 836               	.LM97:
 837 01e8 C098      		cbi 0x18,0
 296:main.c        **** 	NRF24L01_RX_Mode();				//переход в режим приема
 839               	.LM98:
 840 01ea 00D0      		rcall NRF24L01_RX_Mode
 297:main.c        **** 	return 0;
 298:main.c        **** }
 842               	.LM99:
 843 01ec 80E0      		ldi r24,0
 844               	/* epilogue start */
 845 01ee DF91      		pop r29
 846 01f0 CF91      		pop r28
 847 01f2 0895      		ret
 849               	.Lscope15:
 851               	.global	nrf24_init
 853               	nrf24_init:
 299:main.c        **** 
 300:main.c        **** //------------------------------------------------
 301:main.c        **** void nrf24_init(void)
 302:main.c        **** {//инициализация
 855               	.LM100:
 856               	.LFBB16:
 857               	/* prologue: function */
 858               	/* frame size = 0 */
 859               	/* stack size = 0 */
 860               	.L__stack_usage = 0
 303:main.c        **** 	CE_RESET();							//опускаем к земле вывод ce
 862               	.LM101:
 863 01f4 C098      		cbi 0x18,0
 864               	.LBB49:
 865               	.LBB50:
 867               	.Ltext17:
 869               	.LM102:
 870 01f6 8FE0      		ldi r24,lo8(9999)
 871 01f8 97E2      		ldi r25,hi8(9999)
 872 01fa 0197      	1:	sbiw r24,1
 873 01fc 01F4      		brne 1b
 874 01fe 00C0      		rjmp .
 875 0200 0000      		nop
 876               	.LBE50:
 877               	.LBE49:
 879               	.Ltext18:
 304:main.c        **** 	_delay_us(5000);					//задержка 5 мс
 305:main.c        **** 	//записываем конфигурационный байт,
 306:main.c        **** 	NRF24_WriteReg(CONFIG, 0x0a);		// Set PWR_UP bit, enable CRC(1 byte) &Prim_RX:0 (Transmitter)
 881               	.LM103:
 882 0202 6AE0      		ldi r22,lo8(10)
 883 0204 80E0      		ldi r24,0
 884 0206 00D0      		rcall NRF24_WriteReg
 885               	.LBB51:
 886               	.LBB52:
 888               	.Ltext19:
 890               	.LM104:
 891 0208 8FE0      		ldi r24,lo8(9999)
 892 020a 97E2      		ldi r25,hi8(9999)
 893 020c 0197      	1:	sbiw r24,1
 894 020e 01F4      		brne 1b
 895 0210 00C0      		rjmp .
 896 0212 0000      		nop
 897               	.LBE52:
 898               	.LBE51:
 900               	.Ltext20:
 307:main.c        **** 	_delay_us(5000);
 308:main.c        **** 	NRF24_WriteReg(EN_AA, 0x00);		// Enable Pipe0
 902               	.LM105:
 903 0214 60E0      		ldi r22,0
 904 0216 81E0      		ldi r24,lo8(1)
 905 0218 00D0      		rcall NRF24_WriteReg
 309:main.c        **** 	NRF24_WriteReg(EN_RXADDR, 0x01);	// Enable Pipe0
 907               	.LM106:
 908 021a 61E0      		ldi r22,lo8(1)
 909 021c 82E0      		ldi r24,lo8(2)
 910 021e 00D0      		rcall NRF24_WriteReg
 310:main.c        **** 	NRF24_WriteReg(SETUP_AW, 0x01);		// Setup address width=3 bytes
 912               	.LM107:
 913 0220 61E0      		ldi r22,lo8(1)
 914 0222 83E0      		ldi r24,lo8(3)
 915 0224 00D0      		rcall NRF24_WriteReg
 311:main.c        **** 	NRF24_WriteReg(SETUP_RETR, 0x00);	// 1500us, 15 retrans
 917               	.LM108:
 918 0226 60E0      		ldi r22,0
 919 0228 84E0      		ldi r24,lo8(4)
 920 022a 00D0      		rcall NRF24_WriteReg
 312:main.c        **** 	NRF24_ToggleFeatures();				//активация команд
 922               	.LM109:
 923 022c 00D0      		rcall NRF24_ToggleFeatures
 313:main.c        **** 	NRF24_WriteReg(FEATURE, 0x07);			//установка стандартных значений регистра FEATURE
 925               	.LM110:
 926 022e 67E0      		ldi r22,lo8(7)
 927 0230 8DE1      		ldi r24,lo8(29)
 928 0232 00D0      		rcall NRF24_WriteReg
 314:main.c        **** 	NRF24_WriteReg(DYNPD, 0);			//отключение динамического размера полезной нагрузки
 930               	.LM111:
 931 0234 60E0      		ldi r22,0
 932 0236 8CE1      		ldi r24,lo8(28)
 933 0238 00D0      		rcall NRF24_WriteReg
 315:main.c        **** 	NRF24_WriteReg(STATUS, 0x70);		//Reset flags for IRQ
 935               	.LM112:
 936 023a 60E7      		ldi r22,lo8(112)
 937 023c 87E0      		ldi r24,lo8(7)
 938 023e 00D0      		rcall NRF24_WriteReg
 316:main.c        **** 	NRF24_WriteReg(RF_CH, 76);			// частота 2476 MHz
 940               	.LM113:
 941 0240 6CE4      		ldi r22,lo8(76)
 942 0242 85E0      		ldi r24,lo8(5)
 943 0244 00D0      		rcall NRF24_WriteReg
 317:main.c        **** 	NRF24_WriteReg(RF_SETUP, 0x06);		//TX_PWR:0dBm, Datarate:1Mbps
 945               	.LM114:
 946 0246 66E0      		ldi r22,lo8(6)
 947 0248 86E0      		ldi r24,lo8(6)
 948 024a 00D0      		rcall NRF24_WriteReg
 318:main.c        **** 	NRF24_Write_Buf(TX_ADDR, TX_ADDRESS0, TX_ADR_WIDTH);//запись адреса передачи
 950               	.LM115:
 951 024c 43E0      		ldi r20,lo8(3)
 952 024e 60E0      		ldi r22,lo8(TX_ADDRESS0)
 953 0250 70E0      		ldi r23,hi8(TX_ADDRESS0)
 954 0252 80E1      		ldi r24,lo8(16)
 955 0254 00D0      		rcall NRF24_Write_Buf
 319:main.c        **** 	NRF24_Write_Buf(RX_ADDR_P1, TX_ADDRESS0, TX_ADR_WIDTH);//запись адреса приема
 957               	.LM116:
 958 0256 43E0      		ldi r20,lo8(3)
 959 0258 60E0      		ldi r22,lo8(TX_ADDRESS0)
 960 025a 70E0      		ldi r23,hi8(TX_ADDRESS0)
 961 025c 8BE0      		ldi r24,lo8(11)
 962 025e 00D0      		rcall NRF24_Write_Buf
 320:main.c        **** 	NRF24_WriteReg(RX_PW_P0, TX_PLOAD_WIDTH); //Number of bytes in RX payload in data pipe 1
 964               	.LM117:
 965 0260 60E2      		ldi r22,lo8(32)
 966 0262 81E1      		ldi r24,lo8(17)
 967 0264 00D0      		rcall NRF24_WriteReg
 321:main.c        **** 	//пока уходим в режим приёмника
 322:main.c        **** 	NRF24L01_RX_Mode();					//режим приема
 969               	.LM118:
 970 0266 00D0      		rcall NRF24L01_RX_Mode
 323:main.c        **** 	LED_OFF();
 972               	.LM119:
 973 0268 9698      		cbi 0x12,6
 974 026a 0895      		ret
 976               	.Lscope16:
 978               	.global	nrf24_receive
 980               	nrf24_receive:
 324:main.c        **** }
 325:main.c        **** 
 326:main.c        **** //--------------------------------------------------
 327:main.c        **** void nrf24_receive(void)
 328:main.c        **** {
 982               	.LM120:
 983               	.LFBB17:
 984               	/* prologue: function */
 985               	/* frame size = 0 */
 986               	/* stack size = 0 */
 987               	.L__stack_usage = 0
 329:main.c        **** 	uint8_t status = 0x01;	//переменная статус
 330:main.c        **** 	status = NRF24_ReadReg(STATUS);	//чтение значения регистра статуса
 989               	.LM121:
 990 026c 87E0      		ldi r24,lo8(7)
 991 026e 00D0      		rcall NRF24_ReadReg
 331:main.c        **** 	if(status & RX_DR)				//если есть данные на прием
 993               	.LM122:
 994 0270 86FF      		sbrs r24,6
 995 0272 00C0      		rjmp .L35
 996               	.LBB55:
 997               	.LBB56:
 332:main.c        **** 	{
 333:main.c        **** 		NRF24_Read_Buf(RD_RX_PLOAD,rx_buf,TX_PLOAD_WIDTH);//чтение буфера
 999               	.LM123:
 1000 0274 40E2      		ldi r20,lo8(32)
 1001 0276 60E0      		ldi r22,lo8(rx_buf)
 1002 0278 70E0      		ldi r23,hi8(rx_buf)
 1003 027a 81E6      		ldi r24,lo8(97)
 1004 027c 00D0      		rcall NRF24_Read_Buf
 334:main.c        **** 		NRF24_WriteReg(STATUS, 0x40);	//запись в регистр статуса 1 в шестой бит, обнуление остальных
 1006               	.LM124:
 1007 027e 60E4      		ldi r22,lo8(64)
 1008 0280 87E0      		ldi r24,lo8(7)
 1009 0282 00D0      		rcall NRF24_WriteReg
 335:main.c        **** 		f_rx = 1;						//поднимаем флаг приема
 1011               	.LM125:
 1012 0284 81E0      		ldi r24,lo8(1)
 1013 0286 8093 0000 		sts f_rx,r24
 1014               	.L35:
 1015 028a 0895      		ret
 1016               	.LBE56:
 1017               	.LBE55:
 1019               	.Lscope17:
 1020               		.section	.text.startup,"ax",@progbits
 1022               	.global	main
 1024               	main:
 336:main.c        **** 	}
 337:main.c        **** }
 338:main.c        **** 
 339:main.c        **** static inline void eraseFlash(void)
 340:main.c        **** {
 341:main.c        **** 	// erase only main section (bootloader protection)
 342:main.c        **** 	uint32_t addr = 0;
 343:main.c        **** 	while (APP_END > addr) 
 344:main.c        **** 	{
 345:main.c        **** 		boot_page_erase(addr);		// Perform page erase
 346:main.c        **** 		boot_spm_busy_wait();		// Wait until the memory is erased.
 347:main.c        **** 		addr += SPM_PAGESIZE;
 348:main.c        **** 	}
 349:main.c        **** 	boot_rww_enable();
 350:main.c        **** }
 351:main.c        **** 
 352:main.c        **** static inline uint16_t writeFlashPage(uint16_t waddr, pagebuf_t size)
 353:main.c        **** {
 354:main.c        **** 	uint32_t pagestart = (uint32_t)waddr<<1;
 355:main.c        **** 	uint32_t baddr = pagestart;
 356:main.c        **** 	uint16_t data;
 357:main.c        **** 	uint8_t *tmp = gBuffer;
 358:main.c        **** 
 359:main.c        **** 	do 
 360:main.c        **** 		{
 361:main.c        **** 		data = *tmp++;
 362:main.c        **** 		data |= *tmp++ << 8;
 363:main.c        **** 		boot_page_fill(baddr, data);	// call asm routine.
 364:main.c        **** 
 365:main.c        **** 		baddr += 2;			// Select next word in memory
 366:main.c        **** 		size -= 2;			// Reduce number of bytes to write by two
 367:main.c        **** 		} 
 368:main.c        **** 	while (size);				// Loop until all bytes written
 369:main.c        **** 
 370:main.c        **** 	boot_page_write(pagestart);
 371:main.c        **** 	boot_spm_busy_wait();
 372:main.c        **** 	boot_rww_enable();		// Re-enable the RWW section
 373:main.c        **** 
 374:main.c        **** 	return baddr>>1;
 375:main.c        **** }
 376:main.c        **** 
 377:main.c        **** static inline uint16_t writeEEpromPage(uint16_t address, pagebuf_t size)
 378:main.c        **** {
 379:main.c        **** 	uint8_t *tmp = gBuffer;
 380:main.c        **** 
 381:main.c        **** 	do 
 382:main.c        **** 		{
 383:main.c        **** 		eeprom_write_byte( (uint8_t*)address, *tmp++ );
 384:main.c        **** 		address++;			// Select next byte
 385:main.c        **** 		size--;				// Decreas number of bytes to write
 386:main.c        **** 		}
 387:main.c        **** 	while (size);				// Loop until all bytes written
 388:main.c        **** 
 389:main.c        **** 	//eeprom_busy_wait();
 390:main.c        **** 
 391:main.c        **** 	return address;
 392:main.c        **** }
 393:main.c        **** 
 394:main.c        **** static void (*jump_to_app)(void) = 0x0000;
 395:main.c        **** 
 396:main.c        **** int main(void)
 397:main.c        **** {
 1026               	.LM126:
 1027               	.LFBB18:
 1028               	/* prologue: function */
 1029               	/* frame size = 0 */
 1030               	/* stack size = 0 */
 1031               	.L__stack_usage = 0
 398:main.c        **** 	port_init();							//инициализация портов
 1033               	.LM127:
 1034 0000 00D0      		rcall port_init
 399:main.c        **** 	spi_init();								//инициализация SPI
 1036               	.LM128:
 1037 0002 00D0      		rcall spi_init
 400:main.c        **** 	nrf24_init();
 1039               	.LM129:
 1040 0004 00D0      		rcall nrf24_init
 401:main.c        **** 
 402:main.c        **** 	uint8_t blink_counter = 2;
 403:main.c        **** 	while (blink_counter)
 404:main.c        **** 	{
 405:main.c        **** 		LED_ON();
 1042               	.LM130:
 1043 0006 969A      		sbi 0x12,6
 1044               	.LBB67:
 1045               	.LBB68:
 1047               	.Ltext21:
 187:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 1049               	.LM131:
 1050 0008 2FEF      		ldi r18,lo8(159999)
 1051 000a 80E7      		ldi r24,hi8(159999)
 1052 000c 92E0      		ldi r25,hlo8(159999)
 1053 000e 2150      	1:	subi r18,1
 1054 0010 8040      		sbci r24,0
 1055 0012 9040      		sbci r25,0
 1056 0014 01F4      		brne 1b
 1057 0016 00C0      		rjmp .
 1058 0018 0000      		nop
 1059               	.LBE68:
 1060               	.LBE67:
 1062               	.Ltext22:
 406:main.c        **** 		_delay_ms(100);
 407:main.c        **** 		LED_OFF();
 1064               	.LM132:
 1065 001a 9698      		cbi 0x12,6
 1066               	.LBB70:
 1067               	.LBB71:
 1069               	.Ltext23:
 187:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 1071               	.LM133:
 1072 001c AFEF      		ldi r26,lo8(159999)
 1073 001e B0E7      		ldi r27,hi8(159999)
 1074 0020 E2E0      		ldi r30,hlo8(159999)
 1075 0022 A150      	1:	subi r26,1
 1076 0024 B040      		sbci r27,0
 1077 0026 E040      		sbci r30,0
 1078 0028 01F4      		brne 1b
 1079 002a 00C0      		rjmp .
 1080 002c 0000      		nop
 1081               	.LBE71:
 1082               	.LBE70:
 1084               	.Ltext24:
 405:main.c        **** 		_delay_ms(100);
 1086               	.LM134:
 1087 002e 969A      		sbi 0x12,6
 1088               	.LBB73:
 1089               	.LBB69:
 1091               	.Ltext25:
 187:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 1093               	.LM135:
 1094 0030 FFEF      		ldi r31,lo8(159999)
 1095 0032 20E7      		ldi r18,hi8(159999)
 1096 0034 82E0      		ldi r24,hlo8(159999)
 1097 0036 F150      	1:	subi r31,1
 1098 0038 2040      		sbci r18,0
 1099 003a 8040      		sbci r24,0
 1100 003c 01F4      		brne 1b
 1101 003e 00C0      		rjmp .
 1102 0040 0000      		nop
 1103               	.LBE69:
 1104               	.LBE73:
 1106               	.Ltext26:
 1108               	.LM136:
 1109 0042 9698      		cbi 0x12,6
 1110               	.LBB74:
 1111               	.LBB72:
 1113               	.Ltext27:
 187:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 1115               	.LM137:
 1116 0044 9FEF      		ldi r25,lo8(159999)
 1117 0046 A0E7      		ldi r26,hi8(159999)
 1118 0048 B2E0      		ldi r27,hlo8(159999)
 1119 004a 9150      	1:	subi r25,1
 1120 004c A040      		sbci r26,0
 1121 004e B040      		sbci r27,0
 1122 0050 01F4      		brne 1b
 1123 0052 00C0      		rjmp .
 1124 0054 0000      		nop
 1125               	.LBE72:
 1126               	.LBE74:
 1127               	.LBB75:
 1128               	.LBB76:
 1129               	.LBB77:
 1131               	.Ltext28:
 363:main.c        **** 
 1133               	.LM138:
 1134 0056 D1E0      		ldi r29,lo8(1)
 370:main.c        **** 	boot_spm_busy_wait();
 1136               	.LM139:
 1137 0058 15E0      		ldi r17,lo8(5)
 372:main.c        **** 
 1139               	.LM140:
 1140 005a C1E1      		ldi r28,lo8(17)
 1141               	.LBE77:
 1142               	.LBE76:
 1143               	.LBE75:
 1144               	.LBB81:
 1145               	.LBB82:
 345:main.c        **** 		boot_spm_busy_wait();		// Wait until the memory is erased.
 1147               	.LM141:
 1148 005c 03E0      		ldi r16,lo8(3)
 1149               	.L41:
 1150               	.LBE82:
 1151               	.LBE81:
 408:main.c        **** 		_delay_ms(100);
 409:main.c        **** 		blink_counter--;
 410:main.c        **** 	}
 411:main.c        **** 
 412:main.c        **** 	uint16_t cnt = 0;
 413:main.c        **** 
 414:main.c        **** 	while (1) 
 415:main.c        **** 	{
 416:main.c        **** 		nrf24_receive();
 1153               	.LM142:
 1154 005e 00D0      		rcall nrf24_receive
 417:main.c        **** 
 418:main.c        **** 		if(f_rx == 1)						//если флаг приема поднят
 1156               	.LM143:
 1157 0060 9091 0000 		lds r25,f_rx
 1158 0064 9130      		cpi r25,lo8(1)
 1159 0066 01F4      		brne .L41
 419:main.c        **** 		{
 420:main.c        **** 			if (rx_buf[0] == BUT_ADDR)		//если первый принятый байт совпадает с адресом кнопки
 1161               	.LM144:
 1162 0068 8091 0000 		lds r24,rx_buf
 1163 006c 8730      		cpi r24,lo8(7)
 1164 006e 01F0      		breq .+2
 1165 0070 00C0      		rjmp .L43
 421:main.c        **** 			{
 422:main.c        **** 				
 423:main.c        **** 				if (rx_buf[1] == 'E')	
 1167               	.LM145:
 1168 0072 8091 0000 		lds r24,rx_buf+1
 1169 0076 8534      		cpi r24,lo8(69)
 1170 0078 01F4      		brne .L44
 1171 007a E0E0      		ldi r30,0
 1172 007c F0E0      		ldi r31,0
 1173               	.L46:
 1174               	.LBB84:
 1175               	.LBB83:
 345:main.c        **** 		boot_spm_busy_wait();		// Wait until the memory is erased.
 1177               	.LM146:
 1178               	/* #APP */
 1179               	 ;  345 "main.c" 1
 1180 007e 0093 5700 		sts 87, r16
 1181 0082 E895      		spm
 1182               		
 1183               	 ;  0 "" 2
 1184               	/* #NOAPP */
 1185               	.L45:
 346:main.c        **** 		addr += SPM_PAGESIZE;
 1187               	.LM147:
 1188 0084 07B6      		in __tmp_reg__,0x37
 1189 0086 00FC      		sbrc __tmp_reg__,0
 1190 0088 00C0      		rjmp .L45
 1191 008a E05C      		subi r30,-64
 1192 008c FF4F      		sbci r31,-1
 343:main.c        **** 	{
 1194               	.LM148:
 1195 008e E115      		cp r30,__zero_reg__
 1196 0090 28E1      		ldi r18,24
 1197 0092 F207      		cpc r31,r18
 1198 0094 01F4      		brne .L46
 349:main.c        **** }
 1200               	.LM149:
 1201               	/* #APP */
 1202               	 ;  349 "main.c" 1
 1203 0096 C093 5700 		sts 87, r28
 1204 009a E895      		spm
 1205               		
 1206               	 ;  0 "" 2
 1207               	/* #NOAPP */
 1208 009c 00C0      		rjmp .L47
 1209               	.L44:
 1210               	.LBE83:
 1211               	.LBE84:
 424:main.c        **** 				{
 425:main.c        **** 					eraseFlash();
 426:main.c        **** 				}
 427:main.c        **** 
 428:main.c        **** 				if (rx_buf[1] == 'W')	
 1213               	.LM150:
 1214 009e 8735      		cpi r24,lo8(87)
 1215 00a0 01F4      		brne .L47
 429:main.c        **** 				{
 430:main.c        **** 					f_wait = 1;
 1217               	.LM151:
 1218 00a2 9093 0000 		sts f_wait,r25
 431:main.c        **** 					tx_buf[0] = 'W';
 1220               	.LM152:
 1221 00a6 8093 0000 		sts tx_buf,r24
 432:main.c        **** 					NRF24L01_Send(tx_buf);
 1223               	.LM153:
 1224 00aa 80E0      		ldi r24,lo8(tx_buf)
 1225 00ac 90E0      		ldi r25,hi8(tx_buf)
 1226 00ae 00D0      		rcall NRF24L01_Send
 1227               	.L47:
 433:main.c        **** 				}
 434:main.c        **** 
 435:main.c        **** 				if (rx_buf[1] == 'F')		//
 1229               	.LM154:
 1230 00b0 8091 0000 		lds r24,rx_buf+1
 1231 00b4 8634      		cpi r24,lo8(70)
 1232 00b6 01F0      		breq .+2
 1233 00b8 00C0      		rjmp .L43
 1234               	.LBB85:
 436:main.c        **** 				{
 437:main.c        **** 					LED_ON();
 1236               	.LM155:
 1237 00ba 969A      		sbi 0x12,6
 438:main.c        **** 					pagebuf_t size;
 439:main.c        **** 					size = rx_buf[2];
 1239               	.LM156:
 1240 00bc F090 0000 		lds r15,rx_buf+2
 440:main.c        **** 					address = rx_buf[3]; //
 1242               	.LM157:
 1243 00c0 8091 0000 		lds r24,rx_buf+3
 1244 00c4 282F      		mov r18,r24
 1245 00c6 30E0      		ldi r19,0
 1246 00c8 3093 0000 		sts address+1,r19
 1247 00cc 2093 0000 		sts address,r18
 1248 00d0 A0E0      		ldi r26,lo8(rx_buf+4)
 1249 00d2 B0E0      		ldi r27,hi8(rx_buf+4)
 1250               	.LBB79:
 441:main.c        **** 
 442:main.c        **** 					for (uint8_t i = 0; i < size; i++)
 1252               	.LM158:
 1253 00d4 E0E0      		ldi r30,lo8(gBuffer)
 1254 00d6 F0E0      		ldi r31,hi8(gBuffer)
 1255 00d8 90E0      		ldi r25,0
 1256               	.L49:
 1258               	.LM159:
 1259 00da 9F15      		cp r25,r15
 1260 00dc 01F0      		breq .L59
 443:main.c        **** 					{
 444:main.c        **** 						gBuffer[i] = rx_buf[i+4];
 1262               	.LM160:
 1263 00de 2D91      		ld r18,X+
 1264 00e0 2193      		st Z+,r18
 442:main.c        **** 					{
 1266               	.LM161:
 1267 00e2 9F5F      		subi r25,lo8(-(1))
 1268 00e4 00C0      		rjmp .L49
 1269               	.L59:
 1270               	.LBE79:
 1271               	.LBB80:
 1272               	.LBB78:
 354:main.c        **** 	uint32_t baddr = pagestart;
 1274               	.LM162:
 1275 00e6 90E0      		ldi r25,0
 1276 00e8 A0E0      		ldi r26,0
 1277 00ea B0E0      		ldi r27,0
 1278 00ec 880F      		lsl r24
 1279 00ee 991F      		rol r25
 1280 00f0 AA1F      		rol r26
 1281 00f2 BB1F      		rol r27
 357:main.c        **** 
 1283               	.LM163:
 1284 00f4 2091 0000 		lds r18,gBuffer
 1285 00f8 40E0      		ldi r20,lo8(gBuffer)
 1286 00fa 50E0      		ldi r21,hi8(gBuffer)
 1287 00fc BC01      		movw r22,r24
 363:main.c        **** 
 1289               	.LM164:
 1290 00fe 8050      		subi r24,lo8(gBuffer)
 1291 0100 9040      		sbci r25,hi8(gBuffer)
 1292               	.L52:
 1293 0102 FC01      		movw r30,r24
 1294 0104 E40F      		add r30,r20
 1295 0106 F51F      		adc r31,r21
 1296 0108 DA01      		movw r26,r20
 1297 010a 1196      		adiw r26,1
 1298 010c EC90      		ld r14,X
 1299 010e 30E0      		ldi r19,0
 1300 0110 3E29      		or r19,r14
 1301               	/* #APP */
 1302               	 ;  363 "main.c" 1
 1303 0112 0901      		movw  r0, r18
 1304 0114 D093 5700 		sts 87, r29
 1305 0118 E895      		spm
 1306 011a 1124      		clr  r1
 1307               		
 1308               	 ;  0 "" 2
 366:main.c        **** 		} 
 1310               	.LM165:
 1311               	/* #NOAPP */
 1312 011c FA94      		dec r15
 1313 011e FA94      		dec r15
 1314 0120 4E5F      		subi r20,-2
 1315 0122 5F4F      		sbci r21,-1
 368:main.c        **** 
 1317               	.LM166:
 1318 0124 FF20      		tst r15
 1319 0126 01F0      		breq .L51
 362:main.c        **** 		boot_page_fill(baddr, data);	// call asm routine.
 1321               	.LM167:
 1322 0128 FA01      		movw r30,r20
 1323 012a 2081      		ld r18,Z
 1324 012c 00C0      		rjmp .L52
 1325               	.L51:
 370:main.c        **** 	boot_spm_busy_wait();
 1327               	.LM168:
 1328 012e FB01      		movw r30,r22
 1329               	/* #APP */
 1330               	 ;  370 "main.c" 1
 1331 0130 1093 5700 		sts 87, r17
 1332 0134 E895      		spm
 1333               		
 1334               	 ;  0 "" 2
 1335               	/* #NOAPP */
 1336               	.L53:
 371:main.c        **** 	boot_rww_enable();		// Re-enable the RWW section
 1338               	.LM169:
 1339 0136 07B6      		in __tmp_reg__,0x37
 1340 0138 00FC      		sbrc __tmp_reg__,0
 1341 013a 00C0      		rjmp .L53
 372:main.c        **** 
 1343               	.LM170:
 1344               	/* #APP */
 1345               	 ;  372 "main.c" 1
 1346 013c C093 5700 		sts 87, r28
 1347 0140 E895      		spm
 1348               		
 1349               	 ;  0 "" 2
 1350               	/* #NOAPP */
 1351               	.L43:
 1352               	.LBE78:
 1353               	.LBE80:
 1354               	.LBE85:
 445:main.c        **** 					}
 446:main.c        **** 					
 447:main.c        **** 					writeFlashPage(address, size);
 448:main.c        **** 				}
 449:main.c        **** 
 450:main.c        **** 			}
 451:main.c        **** 
 452:main.c        **** 			f_rx = 0;						//опускаем флаг приема
 1356               	.LM171:
 1357 0142 1092 0000 		sts f_rx,__zero_reg__
 1358 0146 00C0      		rjmp .L41
 1375               	.Lscope18:
 1376               		.comm	gBuffer,64,1
 1377               	.global	f_wait
 1378               		.section .bss
 1381               	f_wait:
 1382 0000 00        		.zero	1
 1383               		.comm	val,1,1
 1384               	.global	device
 1387               	device:
 1388 0001 00        		.zero	1
 1389               	.global	address
 1392               	address:
 1393 0002 0000      		.zero	2
 1394               		.comm	buf,20,1
 1395               		.comm	f_send,1,1
 1396               	.global	f_tx
 1399               	f_tx:
 1400 0004 00        		.zero	1
 1401               	.global	f_rx
 1404               	f_rx:
 1405 0005 00        		.zero	1
 1406               	.global	tx_buf
 1409               	tx_buf:
 1410 0006 0000 0000 		.zero	32
 1410      0000 0000 
 1410      0000 0000 
 1410      0000 0000 
 1410      0000 0000 
 1411               	.global	rx_buf
 1414               	rx_buf:
 1415 0026 0000 0000 		.zero	32
 1415      0000 0000 
 1415      0000 0000 
 1415      0000 0000 
 1415      0000 0000 
 1416               	.global	TX_ADDRESS1
 1417               		.data
 1420               	TX_ADDRESS1:
 1421 0000 B7        		.byte	-73
 1422 0001 B5        		.byte	-75
 1423 0002 A1        		.byte	-95
 1424               	.global	TX_ADDRESS0
 1427               	TX_ADDRESS0:
 1428 0003 B5        		.byte	-75
 1429 0004 B5        		.byte	-75
 1430 0005 A1        		.byte	-95
 1444               		.text
 1446               	.Letext0:
 1447               		.ident	"GCC: (AVR_8_bit_GNU_Toolchain_3.6.2_1778) 5.4.0"
 1448               	.global __do_copy_data
 1449               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
C:\Users\vmelehin\AppData\Local\Temp\ccp43vnD.s:2      *ABS*:0000003e __SP_H__
C:\Users\vmelehin\AppData\Local\Temp\ccp43vnD.s:3      *ABS*:0000003d __SP_L__
C:\Users\vmelehin\AppData\Local\Temp\ccp43vnD.s:4      *ABS*:0000003f __SREG__
C:\Users\vmelehin\AppData\Local\Temp\ccp43vnD.s:5      *ABS*:00000000 __tmp_reg__
C:\Users\vmelehin\AppData\Local\Temp\ccp43vnD.s:6      *ABS*:00000001 __zero_reg__
C:\Users\vmelehin\AppData\Local\Temp\ccp43vnD.s:136    .text:00000000 port_init
C:\Users\vmelehin\AppData\Local\Temp\ccp43vnD.s:172    .text:00000016 spi_init
C:\Users\vmelehin\AppData\Local\Temp\ccp43vnD.s:201    .text:00000028 spi_sendByte
C:\Users\vmelehin\AppData\Local\Temp\ccp43vnD.s:227    .text:00000030 spi_changeByte
C:\Users\vmelehin\AppData\Local\Temp\ccp43vnD.s:255    .text:0000003a NRF24_ReadReg
C:\Users\vmelehin\AppData\Local\Temp\ccp43vnD.s:298    .text:00000050 NRF24_WriteReg
C:\Users\vmelehin\AppData\Local\Temp\ccp43vnD.s:332    .text:00000064 NRF24_ToggleFeatures
C:\Users\vmelehin\AppData\Local\Temp\ccp43vnD.s:376    .text:0000007a NRF24_Read_Buf
C:\Users\vmelehin\AppData\Local\Temp\ccp43vnD.s:441    .text:000000bc NRF24_Write_Buf
C:\Users\vmelehin\AppData\Local\Temp\ccp43vnD.s:515    .text:00000100 NRF24_FlushRX
C:\Users\vmelehin\AppData\Local\Temp\ccp43vnD.s:553    .text:00000112 NRF24_FlushTX
C:\Users\vmelehin\AppData\Local\Temp\ccp43vnD.s:591    .text:00000124 NRF24L01_RX_Mode
C:\Users\vmelehin\AppData\Local\Temp\ccp43vnD.s:1420   .data:00000000 TX_ADDRESS1
C:\Users\vmelehin\AppData\Local\Temp\ccp43vnD.s:654    .text:00000156 NRF24L01_TX_Mode
C:\Users\vmelehin\AppData\Local\Temp\ccp43vnD.s:1427   .data:00000003 TX_ADDRESS0
C:\Users\vmelehin\AppData\Local\Temp\ccp43vnD.s:692    .text:00000170 NRF24_Transmit
C:\Users\vmelehin\AppData\Local\Temp\ccp43vnD.s:772    .text:000001b6 NRF24L01_Send
C:\Users\vmelehin\AppData\Local\Temp\ccp43vnD.s:853    .text:000001f4 nrf24_init
C:\Users\vmelehin\AppData\Local\Temp\ccp43vnD.s:980    .text:0000026c nrf24_receive
C:\Users\vmelehin\AppData\Local\Temp\ccp43vnD.s:1414   .bss:00000026 rx_buf
C:\Users\vmelehin\AppData\Local\Temp\ccp43vnD.s:1404   .bss:00000005 f_rx
C:\Users\vmelehin\AppData\Local\Temp\ccp43vnD.s:1024   .text.startup:00000000 main
C:\Users\vmelehin\AppData\Local\Temp\ccp43vnD.s:1381   .bss:00000000 f_wait
C:\Users\vmelehin\AppData\Local\Temp\ccp43vnD.s:1409   .bss:00000006 tx_buf
C:\Users\vmelehin\AppData\Local\Temp\ccp43vnD.s:1392   .bss:00000002 address
                            *COM*:00000040 gBuffer
                            *COM*:00000001 val
C:\Users\vmelehin\AppData\Local\Temp\ccp43vnD.s:1387   .bss:00000001 device
                            *COM*:00000014 buf
                            *COM*:00000001 f_send
C:\Users\vmelehin\AppData\Local\Temp\ccp43vnD.s:1399   .bss:00000004 f_tx

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
