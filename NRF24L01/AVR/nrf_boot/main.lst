   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
 134               	.global	port_init
 136               	port_init:
   1:main.c        **** 
   2:main.c        **** #define F_CPU 8000000UL
   3:main.c        **** 
   4:main.c        **** #include <avr/io.h>
   5:main.c        **** #include <avr/interrupt.h>
   6:main.c        **** #include <util/delay.h>
   7:main.c        **** #include <avr/wdt.h>
   8:main.c        **** #include <stdio.h>
   9:main.c        **** #include <stdlib.h>
  10:main.c        **** #include <string.h>
  11:main.c        **** #include <stdint.h>
  12:main.c        **** #include <avr/boot.h>
  13:main.c        **** #include <avr/pgmspace.h>
  14:main.c        **** #include <avr/eeprom.h>
  15:main.c        **** #include "chipdef.h"
  16:main.c        **** 
  17:main.c        **** #define DISABLE_WDT_AT_STARTUP
  18:main.c        **** #define BUT_ADDR 		0x07				//адрес кнопки
  19:main.c        **** #define RESET 			0xFF				//команда сброса
  20:main.c        **** #define NOT_PUSHED 		0xFFFFFFFF			//сообщение "кнопка не нажата"
  21:main.c        **** 
  22:main.c        **** #define LED_Pin PORTD6			//пин светодиода
  23:main.c        **** #define LED_GPIO_Port PORTD		//порт светодиода
  24:main.c        **** #define IRQ_Pin PORTD2			//пин прерывания радиомодуля
  25:main.c        **** #define IRQ_GPIO_Port PORTD2	//порт прерывания радиомодуля
  26:main.c        **** #define CE_Pin PORTB0			//пин CE
  27:main.c        **** #define CE_GPIO_Port PORTB		//порт CE
  28:main.c        **** #define CSN_Pin PORTD7			//пин CSN
  29:main.c        **** #define CSN_GPIO_Port PORTD		//порт CSN
  30:main.c        **** 
  31:main.c        **** #define EXIT_WDT_TIME   WDTO_250MS
  32:main.c        **** 
  33:main.c        **** #define WAIT_VALUE 1000 //в мс
  34:main.c        **** 
  35:main.c        **** //------------------------------------------------
  36:main.c        **** #define CS_ON()			CSN_GPIO_Port&=~(1<<CSN_Pin)
  37:main.c        **** #define CS_OFF()		CSN_GPIO_Port|=(1<<CSN_Pin)
  38:main.c        **** #define CE_RESET()		CE_GPIO_Port&=~(1<<CE_Pin)
  39:main.c        **** #define CE_SET()		CE_GPIO_Port|=(1<<CE_Pin)
  40:main.c        **** 
  41:main.c        **** #define LED_ON()		LED_GPIO_Port|=(1<<LED_Pin)
  42:main.c        **** #define LED_OFF()		LED_GPIO_Port&=~(1<<LED_Pin)
  43:main.c        **** #define LED_TGL()		LED_GPIO_Port^=(1<<LED_Pin)
  44:main.c        **** //------------------------------------------------
  45:main.c        **** #define ACTIVATE 		0x50 //
  46:main.c        **** #define RD_RX_PLOAD		0x61 // Define RX payload register address
  47:main.c        **** #define WR_TX_PLOAD		0xA0 // Define TX payload register address
  48:main.c        **** #define FLUSH_TX 		0xE1
  49:main.c        **** #define FLUSH_RX 		0xE2
  50:main.c        **** //------------------------------------------------
  51:main.c        **** #define CONFIG 			0x00 //'Config' register address
  52:main.c        **** #define EN_AA 			0x01 //'Enable Auto Acknowledgment' register address
  53:main.c        **** #define EN_RXADDR 		0x02 //'Enabled RX addresses' register address
  54:main.c        **** #define SETUP_AW 		0x03 //'Setup address width' register address
  55:main.c        **** #define SETUP_RETR 		0x04 //'Setup Auto. Retrans' register address
  56:main.c        **** #define RF_CH 			0x05 //'RF channel' register address
  57:main.c        **** #define RF_SETUP 		0x06 //'RF setup' register address
  58:main.c        **** #define STATUS 			0x07 //'Status' register address
  59:main.c        **** #define OBSERVE_TX 		0x08 //'Transmit observe' register
  60:main.c        **** #define RX_ADDR_P0 		0x0A //'RX address pipe0' register address
  61:main.c        **** #define RX_ADDR_P1 		0x0B //'RX address pipe1' register address
  62:main.c        **** #define TX_ADDR 		0x10 //'TX address' register address
  63:main.c        **** #define RX_PW_P0 		0x11 //'RX payload width, pipe0' register address
  64:main.c        **** #define RX_PW_P1 		0x12 //'RX payload width, pipe1' register address
  65:main.c        **** #define FIFO_STATUS		0x17 //'FIFO Status Register' register address
  66:main.c        **** #define DYNPD 			0x1C
  67:main.c        **** #define FEATURE 		0x1D
  68:main.c        **** //------------------------------------------------
  69:main.c        **** #define PRIM_RX 		0x00 //RX/TX control (1: PRX, 0: PTX)
  70:main.c        **** #define PWR_UP 			0x01 //1: POWER UP, 0:POWER DOWN
  71:main.c        **** #define RX_DR 			0x40 //Data Ready RX FIFO interrupt
  72:main.c        **** #define TX_DS 			0x20 //Data Sent TX FIFO interrupt
  73:main.c        **** #define MAX_RT 			0x10 //Maximum number of TX retransmits interrupt
  74:main.c        **** //------------------------------------------------
  75:main.c        **** #define W_REGISTER 		0x20 //запись в регистр
  76:main.c        **** //------------------------------------------------
  77:main.c        **** #define TX_ADR_WIDTH 3						//размер адреса передачи
  78:main.c        **** #define TX_PLOAD_WIDTH 32					//размер полезной нагрузки
  79:main.c        **** //максимальное число байт, чтобы при добавлении новых функций не переделывать задержки
  80:main.c        **** 
  81:main.c        **** uint8_t TX_ADDRESS0[TX_ADR_WIDTH] = {0xb5,0xb5,0xa1};	//адрес 0
  82:main.c        **** uint8_t TX_ADDRESS1[TX_ADR_WIDTH] = {0xb7,0xb5,0xa1};	//адрес 1
  83:main.c        **** 
  84:main.c        **** uint8_t rx_buf[TX_PLOAD_WIDTH] = {0};				//буфер приема
  85:main.c        **** uint8_t tx_buf[TX_PLOAD_WIDTH] = {0};				//буфер передачи
  86:main.c        **** 
  87:main.c        **** volatile uint8_t f_rx = 0, f_tx = 0;				//флаги приема и передачи
  88:main.c        **** 
  89:main.c        **** uint8_t f_send;								//флаг отправки
  90:main.c        **** 
  91:main.c        **** uint8_t buf[20];							//буфер
  92:main.c        **** uint16_t address;
  93:main.c        **** uint8_t device, val;
  94:main.c        **** uint8_t f_wait = 0;
  95:main.c        **** 
  96:main.c        **** void nrf24_init(void);
  97:main.c        **** uint8_t NRF24_ReadReg(uint8_t addr);
  98:main.c        **** void NRF24_Read_Buf(uint8_t addr,uint8_t *pBuf,uint8_t bytes);
  99:main.c        **** uint8_t NRF24L01_Send(uint8_t *pBuf);
 100:main.c        **** void nrf24l01_receive(void);
 101:main.c        **** 
 102:main.c        **** uint8_t gBuffer[SPM_PAGESIZE];
 103:main.c        **** uint16_t address = 0;
 104:main.c        **** uint8_t device = 0, val;
 105:main.c        **** 
 106:main.c        **** void port_init(void)//Инициализация портов
 107:main.c        **** {
 138               	.LM0:
 139               	.LFBB1:
 140               	/* prologue: function */
 141               	/* frame size = 0 */
 142               	/* stack size = 0 */
 143               	.L__stack_usage = 0
 108:main.c        **** 	// Input/Output Ports initialization
 109:main.c        **** 	// Port B initialization
 110:main.c        **** 	// Function: Bit7=In Bit6=In Bit5=Out Bit4=In Bit3=Out Bit2=Out Bit1=In Bit0=Out
 111:main.c        **** 	DDRB=(0<<DDB7) | (0<<DDB6) | (1<<DDB5) | (0<<DDB4) | (1<<DDB3) | (1<<DDB2) | (0<<DDB1) | (1<<DDB0)
 145               	.LM1:
 146 0000 8DE2      		ldi r24,lo8(45)
 147 0002 87BB      		out 0x17,r24
 112:main.c        **** 	// State: Bit7=T Bit6=T Bit5=0 Bit4=T Bit3=0 Bit2=0 Bit1=T Bit0=0
 113:main.c        **** 	PORTB=(0<<PORTB7) | (0<<PORTB6) | (0<<PORTB5) | (0<<PORTB4) | (0<<PORTB3) | (0<<PORTB2) | (0<<PORT
 149               	.LM2:
 150 0004 81E0      		ldi r24,lo8(1)
 151 0006 88BB      		out 0x18,r24
 114:main.c        **** 
 115:main.c        **** 	// Port C initialization
 116:main.c        **** 	// Function: Bit6=In Bit5=In Bit4=In Bit3=In Bit2=In Bit1=In Bit0=In
 117:main.c        **** 	DDRC=(0<<DDC6) | (0<<DDC5) | (0<<DDC4) | (0<<DDC3) | (0<<DDC2) | (0<<DDC1) | (0<<DDC0);
 153               	.LM3:
 154 0008 14BA      		out 0x14,__zero_reg__
 118:main.c        **** 	// State: Bit6=T Bit5=T Bit4=T Bit3=T Bit2=T Bit1=T Bit0=T
 119:main.c        **** 	PORTC=(0<<PORTC6) | (0<<PORTC5) | (0<<PORTC4) | (0<<PORTC3) | (0<<PORTC2) | (0<<PORTC1) | (0<<PORT
 156               	.LM4:
 157 000a 15BA      		out 0x15,__zero_reg__
 120:main.c        **** 
 121:main.c        **** 	// Port D initialization
 122:main.c        **** 	// Function: Bit7=Out Bit6=Out Bit5=In Bit4=In Bit3=In Bit2=In Bit1=In Bit0=In
 123:main.c        **** 	DDRD=(1<<DDD7) | (1<<DDD6) | (0<<DDD5) | (0<<DDD4) | (0<<DDD3) | (0<<DDD2) | (0<<DDD1) | (0<<DDD0)
 159               	.LM5:
 160 000c 80EC      		ldi r24,lo8(-64)
 161 000e 81BB      		out 0x11,r24
 124:main.c        **** 	// State: Bit7=0 Bit6=0 Bit5=T Bit4=T Bit3=P Bit2=T Bit1=T Bit0=T
 125:main.c        **** 	PORTD=(1<<PORTD7) | (0<<PORTD6) | (0<<PORTD5) | (0<<PORTD4) | (1<<PORTD3) | (0<<PORTD2) | (0<<PORT
 163               	.LM6:
 164 0010 88E8      		ldi r24,lo8(-120)
 165 0012 82BB      		out 0x12,r24
 166 0014 0895      		ret
 168               	.Lscope1:
 170               	.global	spi_init
 172               	spi_init:
 126:main.c        **** }
 127:main.c        **** 
 128:main.c        **** //инициализация SPI
 129:main.c        **** void spi_init(void)
 130:main.c        **** {
 174               	.LM7:
 175               	.LFBB2:
 176               	/* prologue: function */
 177               	/* frame size = 0 */
 178               	/* stack size = 0 */
 179               	.L__stack_usage = 0
 131:main.c        **** 	DDRB |= ((1<<PORTB2)|(1<<PORTB3)|(1<<PORTB5)); //ножки SPI на выход
 181               	.LM8:
 182 0016 87B3      		in r24,0x17
 183 0018 8C62      		ori r24,lo8(44)
 184 001a 87BB      		out 0x17,r24
 132:main.c        **** 	PORTB &= ~((1<<PORTB2)|(1<<PORTB3)|(1<<PORTB5)); //низкий уровень
 186               	.LM9:
 187 001c 88B3      		in r24,0x18
 188 001e 837D      		andi r24,lo8(-45)
 189 0020 88BB      		out 0x18,r24
 133:main.c        **** 	SPCR=(0<<SPIE) | (1<<SPE) | (0<<DORD) | (1<<MSTR) | (0<<CPOL) | (0<<CPHA) | (0<<SPR1) | (0<<SPR0);
 191               	.LM10:
 192 0022 80E5      		ldi r24,lo8(80)
 193 0024 8DB9      		out 0xd,r24
 194 0026 0895      		ret
 196               	.Lscope2:
 199               	.global	spi_sendByte
 201               	spi_sendByte:
 134:main.c        **** }
 135:main.c        **** 
 136:main.c        **** //отправка байта
 137:main.c        **** void spi_sendByte(uint8_t byte)
 138:main.c        **** {
 203               	.LM11:
 204               	.LFBB3:
 205               	/* prologue: function */
 206               	/* frame size = 0 */
 207               	/* stack size = 0 */
 208               	.L__stack_usage = 0
 139:main.c        **** 	SPDR = byte;				//записываем байт в регистр
 210               	.LM12:
 211 0028 8FB9      		out 0xf,r24
 212               	.L4:
 140:main.c        **** 	while(!(SPSR & (1<<SPIF)));	//подождем пока данные передадутся
 214               	.LM13:
 215 002a 779B      		sbis 0xe,7
 216 002c 00C0      		rjmp .L4
 217               	/* epilogue start */
 141:main.c        **** }
 219               	.LM14:
 220 002e 0895      		ret
 222               	.Lscope3:
 225               	.global	spi_changeByte
 227               	spi_changeByte:
 142:main.c        **** 
 143:main.c        **** //прием/отправка байта
 144:main.c        **** uint8_t spi_changeByte(uint8_t byte)
 145:main.c        **** {
 229               	.LM15:
 230               	.LFBB4:
 231               	/* prologue: function */
 232               	/* frame size = 0 */
 233               	/* stack size = 0 */
 234               	.L__stack_usage = 0
 146:main.c        **** 	SPDR = byte;				//записываем байт в регистр
 236               	.LM16:
 237 0030 8FB9      		out 0xf,r24
 238               	.L8:
 147:main.c        **** 	while(!(SPSR & (1<<SPIF)));	//подождем пока данные передадутся (обменяются)
 240               	.LM17:
 241 0032 779B      		sbis 0xe,7
 242 0034 00C0      		rjmp .L8
 148:main.c        **** 	return SPDR;				//возвращаем принятое значение
 244               	.LM18:
 245 0036 8FB1      		in r24,0xf
 149:main.c        **** }
 247               	.LM19:
 248 0038 0895      		ret
 250               	.Lscope4:
 253               	.global	NRF24_ReadReg
 255               	NRF24_ReadReg:
 150:main.c        **** 
 151:main.c        **** //функция чтения регистра модуля
 152:main.c        **** uint8_t NRF24_ReadReg(uint8_t addr)
 153:main.c        **** {
 257               	.LM20:
 258               	.LFBB5:
 259 003a CF93      		push r28
 260               	/* prologue: function */
 261               	/* frame size = 0 */
 262               	/* stack size = 1 */
 263               	.L__stack_usage = 1
 264 003c C82F      		mov r28,r24
 154:main.c        **** 	uint8_t dt=0, cmd;								//переменные данных и команды
 155:main.c        **** 	CS_ON();											//ногу cs к земле
 266               	.LM21:
 267 003e 9798      		cbi 0x12,7
 156:main.c        **** 	dt = spi_changeByte(addr);						//Прием/отправкадайта адреса регистра
 269               	.LM22:
 270 0040 00D0      		rcall spi_changeByte
 157:main.c        **** 	//если адрес равен адрес регистра статус то и возварщаем его состояние
 158:main.c        **** 	if (addr!=STATUS)//а если не равен
 272               	.LM23:
 273 0042 C730      		cpi r28,lo8(7)
 274 0044 01F0      		breq .L11
 159:main.c        **** 	{
 160:main.c        **** 		cmd=0xFF;									//команда NOP для получения данных
 161:main.c        **** 		dt = spi_changeByte(cmd);					//
 276               	.LM24:
 277 0046 8FEF      		ldi r24,lo8(-1)
 278 0048 00D0      		rcall spi_changeByte
 279               	.L11:
 162:main.c        **** 	}
 163:main.c        **** 	CS_OFF();											//поднимаем ногу CS
 281               	.LM25:
 282 004a 979A      		sbi 0x12,7
 283               	/* epilogue start */
 164:main.c        **** 	return dt;	//возвращаемое значение
 165:main.c        **** }
 285               	.LM26:
 286 004c CF91      		pop r28
 287 004e 0895      		ret
 292               	.Lscope5:
 296               	.global	NRF24_WriteReg
 298               	NRF24_WriteReg:
 166:main.c        **** //------------------------------------------------
 167:main.c        **** //функция записи регистра в модуль
 168:main.c        **** void NRF24_WriteReg(uint8_t addr, uint8_t dt)
 169:main.c        **** {
 300               	.LM27:
 301               	.LFBB6:
 302 0050 CF93      		push r28
 303               	/* prologue: function */
 304               	/* frame size = 0 */
 305               	/* stack size = 1 */
 306               	.L__stack_usage = 1
 307 0052 C62F      		mov r28,r22
 170:main.c        **** 	addr |= W_REGISTER;//включим бит записи в адрес
 171:main.c        **** 	CS_ON();
 309               	.LM28:
 310 0054 9798      		cbi 0x12,7
 172:main.c        **** 	spi_sendByte(addr);									//
 312               	.LM29:
 313 0056 8062      		ori r24,lo8(32)
 314 0058 00D0      		rcall spi_sendByte
 173:main.c        **** 	spi_sendByte(dt);										//
 316               	.LM30:
 317 005a 8C2F      		mov r24,r28
 318 005c 00D0      		rcall spi_sendByte
 174:main.c        **** 	CS_OFF();
 320               	.LM31:
 321 005e 979A      		sbi 0x12,7
 322               	/* epilogue start */
 175:main.c        **** }
 324               	.LM32:
 325 0060 CF91      		pop r28
 326 0062 0895      		ret
 328               	.Lscope6:
 330               	.global	NRF24_ToggleFeatures
 332               	NRF24_ToggleFeatures:
 176:main.c        **** 
 177:main.c        **** //------------------------------------------------
 178:main.c        **** void NRF24_ToggleFeatures(void)							//активация команд R_RX_PL_WID, W_ACK_PAYLOAD и W_TX_PAYLOAD_
 179:main.c        **** {	//есть в даташите "без плюса"
 334               	.LM33:
 335               	.LFBB7:
 336               	/* prologue: function */
 337               	/* frame size = 0 */
 338               	/* stack size = 0 */
 339               	.L__stack_usage = 0
 180:main.c        **** 	uint8_t dt[1] = {ACTIVATE};
 181:main.c        **** 	CS_ON();
 341               	.LM34:
 342 0064 9798      		cbi 0x12,7
 182:main.c        **** 	spi_sendByte(dt[0]);
 344               	.LM35:
 345 0066 80E5      		ldi r24,lo8(80)
 346 0068 00D0      		rcall spi_sendByte
 347               	.LBB34:
 348               	.LBB35:
 350               	.Ltext1:
   1:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    All rights reserved.
   5:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
   6:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
   9:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  12:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      distribution.
  16:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  17:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  21:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  33:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /* $Id$ */
  34:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  35:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  38:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #  endif
  42:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  44:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <inttypes.h>
  45:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <math.h>
  47:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  48:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \file */
  49:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \code
  51:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     #include <util/delay.h>
  54:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \endcode
  55:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  56:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     used.
  60:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  61:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  70:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     routines linked into the application.
  78:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  79:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  83:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** */
  84:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  85:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
  89:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  90:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef F_CPU
  91:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \ingroup util_delay
  94:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \def F_CPU
  95:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  97:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 103:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     integer value.
 107:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****  */
 108:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 110:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 111:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 114:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 115:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #  include <math.h>
 119:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 120:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 121:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /**
 122:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \ingroup util_delay
 123:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 124:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 126:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 129:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 131:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 137:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 142:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    microseconds of delay.
 146:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 147:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    respectively.
 151:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 152:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \note
 153:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 154:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    not available to the compiler then.
 163:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 164:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****  */
 165:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** void
 166:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** _delay_ms(double __ms)
 167:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** {
 168:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	double __tmp ;
 169:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 173:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 176:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 179:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 182:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#else
 183:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		//round up by default
 184:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#endif
 186:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 187:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 189:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #else
 190:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	uint16_t __ticks;
 191:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	if (__tmp < 1.0)
 193:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks = 1;
 194:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	else if (__tmp > 65535)
 195:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	{
 196:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		while(__ticks)
 199:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		{
 200:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 			// wait 1/10 ms
 201:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 			__ticks --;
 203:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		}
 204:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		return;
 205:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	}
 206:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	else
 207:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks = (uint16_t)__tmp;
 208:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	_delay_loop_2(__ticks);
 209:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 210:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** }
 211:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 212:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /**
 213:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \ingroup util_delay
 214:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 215:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 217:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 218:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 220:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 222:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    will not be informed about this case.
 225:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 226:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflow results in
 229:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    no delay i.e., 0us.
 230:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 231:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __us
 234:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    microseconds of delay.
 235:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 236:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    respectively.
 240:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 241:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \note
 242:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 243:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 244:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 246:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 248:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 249:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    not available to the compiler then.
 252:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 253:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****  */
 254:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** void
 255:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** _delay_us(double __us)
 256:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** {
 257:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	double __tmp ;
 258:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   __STDC_HOSTED__
 261:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 262:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 265:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 268:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 271:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#else
 272:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		//round up by default
 273:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#endif
 275:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 276:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 352               	.LM36:
 353 006a 82E0      		ldi r24,lo8(2)
 354 006c 8A95      	1:	dec r24
 355 006e 01F4      		brne 1b
 356 0070 00C0      		rjmp .
 357               	.LBE35:
 358               	.LBE34:
 360               	.Ltext2:
 183:main.c        **** 	_delay_us(1);
 184:main.c        **** 	dt[0] = 0x73;
 185:main.c        **** 	spi_sendByte(dt[0]);
 362               	.LM37:
 363 0072 83E7      		ldi r24,lo8(115)
 364 0074 00D0      		rcall spi_sendByte
 186:main.c        **** 	CS_OFF();
 366               	.LM38:
 367 0076 979A      		sbi 0x12,7
 368 0078 0895      		ret
 370               	.Lscope7:
 374               	.global	NRF24_Read_Buf
 376               	NRF24_Read_Buf:
 187:main.c        **** }
 188:main.c        **** 
 189:main.c        **** //-----------------------------------------------
 190:main.c        **** void NRF24_Read_Buf(uint8_t addr,uint8_t *pBuf,uint8_t bytes)
 191:main.c        **** {//чтение буфера (несколько байт)
 378               	.LM39:
 379               	.LFBB8:
 380 007a EF92      		push r14
 381 007c FF92      		push r15
 382 007e 0F93      		push r16
 383 0080 1F93      		push r17
 384 0082 CF93      		push r28
 385 0084 DF93      		push r29
 386               	/* prologue: function */
 387               	/* frame size = 0 */
 388               	/* stack size = 6 */
 389               	.L__stack_usage = 6
 390 0086 182F      		mov r17,r24
 391 0088 062F      		mov r16,r22
 392 008a E72E      		mov r14,r23
 393 008c F42E      		mov r15,r20
 192:main.c        **** 	CS_ON();
 395               	.LM40:
 396 008e 9798      		cbi 0x12,7
 193:main.c        **** 	spi_sendByte(addr);
 398               	.LM41:
 399 0090 00D0      		rcall spi_sendByte
 400 0092 C02F      		mov r28,r16
 401 0094 DE2D      		mov r29,r14
 402 0096 CE01      		movw r24,r28
 403 0098 8F0D      		add r24,r15
 404 009a 911D      		adc r25,__zero_reg__
 405 009c 7C01      		movw r14,r24
 406               	.L18:
 407               	.LBB36:
 194:main.c        **** 	for (uint8_t i = 0 ; i < bytes ; i++) 		//для нужного количества байт
 409               	.LM42:
 410 009e CE15      		cp r28,r14
 411 00a0 DF05      		cpc r29,r15
 412 00a2 01F0      		breq .L20
 195:main.c        **** 	{																					//
 196:main.c        **** 		pBuf[i] = spi_changeByte(addr);
 414               	.LM43:
 415 00a4 812F      		mov r24,r17
 416 00a6 00D0      		rcall spi_changeByte
 417 00a8 8993      		st Y+,r24
 418 00aa 00C0      		rjmp .L18
 419               	.L20:
 420               	.LBE36:
 197:main.c        **** 	}
 198:main.c        **** 	CS_OFF();
 422               	.LM44:
 423 00ac 979A      		sbi 0x12,7
 424               	/* epilogue start */
 199:main.c        **** }
 426               	.LM45:
 427 00ae DF91      		pop r29
 428 00b0 CF91      		pop r28
 429 00b2 1F91      		pop r17
 430 00b4 0F91      		pop r16
 431 00b6 FF90      		pop r15
 432 00b8 EF90      		pop r14
 433 00ba 0895      		ret
 435               	.Lscope8:
 439               	.global	NRF24_Write_Buf
 441               	NRF24_Write_Buf:
 200:main.c        **** 
 201:main.c        **** //------------------------------------------------
 202:main.c        **** void NRF24_Write_Buf(uint8_t addr,uint8_t *pBuf,uint8_t bytes)
 203:main.c        **** {//запись буфера
 443               	.LM46:
 444               	.LFBB9:
 445 00bc FF92      		push r15
 446 00be 0F93      		push r16
 447 00c0 1F93      		push r17
 448 00c2 CF93      		push r28
 449 00c4 DF93      		push r29
 450               	/* prologue: function */
 451               	/* frame size = 0 */
 452               	/* stack size = 5 */
 453               	.L__stack_usage = 5
 454 00c6 F62E      		mov r15,r22
 455 00c8 072F      		mov r16,r23
 456 00ca 142F      		mov r17,r20
 204:main.c        **** 	addr |= W_REGISTER;//включим бит записи в адрес
 205:main.c        **** 	CS_ON();
 458               	.LM47:
 459 00cc 9798      		cbi 0x12,7
 206:main.c        **** 	spi_sendByte(addr);
 461               	.LM48:
 462 00ce 8062      		ori r24,lo8(32)
 463 00d0 00D0      		rcall spi_sendByte
 464               	.LBB37:
 465               	.LBB38:
 467               	.Ltext3:
 469               	.LM49:
 470 00d2 82E0      		ldi r24,lo8(2)
 471 00d4 8A95      	1:	dec r24
 472 00d6 01F4      		brne 1b
 473 00d8 00C0      		rjmp .
 474 00da CF2D      		mov r28,r15
 475 00dc D02F      		mov r29,r16
 476 00de CE01      		movw r24,r28
 477 00e0 810F      		add r24,r17
 478 00e2 911D      		adc r25,__zero_reg__
 479 00e4 8C01      		movw r16,r24
 480               	.L22:
 481               	.LBE38:
 482               	.LBE37:
 483               	.LBB39:
 485               	.Ltext4:
 207:main.c        **** 	_delay_us(1);
 208:main.c        **** 	for (uint8_t i = 0 ; i < bytes ; i++) 		//для нужного количества байт
 487               	.LM50:
 488 00e6 C017      		cp r28,r16
 489 00e8 D107      		cpc r29,r17
 490 00ea 01F0      		breq .L24
 209:main.c        **** 	{
 210:main.c        **** 		spi_sendByte(pBuf[i]);
 492               	.LM51:
 493 00ec 8991      		ld r24,Y+
 494 00ee 00D0      		rcall spi_sendByte
 495 00f0 00C0      		rjmp .L22
 496               	.L24:
 497               	.LBE39:
 211:main.c        **** 	}
 212:main.c        **** 	CS_OFF();
 499               	.LM52:
 500 00f2 979A      		sbi 0x12,7
 501               	/* epilogue start */
 213:main.c        **** }
 503               	.LM53:
 504 00f4 DF91      		pop r29
 505 00f6 CF91      		pop r28
 506 00f8 1F91      		pop r17
 507 00fa 0F91      		pop r16
 508 00fc FF90      		pop r15
 509 00fe 0895      		ret
 511               	.Lscope9:
 513               	.global	NRF24_FlushRX
 515               	NRF24_FlushRX:
 214:main.c        **** 
 215:main.c        **** //------------------------------------------------
 216:main.c        **** void NRF24_FlushRX(void)
 217:main.c        **** {//очистка буфера приема
 517               	.LM54:
 518               	.LFBB10:
 519               	/* prologue: function */
 520               	/* frame size = 0 */
 521               	/* stack size = 0 */
 522               	.L__stack_usage = 0
 218:main.c        **** 	uint8_t dt[1] = {FLUSH_RX};
 219:main.c        **** 	CS_ON();
 524               	.LM55:
 525 0100 9798      		cbi 0x12,7
 220:main.c        **** 	spi_sendByte(dt[0]);
 527               	.LM56:
 528 0102 82EE      		ldi r24,lo8(-30)
 529 0104 00D0      		rcall spi_sendByte
 530               	.LBB40:
 531               	.LBB41:
 533               	.Ltext5:
 535               	.LM57:
 536 0106 82E0      		ldi r24,lo8(2)
 537 0108 8A95      	1:	dec r24
 538 010a 01F4      		brne 1b
 539 010c 00C0      		rjmp .
 540               	.LBE41:
 541               	.LBE40:
 543               	.Ltext6:
 221:main.c        **** 	_delay_us(1); //пауза в микросекунду для завершения процесса
 222:main.c        **** 	CS_OFF();
 545               	.LM58:
 546 010e 979A      		sbi 0x12,7
 547 0110 0895      		ret
 549               	.Lscope10:
 551               	.global	NRF24_FlushTX
 553               	NRF24_FlushTX:
 223:main.c        **** }
 224:main.c        **** 
 225:main.c        **** //------------------------------------------------
 226:main.c        **** void NRF24_FlushTX(void)
 227:main.c        **** {//очистка буфера передачи
 555               	.LM59:
 556               	.LFBB11:
 557               	/* prologue: function */
 558               	/* frame size = 0 */
 559               	/* stack size = 0 */
 560               	.L__stack_usage = 0
 228:main.c        **** 	uint8_t dt[1] = {FLUSH_TX};
 229:main.c        **** 	CS_ON();
 562               	.LM60:
 563 0112 9798      		cbi 0x12,7
 230:main.c        **** 	spi_sendByte(dt[0]);
 565               	.LM61:
 566 0114 81EE      		ldi r24,lo8(-31)
 567 0116 00D0      		rcall spi_sendByte
 568               	.LBB42:
 569               	.LBB43:
 571               	.Ltext7:
 573               	.LM62:
 574 0118 82E0      		ldi r24,lo8(2)
 575 011a 8A95      	1:	dec r24
 576 011c 01F4      		brne 1b
 577 011e 00C0      		rjmp .
 578               	.LBE43:
 579               	.LBE42:
 581               	.Ltext8:
 231:main.c        **** 	_delay_us(1); //пауза в микросекунду для завершения процесса
 232:main.c        **** 	CS_OFF();
 583               	.LM63:
 584 0120 979A      		sbi 0x12,7
 585 0122 0895      		ret
 587               	.Lscope11:
 589               	.global	NRF24L01_RX_Mode
 591               	NRF24L01_RX_Mode:
 233:main.c        **** }
 234:main.c        **** 
 235:main.c        **** //------------------------------------------------
 236:main.c        **** void NRF24L01_RX_Mode(void)
 237:main.c        **** {//режим приемника
 593               	.LM64:
 594               	.LFBB12:
 595               	/* prologue: function */
 596               	/* frame size = 0 */
 597               	/* stack size = 0 */
 598               	.L__stack_usage = 0
 238:main.c        **** 	uint8_t regval=0x00;
 239:main.c        **** 	regval = NRF24_ReadReg(CONFIG);	//сохраняем значение регистра конфигурации
 600               	.LM65:
 601 0124 80E0      		ldi r24,0
 602 0126 00D0      		rcall NRF24_ReadReg
 240:main.c        **** 	//разбудим модуль и переведём его в режим приёмника, включив биты PWR_UP и PRIM_RX
 241:main.c        **** 	regval |= (1<<PWR_UP)|(1<<PRIM_RX);
 242:main.c        **** 	NRF24_WriteReg(CONFIG,regval);	//возвращаем значение регистра статуса
 604               	.LM66:
 605 0128 682F      		mov r22,r24
 606 012a 6360      		ori r22,lo8(3)
 607 012c 80E0      		ldi r24,0
 608 012e 00D0      		rcall NRF24_WriteReg
 243:main.c        **** 	
 244:main.c        **** 	NRF24_Write_Buf(TX_ADDR, TX_ADDRESS1, TX_ADR_WIDTH);		//записываем  адрес передатчика
 610               	.LM67:
 611 0130 43E0      		ldi r20,lo8(3)
 612 0132 60E0      		ldi r22,lo8(TX_ADDRESS1)
 613 0134 70E0      		ldi r23,hi8(TX_ADDRESS1)
 614 0136 80E1      		ldi r24,lo8(16)
 615 0138 00D0      		rcall NRF24_Write_Buf
 245:main.c        **** 	NRF24_Write_Buf(RX_ADDR_P0, TX_ADDRESS1, TX_ADR_WIDTH);	//записываем адрес приемника
 617               	.LM68:
 618 013a 43E0      		ldi r20,lo8(3)
 619 013c 60E0      		ldi r22,lo8(TX_ADDRESS1)
 620 013e 70E0      		ldi r23,hi8(TX_ADDRESS1)
 621 0140 8AE0      		ldi r24,lo8(10)
 622 0142 00D0      		rcall NRF24_Write_Buf
 246:main.c        **** 	
 247:main.c        **** 	CE_SET();
 624               	.LM69:
 625 0144 C09A      		sbi 0x18,0
 626               	.LBB44:
 627               	.LBB45:
 629               	.Ltext9:
 631               	.LM70:
 632 0146 8BE2      		ldi r24,lo8(299)
 633 0148 91E0      		ldi r25,hi8(299)
 634 014a 0197      	1:	sbiw r24,1
 635 014c 01F4      		brne 1b
 636 014e 00C0      		rjmp .
 637 0150 0000      		nop
 638               	.LBE45:
 639               	.LBE44:
 641               	.Ltext10:
 248:main.c        **** 	_delay_us(150); //Задержка минимум 130 мкс
 249:main.c        **** 	// Flush buffers
 250:main.c        **** 	NRF24_FlushRX();
 643               	.LM71:
 644 0152 00D0      		rcall NRF24_FlushRX
 251:main.c        **** 	NRF24_FlushTX();
 646               	.LM72:
 647 0154 00C0      		rjmp NRF24_FlushTX
 649               	.Lscope12:
 652               	.global	NRF24L01_TX_Mode
 654               	NRF24L01_TX_Mode:
 252:main.c        **** }
 253:main.c        **** 
 254:main.c        **** //------------------------------------------------
 255:main.c        **** void NRF24L01_TX_Mode(uint8_t *pBuf)
 256:main.c        **** {//режим передатчика
 656               	.LM73:
 657               	.LFBB13:
 658               	/* prologue: function */
 659               	/* frame size = 0 */
 660               	/* stack size = 0 */
 661               	.L__stack_usage = 0
 257:main.c        **** 	NRF24_Write_Buf(TX_ADDR, TX_ADDRESS0, TX_ADR_WIDTH);		//записываем адрес передатчика
 663               	.LM74:
 664 0156 43E0      		ldi r20,lo8(3)
 665 0158 60E0      		ldi r22,lo8(TX_ADDRESS0)
 666 015a 70E0      		ldi r23,hi8(TX_ADDRESS0)
 667 015c 80E1      		ldi r24,lo8(16)
 668 015e 00D0      		rcall NRF24_Write_Buf
 258:main.c        **** 	NRF24_Write_Buf(RX_ADDR_P0, TX_ADDRESS0, TX_ADR_WIDTH);	//записываем адрес приемника
 670               	.LM75:
 671 0160 43E0      		ldi r20,lo8(3)
 672 0162 60E0      		ldi r22,lo8(TX_ADDRESS0)
 673 0164 70E0      		ldi r23,hi8(TX_ADDRESS0)
 674 0166 8AE0      		ldi r24,lo8(10)
 675 0168 00D0      		rcall NRF24_Write_Buf
 259:main.c        **** 	CE_RESET();
 677               	.LM76:
 678 016a C098      		cbi 0x18,0
 260:main.c        **** 	// Flush buffers
 261:main.c        **** 	NRF24_FlushRX();
 680               	.LM77:
 681 016c 00D0      		rcall NRF24_FlushRX
 262:main.c        **** 	NRF24_FlushTX();
 683               	.LM78:
 684 016e 00C0      		rjmp NRF24_FlushTX
 686               	.Lscope13:
 690               	.global	NRF24_Transmit
 692               	NRF24_Transmit:
 263:main.c        **** }
 264:main.c        **** 
 265:main.c        **** //------------------------------------------------
 266:main.c        **** void NRF24_Transmit(uint8_t addr,uint8_t *pBuf,uint8_t bytes)
 267:main.c        **** {//передача данных в модуль
 694               	.LM79:
 695               	.LFBB14:
 696 0170 FF92      		push r15
 697 0172 0F93      		push r16
 698 0174 1F93      		push r17
 699 0176 CF93      		push r28
 700 0178 DF93      		push r29
 701               	/* prologue: function */
 702               	/* frame size = 0 */
 703               	/* stack size = 5 */
 704               	.L__stack_usage = 5
 705 017a F62E      		mov r15,r22
 706 017c 072F      		mov r16,r23
 707 017e 142F      		mov r17,r20
 268:main.c        **** 	CE_RESET();
 709               	.LM80:
 710 0180 C098      		cbi 0x18,0
 269:main.c        **** 	CS_ON();
 712               	.LM81:
 713 0182 9798      		cbi 0x12,7
 270:main.c        **** 	spi_sendByte(addr);
 715               	.LM82:
 716 0184 00D0      		rcall spi_sendByte
 717               	.LBB46:
 718               	.LBB47:
 720               	.Ltext11:
 722               	.LM83:
 723 0186 82E0      		ldi r24,lo8(2)
 724 0188 8A95      	1:	dec r24
 725 018a 01F4      		brne 1b
 726 018c 00C0      		rjmp .
 727 018e CF2D      		mov r28,r15
 728 0190 D02F      		mov r29,r16
 729 0192 CE01      		movw r24,r28
 730 0194 810F      		add r24,r17
 731 0196 911D      		adc r25,__zero_reg__
 732 0198 8C01      		movw r16,r24
 733               	.L30:
 734               	.LBE47:
 735               	.LBE46:
 736               	.LBB48:
 738               	.Ltext12:
 271:main.c        **** 	_delay_us(1); //пауза в микросекунду для завершения процесса
 272:main.c        **** 	for (uint8_t i = 0 ; i < bytes ; i++)
 740               	.LM84:
 741 019a C017      		cp r28,r16
 742 019c D107      		cpc r29,r17
 743 019e 01F0      		breq .L32
 273:main.c        **** 	{
 274:main.c        **** 		spi_sendByte(pBuf[i]);
 745               	.LM85:
 746 01a0 8991      		ld r24,Y+
 747 01a2 00D0      		rcall spi_sendByte
 748 01a4 00C0      		rjmp .L30
 749               	.L32:
 750               	.LBE48:
 275:main.c        **** 	}
 276:main.c        **** 	CS_OFF();
 752               	.LM86:
 753 01a6 979A      		sbi 0x12,7
 277:main.c        **** 	CE_SET();
 755               	.LM87:
 756 01a8 C09A      		sbi 0x18,0
 757               	/* epilogue start */
 278:main.c        **** }
 759               	.LM88:
 760 01aa DF91      		pop r29
 761 01ac CF91      		pop r28
 762 01ae 1F91      		pop r17
 763 01b0 0F91      		pop r16
 764 01b2 FF90      		pop r15
 765 01b4 0895      		ret
 767               	.Lscope14:
 770               	.global	NRF24L01_Send
 772               	NRF24L01_Send:
 279:main.c        **** 
 280:main.c        **** //------------------------------------------------
 281:main.c        **** uint8_t NRF24L01_Send(uint8_t *pBuf)
 282:main.c        **** {//отправка данных в эфир
 774               	.LM89:
 775               	.LFBB15:
 776 01b6 CF93      		push r28
 777 01b8 DF93      		push r29
 778               	/* prologue: function */
 779               	/* frame size = 0 */
 780               	/* stack size = 2 */
 781               	.L__stack_usage = 2
 782 01ba EC01      		movw r28,r24
 283:main.c        **** 	uint8_t regval=0x00;						//переменная для отправки в конфигурационный регистр
 284:main.c        **** 	NRF24L01_TX_Mode(pBuf);					//включаем режим передачи
 784               	.LM90:
 785 01bc 00D0      		rcall NRF24L01_TX_Mode
 285:main.c        **** 	regval = NRF24_ReadReg(CONFIG);	//сохраняем значения конфигурационного региста
 787               	.LM91:
 788 01be 80E0      		ldi r24,0
 789 01c0 00D0      		rcall NRF24_ReadReg
 790 01c2 8E7F      		andi r24,lo8(-2)
 286:main.c        **** 	//если модуль ушел в спящий режим, то разбудим его, включив бит PWR_UP и выключив PRIM_RX
 287:main.c        **** 	regval |= (1<<PWR_UP);
 288:main.c        **** 	regval &= ~(1<<PRIM_RX);
 289:main.c        **** 	NRF24_WriteReg(CONFIG,regval);//записываем новое значение конфигурационного регистра
 792               	.LM92:
 793 01c4 682F      		mov r22,r24
 794 01c6 6260      		ori r22,lo8(2)
 795 01c8 80E0      		ldi r24,0
 796 01ca 00D0      		rcall NRF24_WriteReg
 797               	.LBB49:
 798               	.LBB50:
 800               	.Ltext13:
 802               	.LM93:
 803 01cc 8BE2      		ldi r24,lo8(299)
 804 01ce 91E0      		ldi r25,hi8(299)
 805 01d0 0197      	1:	sbiw r24,1
 806 01d2 01F4      		brne 1b
 807 01d4 00C0      		rjmp .
 808 01d6 0000      		nop
 809               	.LBE50:
 810               	.LBE49:
 812               	.Ltext14:
 290:main.c        **** 	_delay_us(150); //Задержка минимум 130 мкс
 291:main.c        **** 	//Отправим данные в воздух
 292:main.c        **** 	NRF24_Transmit(WR_TX_PLOAD, pBuf, TX_PLOAD_WIDTH);//отправка данных
 814               	.LM94:
 815 01d8 40E2      		ldi r20,lo8(32)
 816 01da BE01      		movw r22,r28
 817 01dc 80EA      		ldi r24,lo8(-96)
 818 01de 00D0      		rcall NRF24_Transmit
 293:main.c        **** 	CE_SET();
 820               	.LM95:
 821 01e0 C09A      		sbi 0x18,0
 822               	.LBB51:
 823               	.LBB52:
 825               	.Ltext15:
 827               	.LM96:
 828 01e2 98E2      		ldi r25,lo8(40)
 829 01e4 9A95      	1:	dec r25
 830 01e6 01F4      		brne 1b
 831               	.LBE52:
 832               	.LBE51:
 834               	.Ltext16:
 294:main.c        **** 	_delay_us(15); //minimum 10us high pulse (Page 21)
 295:main.c        **** 	CE_RESET();
 836               	.LM97:
 837 01e8 C098      		cbi 0x18,0
 838               	.LBB53:
 839               	.LBB54:
 841               	.Ltext17:
 843               	.LM98:
 844 01ea 87EE      		ldi r24,lo8(999)
 845 01ec 93E0      		ldi r25,hi8(999)
 846 01ee 0197      	1:	sbiw r24,1
 847 01f0 01F4      		brne 1b
 848 01f2 00C0      		rjmp .
 849 01f4 0000      		nop
 850               	.LBE54:
 851               	.LBE53:
 853               	.Ltext18:
 296:main.c        **** 	_delay_us(500);
 297:main.c        **** 	NRF24L01_RX_Mode();				//переход в режим приема
 855               	.LM99:
 856 01f6 00D0      		rcall NRF24L01_RX_Mode
 298:main.c        **** 	return 0;
 299:main.c        **** }
 858               	.LM100:
 859 01f8 80E0      		ldi r24,0
 860               	/* epilogue start */
 861 01fa DF91      		pop r29
 862 01fc CF91      		pop r28
 863 01fe 0895      		ret
 865               	.Lscope15:
 867               	.global	nrf24_init
 869               	nrf24_init:
 300:main.c        **** 
 301:main.c        **** //------------------------------------------------
 302:main.c        **** void nrf24_init(void)
 303:main.c        **** {//инициализация
 871               	.LM101:
 872               	.LFBB16:
 873               	/* prologue: function */
 874               	/* frame size = 0 */
 875               	/* stack size = 0 */
 876               	.L__stack_usage = 0
 304:main.c        **** 	CE_RESET();							//опускаем к земле вывод ce
 878               	.LM102:
 879 0200 C098      		cbi 0x18,0
 880               	.LBB55:
 881               	.LBB56:
 883               	.Ltext19:
 885               	.LM103:
 886 0202 8FE0      		ldi r24,lo8(9999)
 887 0204 97E2      		ldi r25,hi8(9999)
 888 0206 0197      	1:	sbiw r24,1
 889 0208 01F4      		brne 1b
 890 020a 00C0      		rjmp .
 891 020c 0000      		nop
 892               	.LBE56:
 893               	.LBE55:
 895               	.Ltext20:
 305:main.c        **** 	_delay_us(5000);					//задержка 5 мс
 306:main.c        **** 	//записываем конфигурационный байт,
 307:main.c        **** 	NRF24_WriteReg(CONFIG, 0x0a);		// Set PWR_UP bit, enable CRC(1 byte) &Prim_RX:0 (Transmitter)
 897               	.LM104:
 898 020e 6AE0      		ldi r22,lo8(10)
 899 0210 80E0      		ldi r24,0
 900 0212 00D0      		rcall NRF24_WriteReg
 901               	.LBB57:
 902               	.LBB58:
 904               	.Ltext21:
 906               	.LM105:
 907 0214 8FE0      		ldi r24,lo8(9999)
 908 0216 97E2      		ldi r25,hi8(9999)
 909 0218 0197      	1:	sbiw r24,1
 910 021a 01F4      		brne 1b
 911 021c 00C0      		rjmp .
 912 021e 0000      		nop
 913               	.LBE58:
 914               	.LBE57:
 916               	.Ltext22:
 308:main.c        **** 	_delay_us(5000);
 309:main.c        **** 	NRF24_WriteReg(EN_AA, 0x00);		// Enable Pipe0
 918               	.LM106:
 919 0220 60E0      		ldi r22,0
 920 0222 81E0      		ldi r24,lo8(1)
 921 0224 00D0      		rcall NRF24_WriteReg
 310:main.c        **** 	NRF24_WriteReg(EN_RXADDR, 0x01);	// Enable Pipe0
 923               	.LM107:
 924 0226 61E0      		ldi r22,lo8(1)
 925 0228 82E0      		ldi r24,lo8(2)
 926 022a 00D0      		rcall NRF24_WriteReg
 311:main.c        **** 	NRF24_WriteReg(SETUP_AW, 0x01);		// Setup address width=3 bytes
 928               	.LM108:
 929 022c 61E0      		ldi r22,lo8(1)
 930 022e 83E0      		ldi r24,lo8(3)
 931 0230 00D0      		rcall NRF24_WriteReg
 312:main.c        **** 	NRF24_WriteReg(SETUP_RETR, 0x00);	// 1500us, 15 retrans
 933               	.LM109:
 934 0232 60E0      		ldi r22,0
 935 0234 84E0      		ldi r24,lo8(4)
 936 0236 00D0      		rcall NRF24_WriteReg
 313:main.c        **** 	NRF24_ToggleFeatures();				//активация команд
 938               	.LM110:
 939 0238 00D0      		rcall NRF24_ToggleFeatures
 314:main.c        **** 	NRF24_WriteReg(FEATURE, 0x07);			//установка стандартных значений регистра FEATURE
 941               	.LM111:
 942 023a 67E0      		ldi r22,lo8(7)
 943 023c 8DE1      		ldi r24,lo8(29)
 944 023e 00D0      		rcall NRF24_WriteReg
 315:main.c        **** 	NRF24_WriteReg(DYNPD, 0);			//отключение динамического размера полезной нагрузки
 946               	.LM112:
 947 0240 60E0      		ldi r22,0
 948 0242 8CE1      		ldi r24,lo8(28)
 949 0244 00D0      		rcall NRF24_WriteReg
 316:main.c        **** 	NRF24_WriteReg(STATUS, 0x70);		//Reset flags for IRQ
 951               	.LM113:
 952 0246 60E7      		ldi r22,lo8(112)
 953 0248 87E0      		ldi r24,lo8(7)
 954 024a 00D0      		rcall NRF24_WriteReg
 317:main.c        **** 	NRF24_WriteReg(RF_CH, 76);			// частота 2476 MHz
 956               	.LM114:
 957 024c 6CE4      		ldi r22,lo8(76)
 958 024e 85E0      		ldi r24,lo8(5)
 959 0250 00D0      		rcall NRF24_WriteReg
 318:main.c        **** 	NRF24_WriteReg(RF_SETUP, 0x06);		//TX_PWR:0dBm, Datarate:1Mbps
 961               	.LM115:
 962 0252 66E0      		ldi r22,lo8(6)
 963 0254 86E0      		ldi r24,lo8(6)
 964 0256 00D0      		rcall NRF24_WriteReg
 319:main.c        **** 	NRF24_Write_Buf(TX_ADDR, TX_ADDRESS0, TX_ADR_WIDTH);//запись адреса передачи
 966               	.LM116:
 967 0258 43E0      		ldi r20,lo8(3)
 968 025a 60E0      		ldi r22,lo8(TX_ADDRESS0)
 969 025c 70E0      		ldi r23,hi8(TX_ADDRESS0)
 970 025e 80E1      		ldi r24,lo8(16)
 971 0260 00D0      		rcall NRF24_Write_Buf
 320:main.c        **** 	NRF24_Write_Buf(RX_ADDR_P1, TX_ADDRESS0, TX_ADR_WIDTH);//запись адреса приема
 973               	.LM117:
 974 0262 43E0      		ldi r20,lo8(3)
 975 0264 60E0      		ldi r22,lo8(TX_ADDRESS0)
 976 0266 70E0      		ldi r23,hi8(TX_ADDRESS0)
 977 0268 8BE0      		ldi r24,lo8(11)
 978 026a 00D0      		rcall NRF24_Write_Buf
 321:main.c        **** 	NRF24_WriteReg(RX_PW_P0, TX_PLOAD_WIDTH); //Number of bytes in RX payload in data pipe 1
 980               	.LM118:
 981 026c 60E2      		ldi r22,lo8(32)
 982 026e 81E1      		ldi r24,lo8(17)
 983 0270 00D0      		rcall NRF24_WriteReg
 322:main.c        **** 	//пока уходим в режим приёмника
 323:main.c        **** 	NRF24L01_RX_Mode();					//режим приема
 985               	.LM119:
 986 0272 00D0      		rcall NRF24L01_RX_Mode
 324:main.c        **** 	LED_OFF();
 988               	.LM120:
 989 0274 9698      		cbi 0x12,6
 990 0276 0895      		ret
 992               	.Lscope16:
 994               	.global	nrf24_receive
 996               	nrf24_receive:
 325:main.c        **** }
 326:main.c        **** 
 327:main.c        **** //--------------------------------------------------
 328:main.c        **** void nrf24_receive(void)
 329:main.c        **** {
 998               	.LM121:
 999               	.LFBB17:
 1000               	/* prologue: function */
 1001               	/* frame size = 0 */
 1002               	/* stack size = 0 */
 1003               	.L__stack_usage = 0
 330:main.c        **** 	uint8_t status = 0x01;	//переменная статус
 331:main.c        **** 	status = NRF24_ReadReg(STATUS);	//чтение значения регистра статуса
 1005               	.LM122:
 1006 0278 87E0      		ldi r24,lo8(7)
 1007 027a 00D0      		rcall NRF24_ReadReg
 332:main.c        **** 	if(status & RX_DR)				//если есть данные на прием
 1009               	.LM123:
 1010 027c 86FF      		sbrs r24,6
 1011 027e 00C0      		rjmp .L35
 1012               	.LBB61:
 1013               	.LBB62:
 333:main.c        **** 	{
 334:main.c        **** 		NRF24_Read_Buf(RD_RX_PLOAD,rx_buf,TX_PLOAD_WIDTH);//чтение буфера
 1015               	.LM124:
 1016 0280 40E2      		ldi r20,lo8(32)
 1017 0282 60E0      		ldi r22,lo8(rx_buf)
 1018 0284 70E0      		ldi r23,hi8(rx_buf)
 1019 0286 81E6      		ldi r24,lo8(97)
 1020 0288 00D0      		rcall NRF24_Read_Buf
 335:main.c        **** 		NRF24_WriteReg(STATUS, 0x40);	//запись в регистр статуса 1 в шестой бит, обнуление остальных
 1022               	.LM125:
 1023 028a 60E4      		ldi r22,lo8(64)
 1024 028c 87E0      		ldi r24,lo8(7)
 1025 028e 00D0      		rcall NRF24_WriteReg
 336:main.c        **** 		f_rx = 1;						//поднимаем флаг приема
 1027               	.LM126:
 1028 0290 81E0      		ldi r24,lo8(1)
 1029 0292 8093 0000 		sts f_rx,r24
 1030               	.L35:
 1031 0296 0895      		ret
 1032               	.LBE62:
 1033               	.LBE61:
 1035               	.Lscope17:
 1036               		.section	.text.startup,"ax",@progbits
 1038               	.global	main
 1040               	main:
 337:main.c        **** 	}
 338:main.c        **** }
 339:main.c        **** 
 340:main.c        **** static inline void eraseFlash(void)
 341:main.c        **** {
 342:main.c        **** 	// erase only main section (bootloader protection)
 343:main.c        **** 	uint32_t addr = 0;
 344:main.c        **** 	while (APP_END > addr) 
 345:main.c        **** 	{
 346:main.c        **** 		boot_page_erase(addr);		// Perform page erase
 347:main.c        **** 		boot_spm_busy_wait();		// Wait until the memory is erased.
 348:main.c        **** 		addr += SPM_PAGESIZE;
 349:main.c        **** 	}
 350:main.c        **** 	boot_rww_enable();
 351:main.c        **** }
 352:main.c        **** 
 353:main.c        **** static inline uint16_t writeFlashPage(uint16_t waddr, pagebuf_t size)
 354:main.c        **** {
 355:main.c        **** 	uint32_t pagestart = (uint32_t)waddr<<1;
 356:main.c        **** 	uint32_t baddr = pagestart;
 357:main.c        **** 	uint16_t data;
 358:main.c        **** 	uint8_t *tmp = gBuffer;
 359:main.c        **** 
 360:main.c        **** 	do 
 361:main.c        **** 		{
 362:main.c        **** 		data = *tmp++;
 363:main.c        **** 		data |= *tmp++ << 8;
 364:main.c        **** 		boot_page_fill(baddr, data);	// call asm routine.
 365:main.c        **** 
 366:main.c        **** 		baddr += 2;			// Select next word in memory
 367:main.c        **** 		size -= 2;			// Reduce number of bytes to write by two
 368:main.c        **** 		} 
 369:main.c        **** 	while (size);				// Loop until all bytes written
 370:main.c        **** 
 371:main.c        **** 	boot_page_write(pagestart);
 372:main.c        **** 	boot_spm_busy_wait();
 373:main.c        **** 	boot_rww_enable();		// Re-enable the RWW section
 374:main.c        **** 
 375:main.c        **** 	return baddr>>1;
 376:main.c        **** }
 377:main.c        **** 
 378:main.c        **** static inline uint16_t writeEEpromPage(uint16_t address, pagebuf_t size)
 379:main.c        **** {
 380:main.c        **** 	uint8_t *tmp = gBuffer;
 381:main.c        **** 
 382:main.c        **** 	do 
 383:main.c        **** 		{
 384:main.c        **** 		eeprom_write_byte( (uint8_t*)address, *tmp++ );
 385:main.c        **** 		address++;			// Select next byte
 386:main.c        **** 		size--;				// Decreas number of bytes to write
 387:main.c        **** 		}
 388:main.c        **** 	while (size);				// Loop until all bytes written
 389:main.c        **** 
 390:main.c        **** 	//eeprom_busy_wait();
 391:main.c        **** 
 392:main.c        **** 	return address;
 393:main.c        **** }
 394:main.c        **** 
 395:main.c        **** static void (*jump_to_app)(void) = 0x0000;
 396:main.c        **** 
 397:main.c        **** int main(void)
 398:main.c        **** {
 1042               	.LM127:
 1043               	.LFBB18:
 1044               	/* prologue: function */
 1045               	/* frame size = 0 */
 1046               	/* stack size = 0 */
 1047               	.L__stack_usage = 0
 399:main.c        **** 	port_init();							//инициализация портов
 1049               	.LM128:
 1050 0000 00D0      		rcall port_init
 400:main.c        **** 	spi_init();								//инициализация SPI
 1052               	.LM129:
 1053 0002 00D0      		rcall spi_init
 401:main.c        **** 	nrf24_init();
 1055               	.LM130:
 1056 0004 00D0      		rcall nrf24_init
 402:main.c        **** 
 403:main.c        **** 	uint8_t blink_counter = 2;
 404:main.c        **** 	while (blink_counter)
 405:main.c        **** 	{
 406:main.c        **** 		LED_ON();
 1058               	.LM131:
 1059 0006 969A      		sbi 0x12,6
 1060               	.LBB75:
 1061               	.LBB76:
 1063               	.Ltext23:
 187:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 1065               	.LM132:
 1066 0008 2FEF      		ldi r18,lo8(159999)
 1067 000a 80E7      		ldi r24,hi8(159999)
 1068 000c 92E0      		ldi r25,hlo8(159999)
 1069 000e 2150      	1:	subi r18,1
 1070 0010 8040      		sbci r24,0
 1071 0012 9040      		sbci r25,0
 1072 0014 01F4      		brne 1b
 1073 0016 00C0      		rjmp .
 1074 0018 0000      		nop
 1075               	.LBE76:
 1076               	.LBE75:
 1078               	.Ltext24:
 407:main.c        **** 		_delay_ms(100);
 408:main.c        **** 		LED_OFF();
 1080               	.LM133:
 1081 001a 9698      		cbi 0x12,6
 1082               	.LBB78:
 1083               	.LBB79:
 1085               	.Ltext25:
 187:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 1087               	.LM134:
 1088 001c EFEF      		ldi r30,lo8(159999)
 1089 001e F0E7      		ldi r31,hi8(159999)
 1090 0020 22E0      		ldi r18,hlo8(159999)
 1091 0022 E150      	1:	subi r30,1
 1092 0024 F040      		sbci r31,0
 1093 0026 2040      		sbci r18,0
 1094 0028 01F4      		brne 1b
 1095 002a 00C0      		rjmp .
 1096 002c 0000      		nop
 1097               	.LBE79:
 1098               	.LBE78:
 1100               	.Ltext26:
 406:main.c        **** 		_delay_ms(100);
 1102               	.LM135:
 1103 002e 969A      		sbi 0x12,6
 1104               	.LBB81:
 1105               	.LBB77:
 1107               	.Ltext27:
 187:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 1109               	.LM136:
 1110 0030 8FEF      		ldi r24,lo8(159999)
 1111 0032 90E7      		ldi r25,hi8(159999)
 1112 0034 E2E0      		ldi r30,hlo8(159999)
 1113 0036 8150      	1:	subi r24,1
 1114 0038 9040      		sbci r25,0
 1115 003a E040      		sbci r30,0
 1116 003c 01F4      		brne 1b
 1117 003e 00C0      		rjmp .
 1118 0040 0000      		nop
 1119               	.LBE77:
 1120               	.LBE81:
 1122               	.Ltext28:
 1124               	.LM137:
 1125 0042 9698      		cbi 0x12,6
 1126               	.LBB82:
 1127               	.LBB80:
 1129               	.Ltext29:
 187:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 1131               	.LM138:
 1132 0044 FFEF      		ldi r31,lo8(159999)
 1133 0046 20E7      		ldi r18,hi8(159999)
 1134 0048 82E0      		ldi r24,hlo8(159999)
 1135 004a F150      	1:	subi r31,1
 1136 004c 2040      		sbci r18,0
 1137 004e 8040      		sbci r24,0
 1138 0050 01F4      		brne 1b
 1139 0052 00C0      		rjmp .
 1140 0054 0000      		nop
 1141 0056 C0E0      		ldi r28,0
 1142 0058 D0E0      		ldi r29,0
 1143               	.LBE80:
 1144               	.LBE82:
 1145               	.LBB83:
 1147               	.Ltext30:
 409:main.c        **** 		_delay_ms(100);
 410:main.c        **** 		blink_counter--;
 411:main.c        **** 	}
 412:main.c        **** 
 413:main.c        **** 	uint16_t cnt = 0;
 414:main.c        **** 
 415:main.c        **** 	while (1) 
 416:main.c        **** 	{
 417:main.c        **** 		nrf24_receive();
 418:main.c        **** 
 419:main.c        **** 		if(f_rx == 1)						//если флаг приема поднят
 420:main.c        **** 		{
 421:main.c        **** 			if (rx_buf[0] == BUT_ADDR)		//если первый принятый байт совпадает с адресом кнопки
 422:main.c        **** 			{
 423:main.c        **** 				if (rx_buf[1] == 'J')
 424:main.c        **** 				{
 425:main.c        **** 					jump_to_app();
 426:main.c        **** 				}
 427:main.c        **** 
 428:main.c        **** 				if (rx_buf[1] == 'E')	
 429:main.c        **** 				{
 430:main.c        **** 					eraseFlash();
 431:main.c        **** 				}
 432:main.c        **** 
 433:main.c        **** 				if (rx_buf[1] == 'W')	
 434:main.c        **** 				{
 435:main.c        **** 					LED_ON();
 436:main.c        **** 					f_wait = 1;
 437:main.c        **** 					tx_buf[0] = BUT_ADDR;
 438:main.c        **** 					tx_buf[1] = 'W';
 439:main.c        **** 					NRF24L01_Send(tx_buf);
 440:main.c        **** 				}
 441:main.c        **** 
 442:main.c        **** 				if (rx_buf[1] == 'F')		//
 443:main.c        **** 				{
 444:main.c        **** 					LED_TGL();
 1149               	.LM139:
 1150 005a 20E4      		ldi r18,lo8(64)
 1151 005c 822E      		mov r8,r18
 1152               	.LBB84:
 1153               	.LBB85:
 364:main.c        **** 
 1155               	.LM140:
 1156 005e 9924      		clr r9
 1157 0060 9394      		inc r9
 371:main.c        **** 	boot_spm_busy_wait();
 1159               	.LM141:
 1160 0062 35E0      		ldi r19,lo8(5)
 1161 0064 A32E      		mov r10,r19
 373:main.c        **** 
 1163               	.LM142:
 1164 0066 11E1      		ldi r17,lo8(17)
 1165               	.LBE85:
 1166               	.LBE84:
 1167               	.LBE83:
 1168               	.LBB91:
 1169               	.LBB92:
 346:main.c        **** 		boot_spm_busy_wait();		// Wait until the memory is erased.
 1171               	.LM143:
 1172 0068 43E0      		ldi r20,lo8(3)
 1173 006a D42E      		mov r13,r20
 1174               	.LBE92:
 1175               	.LBE91:
 425:main.c        **** 				}
 1177               	.LM144:
 1178 006c E12C      		mov r14,__zero_reg__
 1179 006e F12C      		mov r15,__zero_reg__
 1180               	.LBB94:
 1181               	.LBB88:
 1182               	.LBB86:
 364:main.c        **** 
 1184               	.LM145:
 1185 0070 CC24      		clr r12
 1186 0072 C394      		inc r12
 1187               	.L57:
 1188               	.LBE86:
 1189               	.LBE88:
 445:main.c        **** 					pagebuf_t size;
 446:main.c        **** 					size = rx_buf[2];
 447:main.c        **** 					address = rx_buf[3]; //
 448:main.c        **** 
 449:main.c        **** 					for (uint8_t i = 0; i < size; i++)
 450:main.c        **** 					{
 451:main.c        **** 						gBuffer[i] = rx_buf[i+4];
 452:main.c        **** 					}
 453:main.c        **** 
 454:main.c        **** 					writeFlashPage(address, size);
 455:main.c        **** 					//_delay_ms(100);
 456:main.c        **** 					tx_buf[0] = BUT_ADDR;
 1191               	.LM146:
 1192 0074 07E0      		ldi r16,lo8(7)
 457:main.c        **** 					tx_buf[1] = 'N';
 1194               	.LM147:
 1195 0076 9EE4      		ldi r25,lo8(78)
 1196 0078 B92E      		mov r11,r25
 1197               	.L55:
 1198               	.LBE94:
 417:main.c        **** 
 1200               	.LM148:
 1201 007a 00D0      		rcall nrf24_receive
 419:main.c        **** 		{
 1203               	.LM149:
 1204 007c 8091 0000 		lds r24,f_rx
 1205 0080 8130      		cpi r24,lo8(1)
 1206 0082 01F0      		breq .+2
 1207 0084 00C0      		rjmp .L41
 421:main.c        **** 			{
 1209               	.LM150:
 1210 0086 8091 0000 		lds r24,rx_buf
 1211 008a 8730      		cpi r24,lo8(7)
 1212 008c 01F0      		breq .+2
 1213 008e 00C0      		rjmp .L43
 423:main.c        **** 				{
 1215               	.LM151:
 1216 0090 8091 0000 		lds r24,rx_buf+1
 1217 0094 8A34      		cpi r24,lo8(74)
 1218 0096 01F4      		brne .L44
 425:main.c        **** 				}
 1220               	.LM152:
 1221 0098 F701      		movw r30,r14
 1222 009a 0995      		icall
 1223               	.L44:
 428:main.c        **** 				{
 1225               	.LM153:
 1226 009c 8091 0000 		lds r24,rx_buf+1
 1227 00a0 8534      		cpi r24,lo8(69)
 1228 00a2 01F4      		brne .L45
 1229 00a4 E0E0      		ldi r30,0
 1230 00a6 F0E0      		ldi r31,0
 1231               	.L47:
 1232               	.LBB95:
 1233               	.LBB93:
 346:main.c        **** 		boot_spm_busy_wait();		// Wait until the memory is erased.
 1235               	.LM154:
 1236               	/* #APP */
 1237               	 ;  346 "main.c" 1
 1238 00a8 D092 5700 		sts 87, r13
 1239 00ac E895      		spm
 1240               		
 1241               	 ;  0 "" 2
 1242               	/* #NOAPP */
 1243               	.L46:
 347:main.c        **** 		addr += SPM_PAGESIZE;
 1245               	.LM155:
 1246 00ae 07B6      		in __tmp_reg__,0x37
 1247 00b0 00FC      		sbrc __tmp_reg__,0
 1248 00b2 00C0      		rjmp .L46
 1249 00b4 E05C      		subi r30,-64
 1250 00b6 FF4F      		sbci r31,-1
 344:main.c        **** 	{
 1252               	.LM156:
 1253 00b8 E115      		cp r30,__zero_reg__
 1254 00ba 28E1      		ldi r18,24
 1255 00bc F207      		cpc r31,r18
 1256 00be 01F4      		brne .L47
 350:main.c        **** }
 1258               	.LM157:
 1259               	/* #APP */
 1260               	 ;  350 "main.c" 1
 1261 00c0 1093 5700 		sts 87, r17
 1262 00c4 E895      		spm
 1263               		
 1264               	 ;  0 "" 2
 1265               	/* #NOAPP */
 1266 00c6 00C0      		rjmp .L48
 1267               	.L45:
 1268               	.LBE93:
 1269               	.LBE95:
 433:main.c        **** 				{
 1271               	.LM158:
 1272 00c8 8735      		cpi r24,lo8(87)
 1273 00ca 01F4      		brne .L48
 435:main.c        **** 					f_wait = 1;
 1275               	.LM159:
 1276 00cc 969A      		sbi 0x12,6
 436:main.c        **** 					tx_buf[0] = BUT_ADDR;
 1278               	.LM160:
 1279 00ce C092 0000 		sts f_wait,r12
 437:main.c        **** 					tx_buf[1] = 'W';
 1281               	.LM161:
 1282 00d2 0093 0000 		sts tx_buf,r16
 438:main.c        **** 					NRF24L01_Send(tx_buf);
 1284               	.LM162:
 1285 00d6 8093 0000 		sts tx_buf+1,r24
 439:main.c        **** 				}
 1287               	.LM163:
 1288 00da 80E0      		ldi r24,lo8(tx_buf)
 1289 00dc 90E0      		ldi r25,hi8(tx_buf)
 1290 00de 00D0      		rcall NRF24L01_Send
 1291               	.L48:
 442:main.c        **** 				{
 1293               	.LM164:
 1294 00e0 8091 0000 		lds r24,rx_buf+1
 1295 00e4 8634      		cpi r24,lo8(70)
 1296 00e6 01F0      		breq .+2
 1297 00e8 00C0      		rjmp .L43
 1298               	.LBB96:
 444:main.c        **** 					pagebuf_t size;
 1300               	.LM165:
 1301 00ea 82B3      		in r24,0x12
 1302 00ec 8825      		eor r24,r8
 1303 00ee 82BB      		out 0x12,r24
 446:main.c        **** 					address = rx_buf[3]; //
 1305               	.LM166:
 1306 00f0 6091 0000 		lds r22,rx_buf+2
 447:main.c        **** 
 1308               	.LM167:
 1309 00f4 8091 0000 		lds r24,rx_buf+3
 1310 00f8 282F      		mov r18,r24
 1311 00fa 30E0      		ldi r19,0
 1312 00fc 3093 0000 		sts address+1,r19
 1313 0100 2093 0000 		sts address,r18
 1314 0104 A0E0      		ldi r26,lo8(rx_buf+4)
 1315 0106 B0E0      		ldi r27,hi8(rx_buf+4)
 1316               	.LBB89:
 449:main.c        **** 					{
 1318               	.LM168:
 1319 0108 E0E0      		ldi r30,lo8(gBuffer)
 1320 010a F0E0      		ldi r31,hi8(gBuffer)
 1321 010c 90E0      		ldi r25,0
 1322               	.L50:
 449:main.c        **** 					{
 1324               	.LM169:
 1325 010e 9617      		cp r25,r22
 1326 0110 01F0      		breq .L62
 451:main.c        **** 					}
 1328               	.LM170:
 1329 0112 2D91      		ld r18,X+
 1330 0114 2193      		st Z+,r18
 449:main.c        **** 					{
 1332               	.LM171:
 1333 0116 9F5F      		subi r25,lo8(-(1))
 1334 0118 00C0      		rjmp .L50
 1335               	.L62:
 1336               	.LBE89:
 1337               	.LBB90:
 1338               	.LBB87:
 355:main.c        **** 	uint32_t baddr = pagestart;
 1340               	.LM172:
 1341 011a 90E0      		ldi r25,0
 1342 011c A0E0      		ldi r26,0
 1343 011e B0E0      		ldi r27,0
 1344 0120 2C01      		movw r4,r24
 1345 0122 3D01      		movw r6,r26
 1346 0124 440C      		lsl r4
 1347 0126 551C      		rol r5
 1348 0128 661C      		rol r6
 1349 012a 771C      		rol r7
 358:main.c        **** 
 1351               	.LM173:
 1352 012c 2091 0000 		lds r18,gBuffer
 1353 0130 A0E0      		ldi r26,lo8(gBuffer)
 1354 0132 B0E0      		ldi r27,hi8(gBuffer)
 1355 0134 A201      		movw r20,r4
 364:main.c        **** 
 1357               	.LM174:
 1358 0136 C201      		movw r24,r4
 1359 0138 8050      		subi r24,lo8(gBuffer)
 1360 013a 9040      		sbci r25,hi8(gBuffer)
 1361               	.L53:
 1362 013c FC01      		movw r30,r24
 1363 013e EA0F      		add r30,r26
 1364 0140 FB1F      		adc r31,r27
 1365 0142 1196      		adiw r26,1
 1366 0144 7C91      		ld r23,X
 1367 0146 1197      		sbiw r26,1
 1368 0148 30E0      		ldi r19,0
 1369 014a 372B      		or r19,r23
 1370               	/* #APP */
 1371               	 ;  364 "main.c" 1
 1372 014c 0901      		movw  r0, r18
 1373 014e 9092 5700 		sts 87, r9
 1374 0152 E895      		spm
 1375 0154 1124      		clr  r1
 1376               		
 1377               	 ;  0 "" 2
 367:main.c        **** 		} 
 1379               	.LM175:
 1380               	/* #NOAPP */
 1381 0156 6250      		subi r22,lo8(-(-2))
 1382 0158 1296      		adiw r26,2
 369:main.c        **** 
 1384               	.LM176:
 1385 015a 6623      		tst r22
 1386 015c 01F0      		breq .L52
 363:main.c        **** 		boot_page_fill(baddr, data);	// call asm routine.
 1388               	.LM177:
 1389 015e 2C91      		ld r18,X
 1390 0160 00C0      		rjmp .L53
 1391               	.L52:
 371:main.c        **** 	boot_spm_busy_wait();
 1393               	.LM178:
 1394 0162 FA01      		movw r30,r20
 1395               	/* #APP */
 1396               	 ;  371 "main.c" 1
 1397 0164 A092 5700 		sts 87, r10
 1398 0168 E895      		spm
 1399               		
 1400               	 ;  0 "" 2
 1401               	/* #NOAPP */
 1402               	.L54:
 372:main.c        **** 	boot_rww_enable();		// Re-enable the RWW section
 1404               	.LM179:
 1405 016a 07B6      		in __tmp_reg__,0x37
 1406 016c 00FC      		sbrc __tmp_reg__,0
 1407 016e 00C0      		rjmp .L54
 373:main.c        **** 
 1409               	.LM180:
 1410               	/* #APP */
 1411               	 ;  373 "main.c" 1
 1412 0170 1093 5700 		sts 87, r17
 1413 0174 E895      		spm
 1414               		
 1415               	 ;  0 "" 2
 1416               	/* #NOAPP */
 1417               	.LBE87:
 1418               	.LBE90:
 456:main.c        **** 					tx_buf[1] = 'N';
 1420               	.LM181:
 1421 0176 0093 0000 		sts tx_buf,r16
 1423               	.LM182:
 1424 017a B092 0000 		sts tx_buf+1,r11
 458:main.c        **** 					NRF24L01_Send(tx_buf);
 1426               	.LM183:
 1427 017e 80E0      		ldi r24,lo8(tx_buf)
 1428 0180 90E0      		ldi r25,hi8(tx_buf)
 1429 0182 00D0      		rcall NRF24L01_Send
 1430               	.L43:
 1431               	.LBE96:
 459:main.c        **** 				}
 460:main.c        **** 
 461:main.c        **** 			}
 462:main.c        **** 
 463:main.c        **** 			f_rx = 0;						//опускаем флаг приема
 1433               	.LM184:
 1434 0184 1092 0000 		sts f_rx,__zero_reg__
 1435               	.L41:
 464:main.c        **** 		}
 465:main.c        **** 
 466:main.c        **** 		wdt_reset();
 1437               	.LM185:
 1438               	/* #APP */
 1439               	 ;  466 "main.c" 1
 1440 0188 A895      		wdr
 1441               	 ;  0 "" 2
 467:main.c        **** 
 468:main.c        **** 		if (!f_wait)
 1443               	.LM186:
 1444               	/* #NOAPP */
 1445 018a 8091 0000 		lds r24,f_wait
 1446 018e 8111      		cpse r24,__zero_reg__
 1447 0190 00C0      		rjmp .L55
 469:main.c        **** 		{
 470:main.c        **** 			if (cnt++ >= WAIT_VALUE) 
 1449               	.LM187:
 1450 0192 C83E      		cpi r28,-24
 1451 0194 F3E0      		ldi r31,3
 1452 0196 DF07      		cpc r29,r31
 1453 0198 00F0      		brlo .L56
 471:main.c        **** 			{
 472:main.c        **** 				jump_to_app();			// Jump to application sector
 1455               	.LM188:
 1456 019a F701      		movw r30,r14
 1457 019c 0995      		icall
 1458               	.L56:
 1459               	.LBB97:
 1460               	.LBB98:
 1462               	.Ltext31:
 187:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 1464               	.LM189:
 1465 019e 8FEC      		ldi r24,lo8(1999)
 1466 01a0 97E0      		ldi r25,hi8(1999)
 1467 01a2 0197      	1:	sbiw r24,1
 1468 01a4 01F4      		brne 1b
 1469 01a6 00C0      		rjmp .
 1470 01a8 0000      		nop
 1471 01aa 2196      		adiw r28,1
 1472 01ac 00C0      		rjmp .L57
 1473               	.LBE98:
 1474               	.LBE97:
 1497               	.Lscope18:
 1498               		.comm	gBuffer,64,1
 1499               	.global	f_wait
 1500               		.section .bss
 1503               	f_wait:
 1504 0000 00        		.zero	1
 1505               		.comm	val,1,1
 1506               	.global	device
 1509               	device:
 1510 0001 00        		.zero	1
 1511               	.global	address
 1514               	address:
 1515 0002 0000      		.zero	2
 1516               		.comm	buf,20,1
 1517               		.comm	f_send,1,1
 1518               	.global	f_tx
 1521               	f_tx:
 1522 0004 00        		.zero	1
 1523               	.global	f_rx
 1526               	f_rx:
 1527 0005 00        		.zero	1
 1528               	.global	tx_buf
 1531               	tx_buf:
 1532 0006 0000 0000 		.zero	32
 1532      0000 0000 
 1532      0000 0000 
 1532      0000 0000 
 1532      0000 0000 
 1533               	.global	rx_buf
 1536               	rx_buf:
 1537 0026 0000 0000 		.zero	32
 1537      0000 0000 
 1537      0000 0000 
 1537      0000 0000 
 1537      0000 0000 
 1538               	.global	TX_ADDRESS1
 1539               		.data
 1542               	TX_ADDRESS1:
 1543 0000 B7        		.byte	-73
 1544 0001 B5        		.byte	-75
 1545 0002 A1        		.byte	-95
 1546               	.global	TX_ADDRESS0
 1549               	TX_ADDRESS0:
 1550 0003 B5        		.byte	-75
 1551 0004 B5        		.byte	-75
 1552 0005 A1        		.byte	-95
 1566               		.text
 1568               	.Letext0:
 1569               		.ident	"GCC: (AVR_8_bit_GNU_Toolchain_3.6.2_1778) 5.4.0"
 1570               	.global __do_copy_data
 1571               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
C:\Users\vmelehin\AppData\Local\Temp\ccvX1GN5.s:2      *ABS*:0000003e __SP_H__
C:\Users\vmelehin\AppData\Local\Temp\ccvX1GN5.s:3      *ABS*:0000003d __SP_L__
C:\Users\vmelehin\AppData\Local\Temp\ccvX1GN5.s:4      *ABS*:0000003f __SREG__
C:\Users\vmelehin\AppData\Local\Temp\ccvX1GN5.s:5      *ABS*:00000000 __tmp_reg__
C:\Users\vmelehin\AppData\Local\Temp\ccvX1GN5.s:6      *ABS*:00000001 __zero_reg__
C:\Users\vmelehin\AppData\Local\Temp\ccvX1GN5.s:136    .text:00000000 port_init
C:\Users\vmelehin\AppData\Local\Temp\ccvX1GN5.s:172    .text:00000016 spi_init
C:\Users\vmelehin\AppData\Local\Temp\ccvX1GN5.s:201    .text:00000028 spi_sendByte
C:\Users\vmelehin\AppData\Local\Temp\ccvX1GN5.s:227    .text:00000030 spi_changeByte
C:\Users\vmelehin\AppData\Local\Temp\ccvX1GN5.s:255    .text:0000003a NRF24_ReadReg
C:\Users\vmelehin\AppData\Local\Temp\ccvX1GN5.s:298    .text:00000050 NRF24_WriteReg
C:\Users\vmelehin\AppData\Local\Temp\ccvX1GN5.s:332    .text:00000064 NRF24_ToggleFeatures
C:\Users\vmelehin\AppData\Local\Temp\ccvX1GN5.s:376    .text:0000007a NRF24_Read_Buf
C:\Users\vmelehin\AppData\Local\Temp\ccvX1GN5.s:441    .text:000000bc NRF24_Write_Buf
C:\Users\vmelehin\AppData\Local\Temp\ccvX1GN5.s:515    .text:00000100 NRF24_FlushRX
C:\Users\vmelehin\AppData\Local\Temp\ccvX1GN5.s:553    .text:00000112 NRF24_FlushTX
C:\Users\vmelehin\AppData\Local\Temp\ccvX1GN5.s:591    .text:00000124 NRF24L01_RX_Mode
C:\Users\vmelehin\AppData\Local\Temp\ccvX1GN5.s:1542   .data:00000000 TX_ADDRESS1
C:\Users\vmelehin\AppData\Local\Temp\ccvX1GN5.s:654    .text:00000156 NRF24L01_TX_Mode
C:\Users\vmelehin\AppData\Local\Temp\ccvX1GN5.s:1549   .data:00000003 TX_ADDRESS0
C:\Users\vmelehin\AppData\Local\Temp\ccvX1GN5.s:692    .text:00000170 NRF24_Transmit
C:\Users\vmelehin\AppData\Local\Temp\ccvX1GN5.s:772    .text:000001b6 NRF24L01_Send
C:\Users\vmelehin\AppData\Local\Temp\ccvX1GN5.s:869    .text:00000200 nrf24_init
C:\Users\vmelehin\AppData\Local\Temp\ccvX1GN5.s:996    .text:00000278 nrf24_receive
C:\Users\vmelehin\AppData\Local\Temp\ccvX1GN5.s:1536   .bss:00000026 rx_buf
C:\Users\vmelehin\AppData\Local\Temp\ccvX1GN5.s:1526   .bss:00000005 f_rx
C:\Users\vmelehin\AppData\Local\Temp\ccvX1GN5.s:1040   .text.startup:00000000 main
C:\Users\vmelehin\AppData\Local\Temp\ccvX1GN5.s:1503   .bss:00000000 f_wait
C:\Users\vmelehin\AppData\Local\Temp\ccvX1GN5.s:1531   .bss:00000006 tx_buf
C:\Users\vmelehin\AppData\Local\Temp\ccvX1GN5.s:1514   .bss:00000002 address
                            *COM*:00000040 gBuffer
                            *COM*:00000001 val
C:\Users\vmelehin\AppData\Local\Temp\ccvX1GN5.s:1509   .bss:00000001 device
                            *COM*:00000014 buf
                            *COM*:00000001 f_send
C:\Users\vmelehin\AppData\Local\Temp\ccvX1GN5.s:1521   .bss:00000004 f_tx

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
