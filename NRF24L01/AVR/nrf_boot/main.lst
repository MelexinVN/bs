   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
 134               	.global	port_init
 136               	port_init:
   1:main.c        **** 
   2:main.c        **** #define F_CPU 8000000UL
   3:main.c        **** 
   4:main.c        **** #include <avr/io.h>
   5:main.c        **** #include <avr/interrupt.h>
   6:main.c        **** #include <util/delay.h>
   7:main.c        **** #include <avr/wdt.h>
   8:main.c        **** #include <stdio.h>
   9:main.c        **** #include <stdlib.h>
  10:main.c        **** #include <string.h>
  11:main.c        **** #include <stdint.h>
  12:main.c        **** #include <avr/boot.h>
  13:main.c        **** #include <avr/pgmspace.h>
  14:main.c        **** #include <avr/eeprom.h>
  15:main.c        **** #include "chipdef.h"
  16:main.c        **** 
  17:main.c        **** #define DISABLE_WDT_AT_STARTUP
  18:main.c        **** #define BUT_ADDR 		0x07				//адрес кнопки
  19:main.c        **** #define RESET 			0xFF				//команда сброса
  20:main.c        **** #define NOT_PUSHED 		0xFFFFFFFF			//сообщение "кнопка не нажата"
  21:main.c        **** 
  22:main.c        **** #define LED_Pin PORTD6			//пин светодиода
  23:main.c        **** #define LED_GPIO_Port PORTD		//порт светодиода
  24:main.c        **** #define IRQ_Pin PORTD2			//пин прерывания радиомодуля
  25:main.c        **** #define IRQ_GPIO_Port PORTD2	//порт прерывания радиомодуля
  26:main.c        **** #define CE_Pin PORTB0			//пин CE
  27:main.c        **** #define CE_GPIO_Port PORTB		//порт CE
  28:main.c        **** #define CSN_Pin PORTD7			//пин CSN
  29:main.c        **** #define CSN_GPIO_Port PORTD		//порт CSN
  30:main.c        **** 
  31:main.c        **** #define EXIT_WDT_TIME   WDTO_250MS
  32:main.c        **** 
  33:main.c        **** 
  34:main.c        **** /* Выдержка для START_WAIT mode ( t = WAIT_TIME * 10ms ) */
  35:main.c        **** #define WAIT_VALUE 400 /* сейчас: 300*10ms = 3000ms = 3sec */
  36:main.c        **** 
  37:main.c        **** 
  38:main.c        **** //------------------------------------------------
  39:main.c        **** #define CS_ON()			CSN_GPIO_Port&=~(1<<CSN_Pin)
  40:main.c        **** #define CS_OFF()		CSN_GPIO_Port|=(1<<CSN_Pin)
  41:main.c        **** #define CE_RESET()		CE_GPIO_Port&=~(1<<CE_Pin)
  42:main.c        **** #define CE_SET()		CE_GPIO_Port|=(1<<CE_Pin)
  43:main.c        **** #define IRQ()			IRQ_Pin&(1<<IRQ_Pin)
  44:main.c        **** #define LED_ON()		LED_GPIO_Port|=(1<<LED_Pin)
  45:main.c        **** #define LED_OFF()		LED_GPIO_Port&=~(1<<LED_Pin)
  46:main.c        **** //------------------------------------------------
  47:main.c        **** #define ACTIVATE 		0x50 //
  48:main.c        **** #define RD_RX_PLOAD		0x61 // Define RX payload register address
  49:main.c        **** #define WR_TX_PLOAD		0xA0 // Define TX payload register address
  50:main.c        **** #define FLUSH_TX 		0xE1
  51:main.c        **** #define FLUSH_RX 		0xE2
  52:main.c        **** //------------------------------------------------
  53:main.c        **** #define CONFIG 			0x00 //'Config' register address
  54:main.c        **** #define EN_AA 			0x01 //'Enable Auto Acknowledgment' register address
  55:main.c        **** #define EN_RXADDR 		0x02 //'Enabled RX addresses' register address
  56:main.c        **** #define SETUP_AW 		0x03 //'Setup address width' register address
  57:main.c        **** #define SETUP_RETR 		0x04 //'Setup Auto. Retrans' register address
  58:main.c        **** #define RF_CH 			0x05 //'RF channel' register address
  59:main.c        **** #define RF_SETUP 		0x06 //'RF setup' register address
  60:main.c        **** #define STATUS 			0x07 //'Status' register address
  61:main.c        **** #define OBSERVE_TX 		0x08 //'Transmit observe' register
  62:main.c        **** #define RX_ADDR_P0 		0x0A //'RX address pipe0' register address
  63:main.c        **** #define RX_ADDR_P1 		0x0B //'RX address pipe1' register address
  64:main.c        **** #define TX_ADDR 		0x10 //'TX address' register address
  65:main.c        **** #define RX_PW_P0 		0x11 //'RX payload width, pipe0' register address
  66:main.c        **** #define RX_PW_P1 		0x12 //'RX payload width, pipe1' register address
  67:main.c        **** #define FIFO_STATUS		0x17 //'FIFO Status Register' register address
  68:main.c        **** #define DYNPD 			0x1C
  69:main.c        **** #define FEATURE 		0x1D
  70:main.c        **** //------------------------------------------------
  71:main.c        **** #define PRIM_RX 		0x00 //RX/TX control (1: PRX, 0: PTX)
  72:main.c        **** #define PWR_UP 			0x01 //1: POWER UP, 0:POWER DOWN
  73:main.c        **** #define RX_DR 			0x40 //Data Ready RX FIFO interrupt
  74:main.c        **** #define TX_DS 			0x20 //Data Sent TX FIFO interrupt
  75:main.c        **** #define MAX_RT 			0x10 //Maximum number of TX retransmits interrupt
  76:main.c        **** //------------------------------------------------
  77:main.c        **** #define W_REGISTER 		0x20 //запись в регистр
  78:main.c        **** //------------------------------------------------
  79:main.c        **** #define TX_ADR_WIDTH 3						//размер адреса передачи
  80:main.c        **** #define TX_PLOAD_WIDTH 32					//размер полезной нагрузки
  81:main.c        **** //максимальное число байт, чтобы при добавлении новых функций не переделывать задержки
  82:main.c        **** 
  83:main.c        **** #define BUT									//выбор устройства: BAZ - база, BUT - кнопка
  84:main.c        **** 
  85:main.c        **** #ifdef BAS	//если база
  86:main.c        **** uint8_t TX_ADDRESS0[TX_ADR_WIDTH] = {0xb7,0xb5,0xa1};	//адрес 0
  87:main.c        **** uint8_t TX_ADDRESS1[TX_ADR_WIDTH] = {0xb5,0xb5,0xa1};	//адрес 1
  88:main.c        **** #endif
  89:main.c        **** 
  90:main.c        **** #ifdef BUT	//если кнопка
  91:main.c        **** uint8_t TX_ADDRESS0[TX_ADR_WIDTH] = {0xb5,0xb5,0xa1};	//адрес 0
  92:main.c        **** uint8_t TX_ADDRESS1[TX_ADR_WIDTH] = {0xb7,0xb5,0xa1};	//адрес 1
  93:main.c        **** #endif
  94:main.c        **** 
  95:main.c        **** uint8_t rx_buf[TX_PLOAD_WIDTH] = {0};				//буфер приема
  96:main.c        **** uint8_t tx_buf[TX_PLOAD_WIDTH] = {0};				//буфер передачи
  97:main.c        **** 
  98:main.c        **** volatile uint8_t f_rx = 0, f_tx = 0;				//флаги приема и передачи
  99:main.c        **** 
 100:main.c        **** uint8_t f_send;								//флаг отправки
 101:main.c        **** 
 102:main.c        **** uint8_t buf1[20];							//буфер
 103:main.c        **** uint16_t address;
 104:main.c        **** uint8_t device, val;
 105:main.c        **** 
 106:main.c        **** 
 107:main.c        **** void nrf24_init(void);
 108:main.c        **** uint8_t NRF24_ReadReg(uint8_t addr);
 109:main.c        **** void NRF24_Read_Buf(uint8_t addr,uint8_t *pBuf,uint8_t bytes);
 110:main.c        **** uint8_t NRF24L01_Send(uint8_t *pBuf);
 111:main.c        **** void nrf24l01_receive(void);
 112:main.c        **** void nrf_boot_receive(void);
 113:main.c        **** void IRQ_Callback(void);
 114:main.c        **** 
 115:main.c        **** 
 116:main.c        **** 
 117:main.c        **** uint8_t gBuffer[SPM_PAGESIZE];
 118:main.c        **** uint16_t address = 0;
 119:main.c        **** uint8_t device = 0, val;
 120:main.c        **** 
 121:main.c        **** 
 122:main.c        **** 
 123:main.c        **** 
 124:main.c        **** ISR(INT0_vect)
 125:main.c        **** {
 126:main.c        **** 	IRQ_Callback();
 127:main.c        **** }
 128:main.c        **** 
 129:main.c        **** 
 130:main.c        **** 
 131:main.c        **** void port_init(void)//Инициализация портов
 132:main.c        **** {
 138               	.LM0:
 139               	.LFBB1:
 140               	/* prologue: function */
 141               	/* frame size = 0 */
 142               	/* stack size = 0 */
 143               	.L__stack_usage = 0
 133:main.c        **** 	// Input/Output Ports initialization
 134:main.c        **** 	// Port B initialization
 135:main.c        **** 	// Function: Bit7=In Bit6=In Bit5=Out Bit4=In Bit3=Out Bit2=Out Bit1=In Bit0=Out
 136:main.c        **** 	DDRB=(0<<DDB7) | (0<<DDB6) | (1<<DDB5) | (0<<DDB4) | (1<<DDB3) | (1<<DDB2) | (0<<DDB1) | (1<<DDB0)
 145               	.LM1:
 146 0000 8DE2      		ldi r24,lo8(45)
 147 0002 87BB      		out 0x17,r24
 137:main.c        **** 	// State: Bit7=T Bit6=T Bit5=0 Bit4=T Bit3=0 Bit2=0 Bit1=T Bit0=0
 138:main.c        **** 	PORTB=(0<<PORTB7) | (0<<PORTB6) | (0<<PORTB5) | (0<<PORTB4) | (0<<PORTB3) | (0<<PORTB2) | (0<<PORT
 149               	.LM2:
 150 0004 81E0      		ldi r24,lo8(1)
 151 0006 88BB      		out 0x18,r24
 139:main.c        **** 
 140:main.c        **** 	// Port C initialization
 141:main.c        **** 	// Function: Bit6=In Bit5=In Bit4=In Bit3=In Bit2=In Bit1=In Bit0=In
 142:main.c        **** 	DDRC=(0<<DDC6) | (0<<DDC5) | (0<<DDC4) | (0<<DDC3) | (0<<DDC2) | (0<<DDC1) | (0<<DDC0);
 153               	.LM3:
 154 0008 14BA      		out 0x14,__zero_reg__
 143:main.c        **** 	// State: Bit6=T Bit5=T Bit4=T Bit3=T Bit2=T Bit1=T Bit0=T
 144:main.c        **** 	PORTC=(0<<PORTC6) | (0<<PORTC5) | (0<<PORTC4) | (0<<PORTC3) | (0<<PORTC2) | (0<<PORTC1) | (0<<PORT
 156               	.LM4:
 157 000a 15BA      		out 0x15,__zero_reg__
 145:main.c        **** 
 146:main.c        **** 	// Port D initialization
 147:main.c        **** 	// Function: Bit7=Out Bit6=Out Bit5=In Bit4=In Bit3=In Bit2=In Bit1=In Bit0=In
 148:main.c        **** 	DDRD=(1<<DDD7) | (1<<DDD6) | (0<<DDD5) | (0<<DDD4) | (0<<DDD3) | (0<<DDD2) | (0<<DDD1) | (0<<DDD0)
 159               	.LM5:
 160 000c 80EC      		ldi r24,lo8(-64)
 161 000e 81BB      		out 0x11,r24
 149:main.c        **** 	// State: Bit7=0 Bit6=0 Bit5=T Bit4=T Bit3=P Bit2=T Bit1=T Bit0=T
 150:main.c        **** 	PORTD=(1<<PORTD7) | (1<<PORTD6) | (0<<PORTD5) | (0<<PORTD4) | (1<<PORTD3) | (0<<PORTD2) | (0<<PORT
 163               	.LM6:
 164 0010 88EC      		ldi r24,lo8(-56)
 165 0012 82BB      		out 0x12,r24
 166 0014 0895      		ret
 168               	.Lscope1:
 170               	.global	interrupt_init
 172               	interrupt_init:
 151:main.c        **** }
 152:main.c        **** 
 153:main.c        **** 
 154:main.c        **** void interrupt_init(void)
 155:main.c        **** {
 174               	.LM7:
 175               	.LFBB2:
 176               	/* prologue: function */
 177               	/* frame size = 0 */
 178               	/* stack size = 0 */
 179               	.L__stack_usage = 0
 156:main.c        **** 	// External Interrupt(s) initialization
 157:main.c        **** 	// INT0: On
 158:main.c        **** 	// INT0 Mode: Falling Edge
 159:main.c        **** 	// INT1: On
 160:main.c        **** 	// INT1 Mode: Falling Edge
 161:main.c        **** 	GICR|=(1<<INT1) | (1<<INT0);
 181               	.LM8:
 182 0016 8BB7      		in r24,0x3b
 183 0018 806C      		ori r24,lo8(-64)
 184 001a 8BBF      		out 0x3b,r24
 162:main.c        **** 	MCUCR=(1<<ISC11) | (0<<ISC10) | (1<<ISC01) | (0<<ISC00);
 186               	.LM9:
 187 001c 8AE0      		ldi r24,lo8(10)
 188 001e 85BF      		out 0x35,r24
 163:main.c        **** 	GIFR=(1<<INTF1) | (1<<INTF0);
 190               	.LM10:
 191 0020 80EC      		ldi r24,lo8(-64)
 192 0022 8ABF      		out 0x3a,r24
 164:main.c        **** 	// Timer(s)/Counter(s) Interrupt(s) initialization
 165:main.c        **** 	TIMSK=(0<<OCIE2) | (0<<TOIE2) | (0<<TICIE1) | (1<<OCIE1A) | (0<<OCIE1B) | (0<<TOIE1) | (1<<TOIE0);
 194               	.LM11:
 195 0024 81E1      		ldi r24,lo8(17)
 196 0026 89BF      		out 0x39,r24
 197 0028 0895      		ret
 199               	.Lscope2:
 201               	.global	spi_init
 203               	spi_init:
 166:main.c        **** }
 167:main.c        **** 
 168:main.c        **** 
 169:main.c        **** //инициализация SPI
 170:main.c        **** void spi_init(void)
 171:main.c        **** {
 205               	.LM12:
 206               	.LFBB3:
 207               	/* prologue: function */
 208               	/* frame size = 0 */
 209               	/* stack size = 0 */
 210               	.L__stack_usage = 0
 172:main.c        **** 	DDRB |= ((1<<PORTB2)|(1<<PORTB3)|(1<<PORTB5)); //ножки SPI на выход
 212               	.LM13:
 213 002a 87B3      		in r24,0x17
 214 002c 8C62      		ori r24,lo8(44)
 215 002e 87BB      		out 0x17,r24
 173:main.c        **** 	PORTB &= ~((1<<PORTB2)|(1<<PORTB3)|(1<<PORTB5)); //низкий уровень
 217               	.LM14:
 218 0030 88B3      		in r24,0x18
 219 0032 837D      		andi r24,lo8(-45)
 220 0034 88BB      		out 0x18,r24
 174:main.c        **** 	SPCR=(0<<SPIE) | (1<<SPE) | (0<<DORD) | (1<<MSTR) | (0<<CPOL) | (0<<CPHA) | (0<<SPR1) | (0<<SPR0);
 222               	.LM15:
 223 0036 80E5      		ldi r24,lo8(80)
 224 0038 8DB9      		out 0xd,r24
 225 003a 0895      		ret
 227               	.Lscope3:
 230               	.global	spi_sendByte
 232               	spi_sendByte:
 175:main.c        **** }
 176:main.c        **** //отправка байта
 177:main.c        **** void spi_sendByte(uint8_t byte)
 178:main.c        **** {
 234               	.LM16:
 235               	.LFBB4:
 236               	/* prologue: function */
 237               	/* frame size = 0 */
 238               	/* stack size = 0 */
 239               	.L__stack_usage = 0
 179:main.c        **** 	SPDR = byte;				//записываем байт в регистр
 241               	.LM17:
 242 003c 8FB9      		out 0xf,r24
 243               	.L5:
 180:main.c        **** 	while(!(SPSR & (1<<SPIF)));	//подождем пока данные передадутся
 245               	.LM18:
 246 003e 779B      		sbis 0xe,7
 247 0040 00C0      		rjmp .L5
 248               	/* epilogue start */
 181:main.c        **** }
 250               	.LM19:
 251 0042 0895      		ret
 253               	.Lscope4:
 256               	.global	spi_changeByte
 258               	spi_changeByte:
 182:main.c        **** //прием/отправка байта
 183:main.c        **** uint8_t spi_changeByte(uint8_t byte)
 184:main.c        **** {
 260               	.LM20:
 261               	.LFBB5:
 262               	/* prologue: function */
 263               	/* frame size = 0 */
 264               	/* stack size = 0 */
 265               	.L__stack_usage = 0
 185:main.c        **** 	SPDR = byte;				//записываем байт в регистр
 267               	.LM21:
 268 0044 8FB9      		out 0xf,r24
 269               	.L9:
 186:main.c        **** 	while(!(SPSR & (1<<SPIF)));	//подождем пока данные передадутся (обменяются)
 271               	.LM22:
 272 0046 779B      		sbis 0xe,7
 273 0048 00C0      		rjmp .L9
 187:main.c        **** 	return SPDR;				//возвращаем принятое значение
 275               	.LM23:
 276 004a 8FB1      		in r24,0xf
 188:main.c        **** }
 278               	.LM24:
 279 004c 0895      		ret
 281               	.Lscope5:
 284               	.global	NRF24_ReadReg
 286               	NRF24_ReadReg:
 189:main.c        **** 
 190:main.c        **** //функция чтения регистра модуля
 191:main.c        **** uint8_t NRF24_ReadReg(uint8_t addr)
 192:main.c        **** {
 288               	.LM25:
 289               	.LFBB6:
 290 004e CF93      		push r28
 291               	/* prologue: function */
 292               	/* frame size = 0 */
 293               	/* stack size = 1 */
 294               	.L__stack_usage = 1
 295 0050 C82F      		mov r28,r24
 193:main.c        **** 	uint8_t dt=0, cmd;								//переменные данных и команды
 194:main.c        **** 	CS_ON();											//ногу cs к земле
 297               	.LM26:
 298 0052 9798      		cbi 0x12,7
 195:main.c        **** 	dt = spi_changeByte(addr);						//Прием/отправкадайта адреса регистра
 300               	.LM27:
 301 0054 00D0      		rcall spi_changeByte
 196:main.c        **** 	//если адрес равен адрес регистра статус то и возварщаем его состояние
 197:main.c        **** 	if (addr!=STATUS)//а если не равен
 303               	.LM28:
 304 0056 C730      		cpi r28,lo8(7)
 305 0058 01F0      		breq .L12
 198:main.c        **** 	{
 199:main.c        **** 		cmd=0xFF;									//команда NOP для получения данных
 200:main.c        **** 		dt = spi_changeByte(cmd);					//
 307               	.LM29:
 308 005a 8FEF      		ldi r24,lo8(-1)
 309 005c 00D0      		rcall spi_changeByte
 310               	.L12:
 201:main.c        **** 	}
 202:main.c        **** 	CS_OFF();											//поднимаем ногу CS
 312               	.LM30:
 313 005e 979A      		sbi 0x12,7
 314               	/* epilogue start */
 203:main.c        **** 	return dt;	//возвращаемое значение
 204:main.c        **** }
 316               	.LM31:
 317 0060 CF91      		pop r28
 318 0062 0895      		ret
 323               	.Lscope6:
 327               	.global	NRF24_WriteReg
 329               	NRF24_WriteReg:
 205:main.c        **** //------------------------------------------------
 206:main.c        **** //функция записи регистра в модуль
 207:main.c        **** void NRF24_WriteReg(uint8_t addr, uint8_t dt)
 208:main.c        **** {
 331               	.LM32:
 332               	.LFBB7:
 333 0064 CF93      		push r28
 334               	/* prologue: function */
 335               	/* frame size = 0 */
 336               	/* stack size = 1 */
 337               	.L__stack_usage = 1
 338 0066 C62F      		mov r28,r22
 209:main.c        **** 	addr |= W_REGISTER;//включим бит записи в адрес
 210:main.c        **** 	CS_ON();
 340               	.LM33:
 341 0068 9798      		cbi 0x12,7
 211:main.c        **** 	spi_sendByte(addr);									//
 343               	.LM34:
 344 006a 8062      		ori r24,lo8(32)
 345 006c 00D0      		rcall spi_sendByte
 212:main.c        **** 	spi_sendByte(dt);										//
 347               	.LM35:
 348 006e 8C2F      		mov r24,r28
 349 0070 00D0      		rcall spi_sendByte
 213:main.c        **** 	CS_OFF();
 351               	.LM36:
 352 0072 979A      		sbi 0x12,7
 353               	/* epilogue start */
 214:main.c        **** }
 355               	.LM37:
 356 0074 CF91      		pop r28
 357 0076 0895      		ret
 359               	.Lscope7:
 361               	.global	NRF24_ToggleFeatures
 363               	NRF24_ToggleFeatures:
 215:main.c        **** //------------------------------------------------
 216:main.c        **** void NRF24_ToggleFeatures(void)							//активация команд R_RX_PL_WID, W_ACK_PAYLOAD и W_TX_PAYLOAD_
 217:main.c        **** {	//есть в даташите "без плюса"
 365               	.LM38:
 366               	.LFBB8:
 367               	/* prologue: function */
 368               	/* frame size = 0 */
 369               	/* stack size = 0 */
 370               	.L__stack_usage = 0
 218:main.c        **** 	uint8_t dt[1] = {ACTIVATE};
 219:main.c        **** 	CS_ON();
 372               	.LM39:
 373 0078 9798      		cbi 0x12,7
 220:main.c        **** 	spi_sendByte(dt[0]);
 375               	.LM40:
 376 007a 80E5      		ldi r24,lo8(80)
 377 007c 00D0      		rcall spi_sendByte
 378               	.LBB34:
 379               	.LBB35:
 381               	.Ltext1:
   1:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    All rights reserved.
   5:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
   6:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
   9:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  12:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      distribution.
  16:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  17:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  21:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  33:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /* $Id$ */
  34:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  35:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  38:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #  endif
  42:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  44:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <inttypes.h>
  45:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <math.h>
  47:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  48:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \file */
  49:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \code
  51:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     #include <util/delay.h>
  54:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \endcode
  55:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  56:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     used.
  60:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  61:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  70:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     routines linked into the application.
  78:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  79:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  83:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** */
  84:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  85:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
  89:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  90:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef F_CPU
  91:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \ingroup util_delay
  94:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \def F_CPU
  95:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  97:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 103:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     integer value.
 107:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****  */
 108:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 110:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 111:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 114:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 115:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #  include <math.h>
 119:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 120:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 121:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /**
 122:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \ingroup util_delay
 123:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 124:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 126:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 129:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 131:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 137:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 142:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    microseconds of delay.
 146:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 147:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    respectively.
 151:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 152:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \note
 153:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 154:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    not available to the compiler then.
 163:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 164:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****  */
 165:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** void
 166:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** _delay_ms(double __ms)
 167:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** {
 168:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	double __tmp ;
 169:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 173:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 176:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 179:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 182:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#else
 183:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		//round up by default
 184:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#endif
 186:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 187:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 189:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #else
 190:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	uint16_t __ticks;
 191:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	if (__tmp < 1.0)
 193:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks = 1;
 194:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	else if (__tmp > 65535)
 195:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	{
 196:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		while(__ticks)
 199:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		{
 200:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 			// wait 1/10 ms
 201:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 			__ticks --;
 203:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		}
 204:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		return;
 205:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	}
 206:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	else
 207:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks = (uint16_t)__tmp;
 208:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	_delay_loop_2(__ticks);
 209:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 210:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** }
 211:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 212:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /**
 213:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \ingroup util_delay
 214:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 215:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 217:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 218:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 220:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 222:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    will not be informed about this case.
 225:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 226:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflow results in
 229:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    no delay i.e., 0us.
 230:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 231:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __us
 234:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    microseconds of delay.
 235:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 236:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    respectively.
 240:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 241:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \note
 242:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 243:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 244:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 246:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 248:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 249:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    not available to the compiler then.
 252:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 253:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****  */
 254:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** void
 255:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** _delay_us(double __us)
 256:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** {
 257:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	double __tmp ;
 258:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   __STDC_HOSTED__
 261:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 262:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 265:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 268:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 271:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#else
 272:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		//round up by default
 273:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#endif
 275:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 276:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 383               	.LM41:
 384 007e 82E0      		ldi r24,lo8(2)
 385 0080 8A95      	1:	dec r24
 386 0082 01F4      		brne 1b
 387 0084 00C0      		rjmp .
 388               	.LBE35:
 389               	.LBE34:
 391               	.Ltext2:
 221:main.c        **** 	_delay_us(1);
 222:main.c        **** 	dt[0] = 0x73;
 223:main.c        **** 	spi_sendByte(dt[0]);
 393               	.LM42:
 394 0086 83E7      		ldi r24,lo8(115)
 395 0088 00D0      		rcall spi_sendByte
 224:main.c        **** 	CS_OFF();
 397               	.LM43:
 398 008a 979A      		sbi 0x12,7
 399 008c 0895      		ret
 401               	.Lscope8:
 405               	.global	NRF24_Read_Buf
 407               	NRF24_Read_Buf:
 225:main.c        **** }
 226:main.c        **** //-----------------------------------------------
 227:main.c        **** void NRF24_Read_Buf(uint8_t addr,uint8_t *pBuf,uint8_t bytes)
 228:main.c        **** {//чтение буфера (несколько байт)
 409               	.LM44:
 410               	.LFBB9:
 411 008e EF92      		push r14
 412 0090 FF92      		push r15
 413 0092 0F93      		push r16
 414 0094 1F93      		push r17
 415 0096 CF93      		push r28
 416 0098 DF93      		push r29
 417               	/* prologue: function */
 418               	/* frame size = 0 */
 419               	/* stack size = 6 */
 420               	.L__stack_usage = 6
 421 009a 182F      		mov r17,r24
 422 009c 062F      		mov r16,r22
 423 009e E72E      		mov r14,r23
 424 00a0 F42E      		mov r15,r20
 229:main.c        **** 	CS_ON();
 426               	.LM45:
 427 00a2 9798      		cbi 0x12,7
 230:main.c        **** 	spi_sendByte(addr);
 429               	.LM46:
 430 00a4 00D0      		rcall spi_sendByte
 431 00a6 C02F      		mov r28,r16
 432 00a8 DE2D      		mov r29,r14
 433 00aa CE01      		movw r24,r28
 434 00ac 8F0D      		add r24,r15
 435 00ae 911D      		adc r25,__zero_reg__
 436 00b0 7C01      		movw r14,r24
 437               	.L19:
 438               	.LBB36:
 231:main.c        **** 	for (uint8_t i = 0 ; i < bytes ; i++) 		//для нужного количества байт
 440               	.LM47:
 441 00b2 CE15      		cp r28,r14
 442 00b4 DF05      		cpc r29,r15
 443 00b6 01F0      		breq .L21
 232:main.c        **** 	{																					//
 233:main.c        **** 		pBuf[i] = spi_changeByte(addr);
 445               	.LM48:
 446 00b8 812F      		mov r24,r17
 447 00ba 00D0      		rcall spi_changeByte
 448 00bc 8993      		st Y+,r24
 449 00be 00C0      		rjmp .L19
 450               	.L21:
 451               	.LBE36:
 234:main.c        **** 	}
 235:main.c        **** 	CS_OFF();
 453               	.LM49:
 454 00c0 979A      		sbi 0x12,7
 455               	/* epilogue start */
 236:main.c        **** }
 457               	.LM50:
 458 00c2 DF91      		pop r29
 459 00c4 CF91      		pop r28
 460 00c6 1F91      		pop r17
 461 00c8 0F91      		pop r16
 462 00ca FF90      		pop r15
 463 00cc EF90      		pop r14
 464 00ce 0895      		ret
 466               	.Lscope9:
 470               	.global	NRF24_Write_Buf
 472               	NRF24_Write_Buf:
 237:main.c        **** //------------------------------------------------
 238:main.c        **** void NRF24_Write_Buf(uint8_t addr,uint8_t *pBuf,uint8_t bytes)
 239:main.c        **** {//запись буфера
 474               	.LM51:
 475               	.LFBB10:
 476 00d0 FF92      		push r15
 477 00d2 0F93      		push r16
 478 00d4 1F93      		push r17
 479 00d6 CF93      		push r28
 480 00d8 DF93      		push r29
 481               	/* prologue: function */
 482               	/* frame size = 0 */
 483               	/* stack size = 5 */
 484               	.L__stack_usage = 5
 485 00da F62E      		mov r15,r22
 486 00dc 072F      		mov r16,r23
 487 00de 142F      		mov r17,r20
 240:main.c        **** 	addr |= W_REGISTER;//включим бит записи в адрес
 241:main.c        **** 	CS_ON();
 489               	.LM52:
 490 00e0 9798      		cbi 0x12,7
 242:main.c        **** 	spi_sendByte(addr);
 492               	.LM53:
 493 00e2 8062      		ori r24,lo8(32)
 494 00e4 00D0      		rcall spi_sendByte
 495               	.LBB37:
 496               	.LBB38:
 498               	.Ltext3:
 500               	.LM54:
 501 00e6 82E0      		ldi r24,lo8(2)
 502 00e8 8A95      	1:	dec r24
 503 00ea 01F4      		brne 1b
 504 00ec 00C0      		rjmp .
 505 00ee CF2D      		mov r28,r15
 506 00f0 D02F      		mov r29,r16
 507 00f2 CE01      		movw r24,r28
 508 00f4 810F      		add r24,r17
 509 00f6 911D      		adc r25,__zero_reg__
 510 00f8 8C01      		movw r16,r24
 511               	.L23:
 512               	.LBE38:
 513               	.LBE37:
 514               	.LBB39:
 516               	.Ltext4:
 243:main.c        **** 	_delay_us(1);
 244:main.c        **** 	for (uint8_t i = 0 ; i < bytes ; i++) 		//для нужного количества байт
 518               	.LM55:
 519 00fa C017      		cp r28,r16
 520 00fc D107      		cpc r29,r17
 521 00fe 01F0      		breq .L25
 245:main.c        **** 	{
 246:main.c        **** 		spi_sendByte(pBuf[i]);
 523               	.LM56:
 524 0100 8991      		ld r24,Y+
 525 0102 00D0      		rcall spi_sendByte
 526 0104 00C0      		rjmp .L23
 527               	.L25:
 528               	.LBE39:
 247:main.c        **** 	}
 248:main.c        **** 	CS_OFF();
 530               	.LM57:
 531 0106 979A      		sbi 0x12,7
 532               	/* epilogue start */
 249:main.c        **** }
 534               	.LM58:
 535 0108 DF91      		pop r29
 536 010a CF91      		pop r28
 537 010c 1F91      		pop r17
 538 010e 0F91      		pop r16
 539 0110 FF90      		pop r15
 540 0112 0895      		ret
 542               	.Lscope10:
 544               	.global	NRF24_FlushRX
 546               	NRF24_FlushRX:
 250:main.c        **** //------------------------------------------------
 251:main.c        **** void NRF24_FlushRX(void)
 252:main.c        **** {//очистка буфера приема
 548               	.LM59:
 549               	.LFBB11:
 550               	/* prologue: function */
 551               	/* frame size = 0 */
 552               	/* stack size = 0 */
 553               	.L__stack_usage = 0
 253:main.c        **** 	uint8_t dt[1] = {FLUSH_RX};
 254:main.c        **** 	CS_ON();
 555               	.LM60:
 556 0114 9798      		cbi 0x12,7
 255:main.c        **** 	spi_sendByte(dt[0]);
 558               	.LM61:
 559 0116 82EE      		ldi r24,lo8(-30)
 560 0118 00D0      		rcall spi_sendByte
 561               	.LBB40:
 562               	.LBB41:
 564               	.Ltext5:
 566               	.LM62:
 567 011a 82E0      		ldi r24,lo8(2)
 568 011c 8A95      	1:	dec r24
 569 011e 01F4      		brne 1b
 570 0120 00C0      		rjmp .
 571               	.LBE41:
 572               	.LBE40:
 574               	.Ltext6:
 256:main.c        **** 	_delay_us(1); //пауза в микросекунду для завершения процесса
 257:main.c        **** 	CS_OFF();
 576               	.LM63:
 577 0122 979A      		sbi 0x12,7
 578 0124 0895      		ret
 580               	.Lscope11:
 582               	.global	NRF24_FlushTX
 584               	NRF24_FlushTX:
 258:main.c        **** }
 259:main.c        **** //------------------------------------------------
 260:main.c        **** void NRF24_FlushTX(void)
 261:main.c        **** {//очистка буфера передачи
 586               	.LM64:
 587               	.LFBB12:
 588               	/* prologue: function */
 589               	/* frame size = 0 */
 590               	/* stack size = 0 */
 591               	.L__stack_usage = 0
 262:main.c        **** 	uint8_t dt[1] = {FLUSH_TX};
 263:main.c        **** 	CS_ON();
 593               	.LM65:
 594 0126 9798      		cbi 0x12,7
 264:main.c        **** 	spi_sendByte(dt[0]);
 596               	.LM66:
 597 0128 81EE      		ldi r24,lo8(-31)
 598 012a 00D0      		rcall spi_sendByte
 599               	.LBB42:
 600               	.LBB43:
 602               	.Ltext7:
 604               	.LM67:
 605 012c 82E0      		ldi r24,lo8(2)
 606 012e 8A95      	1:	dec r24
 607 0130 01F4      		brne 1b
 608 0132 00C0      		rjmp .
 609               	.LBE43:
 610               	.LBE42:
 612               	.Ltext8:
 265:main.c        **** 	_delay_us(1); //пауза в микросекунду для завершения процесса
 266:main.c        **** 	CS_OFF();
 614               	.LM68:
 615 0134 979A      		sbi 0x12,7
 616 0136 0895      		ret
 618               	.Lscope12:
 620               	.global	NRF24L01_RX_Mode
 622               	NRF24L01_RX_Mode:
 267:main.c        **** }
 268:main.c        **** //------------------------------------------------
 269:main.c        **** void NRF24L01_RX_Mode(void)
 270:main.c        **** {//режим приемника
 624               	.LM69:
 625               	.LFBB13:
 626               	/* prologue: function */
 627               	/* frame size = 0 */
 628               	/* stack size = 0 */
 629               	.L__stack_usage = 0
 271:main.c        **** 	uint8_t regval=0x00;
 272:main.c        **** 	regval = NRF24_ReadReg(CONFIG);	//сохраняем значение регистра конфигурации
 631               	.LM70:
 632 0138 80E0      		ldi r24,0
 633 013a 00D0      		rcall NRF24_ReadReg
 273:main.c        **** 	//разбудим модуль и переведём его в режим приёмника, включив биты PWR_UP и PRIM_RX
 274:main.c        **** 	regval |= (1<<PWR_UP)|(1<<PRIM_RX);
 275:main.c        **** 	NRF24_WriteReg(CONFIG,regval);	//возвращаем значение регистра статуса
 635               	.LM71:
 636 013c 682F      		mov r22,r24
 637 013e 6360      		ori r22,lo8(3)
 638 0140 80E0      		ldi r24,0
 639 0142 00D0      		rcall NRF24_WriteReg
 276:main.c        **** 	
 277:main.c        **** 	NRF24_Write_Buf(TX_ADDR, TX_ADDRESS1, TX_ADR_WIDTH);		//записываем  адрес передатчика
 641               	.LM72:
 642 0144 43E0      		ldi r20,lo8(3)
 643 0146 60E0      		ldi r22,lo8(TX_ADDRESS1)
 644 0148 70E0      		ldi r23,hi8(TX_ADDRESS1)
 645 014a 80E1      		ldi r24,lo8(16)
 646 014c 00D0      		rcall NRF24_Write_Buf
 278:main.c        **** 	NRF24_Write_Buf(RX_ADDR_P0, TX_ADDRESS1, TX_ADR_WIDTH);	//записываем адрес приемника
 648               	.LM73:
 649 014e 43E0      		ldi r20,lo8(3)
 650 0150 60E0      		ldi r22,lo8(TX_ADDRESS1)
 651 0152 70E0      		ldi r23,hi8(TX_ADDRESS1)
 652 0154 8AE0      		ldi r24,lo8(10)
 653 0156 00D0      		rcall NRF24_Write_Buf
 279:main.c        **** 	
 280:main.c        **** 	CE_SET();
 655               	.LM74:
 656 0158 C09A      		sbi 0x18,0
 657               	.LBB44:
 658               	.LBB45:
 660               	.Ltext9:
 662               	.LM75:
 663 015a 8BE2      		ldi r24,lo8(299)
 664 015c 91E0      		ldi r25,hi8(299)
 665 015e 0197      	1:	sbiw r24,1
 666 0160 01F4      		brne 1b
 667 0162 00C0      		rjmp .
 668 0164 0000      		nop
 669               	.LBE45:
 670               	.LBE44:
 672               	.Ltext10:
 281:main.c        **** 	_delay_us(150); //Задержка минимум 130 мкс
 282:main.c        **** 	// Flush buffers
 283:main.c        **** 	NRF24_FlushRX();
 674               	.LM76:
 675 0166 00D0      		rcall NRF24_FlushRX
 284:main.c        **** 	NRF24_FlushTX();
 677               	.LM77:
 678 0168 00C0      		rjmp NRF24_FlushTX
 680               	.Lscope13:
 683               	.global	NRF24L01_TX_Mode
 685               	NRF24L01_TX_Mode:
 285:main.c        **** }
 286:main.c        **** //------------------------------------------------
 287:main.c        **** void NRF24L01_TX_Mode(uint8_t *pBuf)
 288:main.c        **** {//режим передатчика
 687               	.LM78:
 688               	.LFBB14:
 689               	/* prologue: function */
 690               	/* frame size = 0 */
 691               	/* stack size = 0 */
 692               	.L__stack_usage = 0
 289:main.c        **** 	NRF24_Write_Buf(TX_ADDR, TX_ADDRESS0, TX_ADR_WIDTH);		//записываем адрес передатчика
 694               	.LM79:
 695 016a 43E0      		ldi r20,lo8(3)
 696 016c 60E0      		ldi r22,lo8(TX_ADDRESS0)
 697 016e 70E0      		ldi r23,hi8(TX_ADDRESS0)
 698 0170 80E1      		ldi r24,lo8(16)
 699 0172 00D0      		rcall NRF24_Write_Buf
 290:main.c        **** 	NRF24_Write_Buf(RX_ADDR_P0, TX_ADDRESS0, TX_ADR_WIDTH);	//записываем адрес приемника
 701               	.LM80:
 702 0174 43E0      		ldi r20,lo8(3)
 703 0176 60E0      		ldi r22,lo8(TX_ADDRESS0)
 704 0178 70E0      		ldi r23,hi8(TX_ADDRESS0)
 705 017a 8AE0      		ldi r24,lo8(10)
 706 017c 00D0      		rcall NRF24_Write_Buf
 291:main.c        **** 	CE_RESET();
 708               	.LM81:
 709 017e C098      		cbi 0x18,0
 292:main.c        **** 	// Flush buffers
 293:main.c        **** 	NRF24_FlushRX();
 711               	.LM82:
 712 0180 00D0      		rcall NRF24_FlushRX
 294:main.c        **** 	NRF24_FlushTX();
 714               	.LM83:
 715 0182 00C0      		rjmp NRF24_FlushTX
 717               	.Lscope14:
 721               	.global	NRF24_Transmit
 723               	NRF24_Transmit:
 295:main.c        **** }
 296:main.c        **** //------------------------------------------------
 297:main.c        **** void NRF24_Transmit(uint8_t addr,uint8_t *pBuf,uint8_t bytes)
 298:main.c        **** {//передача данных в модуль
 725               	.LM84:
 726               	.LFBB15:
 727 0184 FF92      		push r15
 728 0186 0F93      		push r16
 729 0188 1F93      		push r17
 730 018a CF93      		push r28
 731 018c DF93      		push r29
 732               	/* prologue: function */
 733               	/* frame size = 0 */
 734               	/* stack size = 5 */
 735               	.L__stack_usage = 5
 736 018e F62E      		mov r15,r22
 737 0190 072F      		mov r16,r23
 738 0192 142F      		mov r17,r20
 299:main.c        **** 	CE_RESET();
 740               	.LM85:
 741 0194 C098      		cbi 0x18,0
 300:main.c        **** 	CS_ON();
 743               	.LM86:
 744 0196 9798      		cbi 0x12,7
 301:main.c        **** 	spi_sendByte(addr);
 746               	.LM87:
 747 0198 00D0      		rcall spi_sendByte
 748               	.LBB46:
 749               	.LBB47:
 751               	.Ltext11:
 753               	.LM88:
 754 019a 82E0      		ldi r24,lo8(2)
 755 019c 8A95      	1:	dec r24
 756 019e 01F4      		brne 1b
 757 01a0 00C0      		rjmp .
 758 01a2 CF2D      		mov r28,r15
 759 01a4 D02F      		mov r29,r16
 760 01a6 CE01      		movw r24,r28
 761 01a8 810F      		add r24,r17
 762 01aa 911D      		adc r25,__zero_reg__
 763 01ac 8C01      		movw r16,r24
 764               	.L31:
 765               	.LBE47:
 766               	.LBE46:
 767               	.LBB48:
 769               	.Ltext12:
 302:main.c        **** 	_delay_us(1); //пауза в микросекунду для завершения процесса
 303:main.c        **** 	for (uint8_t i = 0 ; i < bytes ; i++)
 771               	.LM89:
 772 01ae C017      		cp r28,r16
 773 01b0 D107      		cpc r29,r17
 774 01b2 01F0      		breq .L33
 304:main.c        **** 	{
 305:main.c        **** 		spi_sendByte(pBuf[i]);
 776               	.LM90:
 777 01b4 8991      		ld r24,Y+
 778 01b6 00D0      		rcall spi_sendByte
 779 01b8 00C0      		rjmp .L31
 780               	.L33:
 781               	.LBE48:
 306:main.c        **** 	}
 307:main.c        **** 	CS_OFF();
 783               	.LM91:
 784 01ba 979A      		sbi 0x12,7
 308:main.c        **** 	CE_SET();
 786               	.LM92:
 787 01bc C09A      		sbi 0x18,0
 788               	/* epilogue start */
 309:main.c        **** }
 790               	.LM93:
 791 01be DF91      		pop r29
 792 01c0 CF91      		pop r28
 793 01c2 1F91      		pop r17
 794 01c4 0F91      		pop r16
 795 01c6 FF90      		pop r15
 796 01c8 0895      		ret
 798               	.Lscope15:
 801               	.global	NRF24L01_Send
 803               	NRF24L01_Send:
 310:main.c        **** //------------------------------------------------
 311:main.c        **** uint8_t NRF24L01_Send(uint8_t *pBuf)
 312:main.c        **** {//отправка данных в эфир
 805               	.LM94:
 806               	.LFBB16:
 807 01ca CF93      		push r28
 808 01cc DF93      		push r29
 809               	/* prologue: function */
 810               	/* frame size = 0 */
 811               	/* stack size = 2 */
 812               	.L__stack_usage = 2
 813 01ce EC01      		movw r28,r24
 313:main.c        **** 	uint8_t regval=0x00;						//переменная для отправки в конфигурационный регистр
 314:main.c        **** 	NRF24L01_TX_Mode(pBuf);					//включаем режим передачи
 815               	.LM95:
 816 01d0 00D0      		rcall NRF24L01_TX_Mode
 315:main.c        **** 	regval = NRF24_ReadReg(CONFIG);	//сохраняем значения конфигурационного региста
 818               	.LM96:
 819 01d2 80E0      		ldi r24,0
 820 01d4 00D0      		rcall NRF24_ReadReg
 821 01d6 8E7F      		andi r24,lo8(-2)
 316:main.c        **** 	//если модуль ушел в спящий режим, то разбудим его, включив бит PWR_UP и выключив PRIM_RX
 317:main.c        **** 	regval |= (1<<PWR_UP);
 318:main.c        **** 	regval &= ~(1<<PRIM_RX);
 319:main.c        **** 	NRF24_WriteReg(CONFIG,regval);//записываем новое значение конфигурационного регистра
 823               	.LM97:
 824 01d8 682F      		mov r22,r24
 825 01da 6260      		ori r22,lo8(2)
 826 01dc 80E0      		ldi r24,0
 827 01de 00D0      		rcall NRF24_WriteReg
 828               	.LBB49:
 829               	.LBB50:
 831               	.Ltext13:
 833               	.LM98:
 834 01e0 8BE2      		ldi r24,lo8(299)
 835 01e2 91E0      		ldi r25,hi8(299)
 836 01e4 0197      	1:	sbiw r24,1
 837 01e6 01F4      		brne 1b
 838 01e8 00C0      		rjmp .
 839 01ea 0000      		nop
 840               	.LBE50:
 841               	.LBE49:
 843               	.Ltext14:
 320:main.c        **** 	_delay_us(150); //Задержка минимум 130 мкс
 321:main.c        **** 	//Отправим данные в воздух
 322:main.c        **** 	NRF24_Transmit(WR_TX_PLOAD, pBuf, TX_PLOAD_WIDTH);//отправка данных
 845               	.LM99:
 846 01ec 40E2      		ldi r20,lo8(32)
 847 01ee BE01      		movw r22,r28
 848 01f0 80EA      		ldi r24,lo8(-96)
 849 01f2 00D0      		rcall NRF24_Transmit
 323:main.c        **** 	CE_SET();
 851               	.LM100:
 852 01f4 C09A      		sbi 0x18,0
 853               	.LBB51:
 854               	.LBB52:
 856               	.Ltext15:
 858               	.LM101:
 859 01f6 98E2      		ldi r25,lo8(40)
 860 01f8 9A95      	1:	dec r25
 861 01fa 01F4      		brne 1b
 862               	.LBE52:
 863               	.LBE51:
 865               	.Ltext16:
 324:main.c        **** 	_delay_us(15); //minimum 10us high pulse (Page 21)
 325:main.c        **** 	CE_RESET();
 867               	.LM102:
 868 01fc C098      		cbi 0x18,0
 326:main.c        **** 	return 0;
 327:main.c        **** }
 870               	.LM103:
 871 01fe 80E0      		ldi r24,0
 872               	/* epilogue start */
 873 0200 DF91      		pop r29
 874 0202 CF91      		pop r28
 875 0204 0895      		ret
 877               	.Lscope16:
 879               	.global	nrf24_init
 881               	nrf24_init:
 328:main.c        **** //------------------------------------------------
 329:main.c        **** void nrf24_init(void)
 330:main.c        **** {//инициализация
 883               	.LM104:
 884               	.LFBB17:
 885               	/* prologue: function */
 886               	/* frame size = 0 */
 887               	/* stack size = 0 */
 888               	.L__stack_usage = 0
 331:main.c        **** 	CE_RESET();							//опускаем к земле вывод ce
 890               	.LM105:
 891 0206 C098      		cbi 0x18,0
 892               	.LBB53:
 893               	.LBB54:
 895               	.Ltext17:
 897               	.LM106:
 898 0208 8FE0      		ldi r24,lo8(9999)
 899 020a 97E2      		ldi r25,hi8(9999)
 900 020c 0197      	1:	sbiw r24,1
 901 020e 01F4      		brne 1b
 902 0210 00C0      		rjmp .
 903 0212 0000      		nop
 904               	.LBE54:
 905               	.LBE53:
 907               	.Ltext18:
 332:main.c        **** 	_delay_us(5000);					//задержка 5 мс
 333:main.c        **** 	//записываем конфигурационный байт,
 334:main.c        **** 	NRF24_WriteReg(CONFIG, 0x0a);		// Set PWR_UP bit, enable CRC(1 byte) &Prim_RX:0 (Transmitter)
 909               	.LM107:
 910 0214 6AE0      		ldi r22,lo8(10)
 911 0216 80E0      		ldi r24,0
 912 0218 00D0      		rcall NRF24_WriteReg
 913               	.LBB55:
 914               	.LBB56:
 916               	.Ltext19:
 918               	.LM108:
 919 021a 8FE0      		ldi r24,lo8(9999)
 920 021c 97E2      		ldi r25,hi8(9999)
 921 021e 0197      	1:	sbiw r24,1
 922 0220 01F4      		brne 1b
 923 0222 00C0      		rjmp .
 924 0224 0000      		nop
 925               	.LBE56:
 926               	.LBE55:
 928               	.Ltext20:
 335:main.c        **** 	_delay_us(5000);
 336:main.c        **** 	NRF24_WriteReg(EN_AA, 0x00);		// Enable Pipe0
 930               	.LM109:
 931 0226 60E0      		ldi r22,0
 932 0228 81E0      		ldi r24,lo8(1)
 933 022a 00D0      		rcall NRF24_WriteReg
 337:main.c        **** 	NRF24_WriteReg(EN_RXADDR, 0x01);	// Enable Pipe0
 935               	.LM110:
 936 022c 61E0      		ldi r22,lo8(1)
 937 022e 82E0      		ldi r24,lo8(2)
 938 0230 00D0      		rcall NRF24_WriteReg
 338:main.c        **** 	NRF24_WriteReg(SETUP_AW, 0x01);		// Setup address width=3 bytes
 940               	.LM111:
 941 0232 61E0      		ldi r22,lo8(1)
 942 0234 83E0      		ldi r24,lo8(3)
 943 0236 00D0      		rcall NRF24_WriteReg
 339:main.c        **** 	NRF24_WriteReg(SETUP_RETR, 0x00);	// 1500us, 15 retrans
 945               	.LM112:
 946 0238 60E0      		ldi r22,0
 947 023a 84E0      		ldi r24,lo8(4)
 948 023c 00D0      		rcall NRF24_WriteReg
 340:main.c        **** 	NRF24_ToggleFeatures();				//активация команд
 950               	.LM113:
 951 023e 00D0      		rcall NRF24_ToggleFeatures
 341:main.c        **** 	NRF24_WriteReg(FEATURE, 0x07);			//установка стандартных значений регистра FEATURE
 953               	.LM114:
 954 0240 67E0      		ldi r22,lo8(7)
 955 0242 8DE1      		ldi r24,lo8(29)
 956 0244 00D0      		rcall NRF24_WriteReg
 342:main.c        **** 	NRF24_WriteReg(DYNPD, 0);			//отключение динамического размера полезной нагрузки
 958               	.LM115:
 959 0246 60E0      		ldi r22,0
 960 0248 8CE1      		ldi r24,lo8(28)
 961 024a 00D0      		rcall NRF24_WriteReg
 343:main.c        **** 	NRF24_WriteReg(STATUS, 0x70);		//Reset flags for IRQ
 963               	.LM116:
 964 024c 60E7      		ldi r22,lo8(112)
 965 024e 87E0      		ldi r24,lo8(7)
 966 0250 00D0      		rcall NRF24_WriteReg
 344:main.c        **** 	NRF24_WriteReg(RF_CH, 76);			// частота 2476 MHz
 968               	.LM117:
 969 0252 6CE4      		ldi r22,lo8(76)
 970 0254 85E0      		ldi r24,lo8(5)
 971 0256 00D0      		rcall NRF24_WriteReg
 345:main.c        **** 	NRF24_WriteReg(RF_SETUP, 0x06);		//TX_PWR:0dBm, Datarate:1Mbps
 973               	.LM118:
 974 0258 66E0      		ldi r22,lo8(6)
 975 025a 86E0      		ldi r24,lo8(6)
 976 025c 00D0      		rcall NRF24_WriteReg
 346:main.c        **** 	NRF24_Write_Buf(TX_ADDR, TX_ADDRESS0, TX_ADR_WIDTH);//запись адреса передачи
 978               	.LM119:
 979 025e 43E0      		ldi r20,lo8(3)
 980 0260 60E0      		ldi r22,lo8(TX_ADDRESS0)
 981 0262 70E0      		ldi r23,hi8(TX_ADDRESS0)
 982 0264 80E1      		ldi r24,lo8(16)
 983 0266 00D0      		rcall NRF24_Write_Buf
 347:main.c        **** 	NRF24_Write_Buf(RX_ADDR_P1, TX_ADDRESS0, TX_ADR_WIDTH);//запись адреса приема
 985               	.LM120:
 986 0268 43E0      		ldi r20,lo8(3)
 987 026a 60E0      		ldi r22,lo8(TX_ADDRESS0)
 988 026c 70E0      		ldi r23,hi8(TX_ADDRESS0)
 989 026e 8BE0      		ldi r24,lo8(11)
 990 0270 00D0      		rcall NRF24_Write_Buf
 348:main.c        **** 	NRF24_WriteReg(RX_PW_P0, TX_PLOAD_WIDTH); //Number of bytes in RX payload in data pipe 1
 992               	.LM121:
 993 0272 60E2      		ldi r22,lo8(32)
 994 0274 81E1      		ldi r24,lo8(17)
 995 0276 00D0      		rcall NRF24_WriteReg
 349:main.c        **** 	//пока уходим в режим приёмника
 350:main.c        **** 	NRF24L01_RX_Mode();					//режим приема
 997               	.LM122:
 998 0278 00D0      		rcall NRF24L01_RX_Mode
 351:main.c        **** 	LED_OFF();
 1000               	.LM123:
 1001 027a 9698      		cbi 0x12,6
 1002 027c 0895      		ret
 1004               	.Lscope17:
 1006               	.global	IRQ_Callback
 1008               	IRQ_Callback:
 352:main.c        **** }
 353:main.c        **** //--------------------------------------------------
 354:main.c        **** void IRQ_Callback(void)
 355:main.c        **** {
 1010               	.LM124:
 1011               	.LFBB18:
 1012 027e CF93      		push r28
 1013               	/* prologue: function */
 1014               	/* frame size = 0 */
 1015               	/* stack size = 1 */
 1016               	.L__stack_usage = 1
 1017               	.LBB63:
 1018               	.LBB64:
 1020               	.Ltext21:
 1022               	.LM125:
 1023 0280 8AE1      		ldi r24,lo8(26)
 1024 0282 8A95      	1:	dec r24
 1025 0284 01F4      		brne 1b
 1026 0286 00C0      		rjmp .
 1027               	.LBE64:
 1028               	.LBE63:
 1030               	.Ltext22:
 356:main.c        **** 	
 357:main.c        **** 	//LED_ON();
 358:main.c        **** 	uint8_t status=0x01;	//переменная статус
 359:main.c        **** 	_delay_us(10);			//_delay_us(10);
 360:main.c        **** 	status = NRF24_ReadReg(STATUS);	//чтение значения регистра статуса
 1032               	.LM126:
 1033 0288 87E0      		ldi r24,lo8(7)
 1034 028a 00D0      		rcall NRF24_ReadReg
 1035 028c C82F      		mov r28,r24
 361:main.c        **** 	if(status & RX_DR)				//если есть данные на прием
 1037               	.LM127:
 1038 028e 86FF      		sbrs r24,6
 1039 0290 00C0      		rjmp .L37
 362:main.c        **** 	{
 363:main.c        **** 		NRF24_Read_Buf(RD_RX_PLOAD,rx_buf,TX_PLOAD_WIDTH);//чтение буфера
 1041               	.LM128:
 1042 0292 40E2      		ldi r20,lo8(32)
 1043 0294 60E0      		ldi r22,lo8(rx_buf)
 1044 0296 70E0      		ldi r23,hi8(rx_buf)
 1045 0298 81E6      		ldi r24,lo8(97)
 1046 029a 00D0      		rcall NRF24_Read_Buf
 364:main.c        **** 		NRF24_WriteReg(STATUS, 0x40);	//запись в регистр статуса 1 в шестой бит, обнуление остальных
 1048               	.LM129:
 1049 029c 60E4      		ldi r22,lo8(64)
 1050 029e 87E0      		ldi r24,lo8(7)
 1051 02a0 00D0      		rcall NRF24_WriteReg
 365:main.c        **** 		f_rx = 1;						//поднимаем флаг приема
 1053               	.LM130:
 1054 02a2 81E0      		ldi r24,lo8(1)
 1055 02a4 8093 0000 		sts f_rx,r24
 1056               	.L37:
 366:main.c        **** 	}
 367:main.c        **** 	if(status & TX_DS) //данные успешно отправлены
 1058               	.LM131:
 1059 02a8 C5FF      		sbrs r28,5
 1060 02aa 00C0      		rjmp .L38
 1061               	.LBB65:
 1062               	.LBB66:
 368:main.c        **** 	{
 369:main.c        **** 		NRF24_WriteReg(STATUS, 0x20);	//очистка всех битов кроме пятого
 1064               	.LM132:
 1065 02ac 60E2      		ldi r22,lo8(32)
 1066 02ae 87E0      		ldi r24,lo8(7)
 1067 02b0 00D0      		rcall NRF24_WriteReg
 370:main.c        **** 		NRF24L01_RX_Mode();				//переход в режим приема
 1069               	.LM133:
 1070 02b2 00D0      		rcall NRF24L01_RX_Mode
 371:main.c        **** 		f_tx = 1;						//поднимаем флаг передачи
 1072               	.LM134:
 1073 02b4 81E0      		ldi r24,lo8(1)
 1074 02b6 8093 0000 		sts f_tx,r24
 1075 02ba 00C0      		rjmp .L36
 1076               	.L38:
 1077               	.LBE66:
 1078               	.LBE65:
 372:main.c        **** 	}
 373:main.c        **** 	else if(status & MAX_RT)//превышение количества попыток отправки
 1080               	.LM135:
 1081 02bc C4FF      		sbrs r28,4
 1082 02be 00C0      		rjmp .L36
 374:main.c        **** 	{
 375:main.c        **** 		NRF24_WriteReg(STATUS, 0x10);	//однуление всех остальных битов, кроме 4го
 1084               	.LM136:
 1085 02c0 60E1      		ldi r22,lo8(16)
 1086 02c2 87E0      		ldi r24,lo8(7)
 1087 02c4 00D0      		rcall NRF24_WriteReg
 376:main.c        **** 		NRF24_FlushTX();				//очистка буфера отправки
 1089               	.LM137:
 1090 02c6 00D0      		rcall NRF24_FlushTX
 1091               	/* epilogue start */
 377:main.c        **** 		//Уходим в режим приёмника
 378:main.c        **** 		NRF24L01_RX_Mode();
 379:main.c        **** 	}
 380:main.c        **** }
 1093               	.LM138:
 1094 02c8 CF91      		pop r28
 378:main.c        **** 	}
 1096               	.LM139:
 1097 02ca 00C0      		rjmp NRF24L01_RX_Mode
 1098               	.L36:
 1099               	/* epilogue start */
 1101               	.LM140:
 1102 02cc CF91      		pop r28
 1103 02ce 0895      		ret
 1108               	.Lscope18:
 1110               	.global	__vector_1
 1112               	__vector_1:
 125:main.c        **** 	IRQ_Callback();
 1114               	.LM141:
 1115               	.LFBB19:
 1116 02d0 1F92      		push r1
 1117 02d2 0F92      		push r0
 1118 02d4 0FB6      		in r0,__SREG__
 1119 02d6 0F92      		push r0
 1120 02d8 1124      		clr __zero_reg__
 1121 02da 2F93      		push r18
 1122 02dc 3F93      		push r19
 1123 02de 4F93      		push r20
 1124 02e0 5F93      		push r21
 1125 02e2 6F93      		push r22
 1126 02e4 7F93      		push r23
 1127 02e6 8F93      		push r24
 1128 02e8 9F93      		push r25
 1129 02ea AF93      		push r26
 1130 02ec BF93      		push r27
 1131 02ee EF93      		push r30
 1132 02f0 FF93      		push r31
 1133               	/* prologue: Signal */
 1134               	/* frame size = 0 */
 1135               	/* stack size = 15 */
 1136               	.L__stack_usage = 15
 126:main.c        **** }
 1138               	.LM142:
 1139 02f2 00D0      		rcall IRQ_Callback
 1140               	/* epilogue start */
 127:main.c        **** 
 1142               	.LM143:
 1143 02f4 FF91      		pop r31
 1144 02f6 EF91      		pop r30
 1145 02f8 BF91      		pop r27
 1146 02fa AF91      		pop r26
 1147 02fc 9F91      		pop r25
 1148 02fe 8F91      		pop r24
 1149 0300 7F91      		pop r23
 1150 0302 6F91      		pop r22
 1151 0304 5F91      		pop r21
 1152 0306 4F91      		pop r20
 1153 0308 3F91      		pop r19
 1154 030a 2F91      		pop r18
 1155 030c 0F90      		pop r0
 1156 030e 0FBE      		out __SREG__,r0
 1157 0310 0F90      		pop r0
 1158 0312 1F90      		pop r1
 1159 0314 1895      		reti
 1161               	.Lscope19:
 1162               		.section	.text.startup,"ax",@progbits
 1164               	.global	main
 1166               	main:
 381:main.c        **** 
 382:main.c        **** 
 383:main.c        **** 
 384:main.c        **** #if defined(BOOTLOADERHASNOVECTORS)
 385:main.c        **** 	#warning "This Bootloader does not link interrupt vectors - see makefile"
 386:main.c        **** 	/* make the linker happy - it wants to see __vector_default */
 387:main.c        **** 	// void __vector_default(void) { ; }
 388:main.c        **** 	void __vector_default(void) { ; }
 389:main.c        **** #endif
 390:main.c        **** 
 391:main.c        **** static inline void eraseFlash(void)
 392:main.c        **** {
 393:main.c        **** 	// erase only main section (bootloader protection)
 394:main.c        **** 	uint32_t addr = 0;
 395:main.c        **** 	while (APP_END > addr) 
 396:main.c        **** 		{
 397:main.c        **** 		boot_page_erase(addr);		// Perform page erase
 398:main.c        **** 		boot_spm_busy_wait();		// Wait until the memory is erased.
 399:main.c        **** 		addr += SPM_PAGESIZE;
 400:main.c        **** 		}
 401:main.c        **** 	boot_rww_enable();
 402:main.c        **** }
 403:main.c        **** 
 404:main.c        **** static inline uint16_t writeFlashPage(uint16_t waddr, pagebuf_t size)
 405:main.c        **** {
 406:main.c        **** 	uint32_t pagestart = (uint32_t)waddr<<1;
 407:main.c        **** 	uint32_t baddr = pagestart;
 408:main.c        **** 	uint16_t data;
 409:main.c        **** 	uint8_t *tmp = gBuffer;
 410:main.c        **** 
 411:main.c        **** 	do 
 412:main.c        **** 		{
 413:main.c        **** 		data = *tmp++;
 414:main.c        **** 		data |= *tmp++ << 8;
 415:main.c        **** 		boot_page_fill(baddr, data);	// call asm routine.
 416:main.c        **** 
 417:main.c        **** 		baddr += 2;			// Select next word in memory
 418:main.c        **** 		size -= 2;			// Reduce number of bytes to write by two
 419:main.c        **** 		} 
 420:main.c        **** 	while (size);				// Loop until all bytes written
 421:main.c        **** 
 422:main.c        **** 	boot_page_write(pagestart);
 423:main.c        **** 	boot_spm_busy_wait();
 424:main.c        **** 	boot_rww_enable();		// Re-enable the RWW section
 425:main.c        **** 
 426:main.c        **** 	return baddr>>1;
 427:main.c        **** }
 428:main.c        **** 
 429:main.c        **** static inline uint16_t writeEEpromPage(uint16_t address, pagebuf_t size)
 430:main.c        **** {
 431:main.c        **** 	uint8_t *tmp = gBuffer;
 432:main.c        **** 
 433:main.c        **** 	do 
 434:main.c        **** 		{
 435:main.c        **** 		eeprom_write_byte( (uint8_t*)address, *tmp++ );
 436:main.c        **** 		address++;			// Select next byte
 437:main.c        **** 		size--;				// Decreas number of bytes to write
 438:main.c        **** 		}
 439:main.c        **** 	while (size);				// Loop until all bytes written
 440:main.c        **** 
 441:main.c        **** 	// eeprom_busy_wait();
 442:main.c        **** 
 443:main.c        **** 	return address;
 444:main.c        **** }
 445:main.c        **** 
 446:main.c        **** static void (*jump_to_app)(void) = 0x0000;
 447:main.c        **** 
 448:main.c        **** int main(void)
 449:main.c        **** {
 1168               	.LM144:
 1169               	.LFBB20:
 1170               	/* prologue: function */
 1171               	/* frame size = 0 */
 1172               	/* stack size = 0 */
 1173               	.L__stack_usage = 0
 450:main.c        **** 	nrf24_init();
 1175               	.LM145:
 1176 0000 00D0      		rcall nrf24_init
 451:main.c        **** 	interrupt_init();						//инициализация прерываний
 1178               	.LM146:
 1179 0002 00D0      		rcall interrupt_init
 452:main.c        **** 	port_init();							//инициализация портов
 1181               	.LM147:
 1182 0004 00D0      		rcall port_init
 453:main.c        **** 	spi_init();								//инициализация SPI
 1184               	.LM148:
 1185 0006 00D0      		rcall spi_init
 1186 0008 85E0      		ldi r24,lo8(5)
 1187               	.L48:
 454:main.c        **** 
 455:main.c        **** 	uint16_t cnt = 0;
 456:main.c        **** 
 457:main.c        **** 	uint8_t blink_counter = 5;
 458:main.c        **** 	while (blink_counter)
 459:main.c        **** 	{
 460:main.c        **** 		LED_ON();
 1189               	.LM149:
 1190 000a 969A      		sbi 0x12,6
 1191               	.LBB67:
 1192               	.LBB68:
 1194               	.Ltext23:
 187:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 1196               	.LM150:
 1197 000c 2FE7      		ldi r18,lo8(79999)
 1198 000e 38E3      		ldi r19,hi8(79999)
 1199 0010 91E0      		ldi r25,hlo8(79999)
 1200 0012 2150      	1:	subi r18,1
 1201 0014 3040      		sbci r19,0
 1202 0016 9040      		sbci r25,0
 1203 0018 01F4      		brne 1b
 1204 001a 00C0      		rjmp .
 1205 001c 0000      		nop
 1206               	.LBE68:
 1207               	.LBE67:
 1209               	.Ltext24:
 461:main.c        **** 		_delay_ms(50);
 462:main.c        **** 		LED_OFF();
 1211               	.LM151:
 1212 001e 9698      		cbi 0x12,6
 1213               	.LBB69:
 1214               	.LBB70:
 1216               	.Ltext25:
 187:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 1218               	.LM152:
 1219 0020 EFE7      		ldi r30,lo8(79999)
 1220 0022 F8E3      		ldi r31,hi8(79999)
 1221 0024 21E0      		ldi r18,hlo8(79999)
 1222 0026 E150      	1:	subi r30,1
 1223 0028 F040      		sbci r31,0
 1224 002a 2040      		sbci r18,0
 1225 002c 01F4      		brne 1b
 1226 002e 00C0      		rjmp .
 1227 0030 0000      		nop
 1228 0032 8150      		subi r24,lo8(-(-1))
 1229               	.LBE70:
 1230               	.LBE69:
 1232               	.Ltext26:
 458:main.c        **** 	{
 1234               	.LM153:
 1235 0034 01F4      		brne .L48
 1236 0036 C0E0      		ldi r28,0
 1237 0038 D0E0      		ldi r29,0
 463:main.c        **** 		_delay_ms(50);
 464:main.c        **** 		blink_counter--;
 465:main.c        **** 	}
 466:main.c        **** 
 467:main.c        **** 	while (1) 
 468:main.c        **** 	{
 469:main.c        **** 		/*if(f_rx == 1)						//если флаг приема поднят
 470:main.c        **** 		{
 471:main.c        **** 			char stektemp = SREG;// сохраним значение стека
 472:main.c        **** 			cli(); //запрещаем прерывания
 473:main.c        **** 			f_rx = 0;						//опускаем флаг приема
 474:main.c        **** 			if (rx_buf[0] == BUT_ADDR)		//если первый принятый байт совпадает с адресом кнопки
 475:main.c        **** 			{
 476:main.c        **** 				if (rx_buf[1] == 'B')	break;
 477:main.c        **** 
 478:main.c        **** 				if (rx_buf[1] == 'A')	address = (rx_buf[2]<<8) | rx_buf[3];
 479:main.c        **** 
 480:main.c        **** 				if (rx_buf[1] == 'F')		//
 481:main.c        **** 				{
 482:main.c        **** 					pagebuf_t size;
 483:main.c        **** 					size = (rx_buf[2]<<8) | rx_buf[3];
 484:main.c        **** 					address = writeFlashPage(address, size);
 485:main.c        **** 				}
 486:main.c        **** 				if (rx_buf[1] == 'E')		//
 487:main.c        **** 				{
 488:main.c        **** 					pagebuf_t size;
 489:main.c        **** 					size = (rx_buf[2]<<8) | rx_buf[3];
 490:main.c        **** 					address = writeEEpromPage(address, size);
 491:main.c        **** 				}
 492:main.c        **** 			}
 493:main.c        **** 			SREG = stektemp;// вернем значение стека
 494:main.c        **** 		}*/
 495:main.c        **** 
 496:main.c        **** 		if (cnt++ >= WAIT_VALUE) 
 497:main.c        **** 		{
 498:main.c        **** 			jump_to_app();			// Jump to application sector
 1239               	.LM154:
 1240 003a 00E0      		ldi r16,0
 1241 003c 10E0      		ldi r17,0
 1242               	.L50:
 496:main.c        **** 		{
 1244               	.LM155:
 1245 003e C039      		cpi r28,-112
 1246 0040 31E0      		ldi r19,1
 1247 0042 D307      		cpc r29,r19
 1248 0044 00F0      		brlo .L49
 1250               	.LM156:
 1251 0046 F801      		movw r30,r16
 1252 0048 0995      		icall
 1253               	.L49:
 1254               	.LBB71:
 1255               	.LBB72:
 1257               	.Ltext27:
 187:d:\ide\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 1259               	.LM157:
 1260 004a 8FE1      		ldi r24,lo8(19999)
 1261 004c 9EE4      		ldi r25,hi8(19999)
 1262 004e 0197      	1:	sbiw r24,1
 1263 0050 01F4      		brne 1b
 1264 0052 00C0      		rjmp .
 1265 0054 0000      		nop
 1266 0056 2196      		adiw r28,1
 1267 0058 00C0      		rjmp .L50
 1268               	.LBE72:
 1269               	.LBE71:
 1271               	.Lscope20:
 1272               		.comm	gBuffer,64,1
 1273               		.comm	val,1,1
 1274               	.global	device
 1275               		.section .bss
 1278               	device:
 1279 0000 00        		.zero	1
 1280               	.global	address
 1283               	address:
 1284 0001 0000      		.zero	2
 1285               		.comm	buf1,20,1
 1286               		.comm	f_send,1,1
 1287               	.global	f_tx
 1290               	f_tx:
 1291 0003 00        		.zero	1
 1292               	.global	f_rx
 1295               	f_rx:
 1296 0004 00        		.zero	1
 1297               	.global	tx_buf
 1300               	tx_buf:
 1301 0005 0000 0000 		.zero	32
 1301      0000 0000 
 1301      0000 0000 
 1301      0000 0000 
 1301      0000 0000 
 1302               	.global	rx_buf
 1305               	rx_buf:
 1306 0025 0000 0000 		.zero	32
 1306      0000 0000 
 1306      0000 0000 
 1306      0000 0000 
 1306      0000 0000 
 1307               	.global	TX_ADDRESS1
 1308               		.data
 1311               	TX_ADDRESS1:
 1312 0000 B7        		.byte	-73
 1313 0001 B5        		.byte	-75
 1314 0002 A1        		.byte	-95
 1315               	.global	TX_ADDRESS0
 1318               	TX_ADDRESS0:
 1319 0003 B5        		.byte	-75
 1320 0004 B5        		.byte	-75
 1321 0005 A1        		.byte	-95
 1334               		.text
 1336               	.Letext0:
 1337               		.ident	"GCC: (AVR_8_bit_GNU_Toolchain_3.6.2_1778) 5.4.0"
 1338               	.global __do_copy_data
 1339               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
C:\Users\vmelehin\AppData\Local\Temp\cc4nitVf.s:2      *ABS*:0000003e __SP_H__
C:\Users\vmelehin\AppData\Local\Temp\cc4nitVf.s:3      *ABS*:0000003d __SP_L__
C:\Users\vmelehin\AppData\Local\Temp\cc4nitVf.s:4      *ABS*:0000003f __SREG__
C:\Users\vmelehin\AppData\Local\Temp\cc4nitVf.s:5      *ABS*:00000000 __tmp_reg__
C:\Users\vmelehin\AppData\Local\Temp\cc4nitVf.s:6      *ABS*:00000001 __zero_reg__
C:\Users\vmelehin\AppData\Local\Temp\cc4nitVf.s:136    .text:00000000 port_init
C:\Users\vmelehin\AppData\Local\Temp\cc4nitVf.s:172    .text:00000016 interrupt_init
C:\Users\vmelehin\AppData\Local\Temp\cc4nitVf.s:203    .text:0000002a spi_init
C:\Users\vmelehin\AppData\Local\Temp\cc4nitVf.s:232    .text:0000003c spi_sendByte
C:\Users\vmelehin\AppData\Local\Temp\cc4nitVf.s:258    .text:00000044 spi_changeByte
C:\Users\vmelehin\AppData\Local\Temp\cc4nitVf.s:286    .text:0000004e NRF24_ReadReg
C:\Users\vmelehin\AppData\Local\Temp\cc4nitVf.s:329    .text:00000064 NRF24_WriteReg
C:\Users\vmelehin\AppData\Local\Temp\cc4nitVf.s:363    .text:00000078 NRF24_ToggleFeatures
C:\Users\vmelehin\AppData\Local\Temp\cc4nitVf.s:407    .text:0000008e NRF24_Read_Buf
C:\Users\vmelehin\AppData\Local\Temp\cc4nitVf.s:472    .text:000000d0 NRF24_Write_Buf
C:\Users\vmelehin\AppData\Local\Temp\cc4nitVf.s:546    .text:00000114 NRF24_FlushRX
C:\Users\vmelehin\AppData\Local\Temp\cc4nitVf.s:584    .text:00000126 NRF24_FlushTX
C:\Users\vmelehin\AppData\Local\Temp\cc4nitVf.s:622    .text:00000138 NRF24L01_RX_Mode
C:\Users\vmelehin\AppData\Local\Temp\cc4nitVf.s:1311   .data:00000000 TX_ADDRESS1
C:\Users\vmelehin\AppData\Local\Temp\cc4nitVf.s:685    .text:0000016a NRF24L01_TX_Mode
C:\Users\vmelehin\AppData\Local\Temp\cc4nitVf.s:1318   .data:00000003 TX_ADDRESS0
C:\Users\vmelehin\AppData\Local\Temp\cc4nitVf.s:723    .text:00000184 NRF24_Transmit
C:\Users\vmelehin\AppData\Local\Temp\cc4nitVf.s:803    .text:000001ca NRF24L01_Send
C:\Users\vmelehin\AppData\Local\Temp\cc4nitVf.s:881    .text:00000206 nrf24_init
C:\Users\vmelehin\AppData\Local\Temp\cc4nitVf.s:1008   .text:0000027e IRQ_Callback
C:\Users\vmelehin\AppData\Local\Temp\cc4nitVf.s:1305   .bss:00000025 rx_buf
C:\Users\vmelehin\AppData\Local\Temp\cc4nitVf.s:1295   .bss:00000004 f_rx
C:\Users\vmelehin\AppData\Local\Temp\cc4nitVf.s:1290   .bss:00000003 f_tx
C:\Users\vmelehin\AppData\Local\Temp\cc4nitVf.s:1112   .text:000002d0 __vector_1
C:\Users\vmelehin\AppData\Local\Temp\cc4nitVf.s:1166   .text.startup:00000000 main
                            *COM*:00000040 gBuffer
                            *COM*:00000001 val
C:\Users\vmelehin\AppData\Local\Temp\cc4nitVf.s:1278   .bss:00000000 device
C:\Users\vmelehin\AppData\Local\Temp\cc4nitVf.s:1283   .bss:00000001 address
                            *COM*:00000014 buf1
                            *COM*:00000001 f_send
C:\Users\vmelehin\AppData\Local\Temp\cc4nitVf.s:1300   .bss:00000005 tx_buf

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
