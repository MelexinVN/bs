
main.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000004e6  00001800  00001800  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000006  00800060  00001ce6  0000057a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000009c  00800066  00800066  00000580  2**0
                  ALLOC
  3 .stab         000013d4  00000000  00000000  00000580  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      0000141d  00000000  00000000  00001954  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000030  00000000  00000000  00002d71  2**0
                  CONTENTS, READONLY
  6 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00002da4  2**2
                  CONTENTS, READONLY
  7 .debug_info   0000048c  00000000  00000000  00002de0  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 0000044e  00000000  00000000  0000326c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000001a  00000000  00000000  000036ba  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000017a  00000000  00000000  000036d4  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00001800 <__vectors>:
    1800:	12 c0       	rjmp	.+36     	; 0x1826 <__ctors_end>
    1802:	2c c0       	rjmp	.+88     	; 0x185c <__bad_interrupt>
    1804:	2b c0       	rjmp	.+86     	; 0x185c <__bad_interrupt>
    1806:	2a c0       	rjmp	.+84     	; 0x185c <__bad_interrupt>
    1808:	29 c0       	rjmp	.+82     	; 0x185c <__bad_interrupt>
    180a:	28 c0       	rjmp	.+80     	; 0x185c <__bad_interrupt>
    180c:	27 c0       	rjmp	.+78     	; 0x185c <__bad_interrupt>
    180e:	26 c0       	rjmp	.+76     	; 0x185c <__bad_interrupt>
    1810:	25 c0       	rjmp	.+74     	; 0x185c <__bad_interrupt>
    1812:	24 c0       	rjmp	.+72     	; 0x185c <__bad_interrupt>
    1814:	23 c0       	rjmp	.+70     	; 0x185c <__bad_interrupt>
    1816:	22 c0       	rjmp	.+68     	; 0x185c <__bad_interrupt>
    1818:	21 c0       	rjmp	.+66     	; 0x185c <__bad_interrupt>
    181a:	20 c0       	rjmp	.+64     	; 0x185c <__bad_interrupt>
    181c:	1f c0       	rjmp	.+62     	; 0x185c <__bad_interrupt>
    181e:	1e c0       	rjmp	.+60     	; 0x185c <__bad_interrupt>
    1820:	1d c0       	rjmp	.+58     	; 0x185c <__bad_interrupt>
    1822:	1c c0       	rjmp	.+56     	; 0x185c <__bad_interrupt>
    1824:	1b c0       	rjmp	.+54     	; 0x185c <__bad_interrupt>

00001826 <__ctors_end>:
    1826:	11 24       	eor	r1, r1
    1828:	1f be       	out	0x3f, r1	; 63
    182a:	cf e5       	ldi	r28, 0x5F	; 95
    182c:	d4 e0       	ldi	r29, 0x04	; 4
    182e:	de bf       	out	0x3e, r29	; 62
    1830:	cd bf       	out	0x3d, r28	; 61

00001832 <__do_copy_data>:
    1832:	10 e0       	ldi	r17, 0x00	; 0
    1834:	a0 e6       	ldi	r26, 0x60	; 96
    1836:	b0 e0       	ldi	r27, 0x00	; 0
    1838:	e6 ee       	ldi	r30, 0xE6	; 230
    183a:	fc e1       	ldi	r31, 0x1C	; 28
    183c:	02 c0       	rjmp	.+4      	; 0x1842 <__do_copy_data+0x10>
    183e:	05 90       	lpm	r0, Z+
    1840:	0d 92       	st	X+, r0
    1842:	a6 36       	cpi	r26, 0x66	; 102
    1844:	b1 07       	cpc	r27, r17
    1846:	d9 f7       	brne	.-10     	; 0x183e <__do_copy_data+0xc>

00001848 <__do_clear_bss>:
    1848:	21 e0       	ldi	r18, 0x01	; 1
    184a:	a6 e6       	ldi	r26, 0x66	; 102
    184c:	b0 e0       	ldi	r27, 0x00	; 0
    184e:	01 c0       	rjmp	.+2      	; 0x1852 <.do_clear_bss_start>

00001850 <.do_clear_bss_loop>:
    1850:	1d 92       	st	X+, r1

00001852 <.do_clear_bss_start>:
    1852:	a2 30       	cpi	r26, 0x02	; 2
    1854:	b2 07       	cpc	r27, r18
    1856:	e1 f7       	brne	.-8      	; 0x1850 <.do_clear_bss_loop>
    1858:	4e d1       	rcall	.+668    	; 0x1af6 <main>
    185a:	43 c2       	rjmp	.+1158   	; 0x1ce2 <_exit>

0000185c <__bad_interrupt>:
    185c:	d1 cf       	rjmp	.-94     	; 0x1800 <__vectors>

0000185e <port_init>:
void port_init(void)//Инициализация портов
{
	// Input/Output Ports initialization
	// Port B initialization
	// Function: Bit7=In Bit6=In Bit5=Out Bit4=In Bit3=Out Bit2=Out Bit1=In Bit0=Out
	DDRB=(0<<DDB7) | (0<<DDB6) | (1<<DDB5) | (0<<DDB4) | (1<<DDB3) | (1<<DDB2) | (0<<DDB1) | (1<<DDB0);
    185e:	8d e2       	ldi	r24, 0x2D	; 45
    1860:	87 bb       	out	0x17, r24	; 23
	// State: Bit7=T Bit6=T Bit5=0 Bit4=T Bit3=0 Bit2=0 Bit1=T Bit0=0
	PORTB=(0<<PORTB7) | (0<<PORTB6) | (0<<PORTB5) | (0<<PORTB4) | (0<<PORTB3) | (0<<PORTB2) | (0<<PORTB1) | (1<<PORTB0);
    1862:	81 e0       	ldi	r24, 0x01	; 1
    1864:	88 bb       	out	0x18, r24	; 24

	// Port C initialization
	// Function: Bit6=In Bit5=In Bit4=In Bit3=In Bit2=In Bit1=In Bit0=In
	DDRC=(0<<DDC6) | (0<<DDC5) | (0<<DDC4) | (0<<DDC3) | (0<<DDC2) | (0<<DDC1) | (0<<DDC0);
    1866:	14 ba       	out	0x14, r1	; 20
	// State: Bit6=T Bit5=T Bit4=T Bit3=T Bit2=T Bit1=T Bit0=T
	PORTC=(0<<PORTC6) | (0<<PORTC5) | (0<<PORTC4) | (0<<PORTC3) | (0<<PORTC2) | (0<<PORTC1) | (0<<PORTC0);
    1868:	15 ba       	out	0x15, r1	; 21

	// Port D initialization
	// Function: Bit7=Out Bit6=Out Bit5=In Bit4=In Bit3=In Bit2=In Bit1=In Bit0=In
	DDRD=(1<<DDD7) | (1<<DDD6) | (0<<DDD5) | (0<<DDD4) | (0<<DDD3) | (0<<DDD2) | (0<<DDD1) | (0<<DDD0);
    186a:	80 ec       	ldi	r24, 0xC0	; 192
    186c:	81 bb       	out	0x11, r24	; 17
	// State: Bit7=0 Bit6=0 Bit5=T Bit4=T Bit3=P Bit2=T Bit1=T Bit0=T
	PORTD=(1<<PORTD7) | (0<<PORTD6) | (0<<PORTD5) | (0<<PORTD4) | (1<<PORTD3) | (0<<PORTD2) | (0<<PORTD1) | (0<<PORTD0);
    186e:	88 e8       	ldi	r24, 0x88	; 136
    1870:	82 bb       	out	0x12, r24	; 18
    1872:	08 95       	ret

00001874 <spi_init>:
}

//инициализация SPI
void spi_init(void)
{
	DDRB |= ((1<<PORTB2)|(1<<PORTB3)|(1<<PORTB5)); //ножки SPI на выход
    1874:	87 b3       	in	r24, 0x17	; 23
    1876:	8c 62       	ori	r24, 0x2C	; 44
    1878:	87 bb       	out	0x17, r24	; 23
	PORTB &= ~((1<<PORTB2)|(1<<PORTB3)|(1<<PORTB5)); //низкий уровень
    187a:	88 b3       	in	r24, 0x18	; 24
    187c:	83 7d       	andi	r24, 0xD3	; 211
    187e:	88 bb       	out	0x18, r24	; 24
	SPCR=(0<<SPIE) | (1<<SPE) | (0<<DORD) | (1<<MSTR) | (0<<CPOL) | (0<<CPHA) | (0<<SPR1) | (0<<SPR0);
    1880:	80 e5       	ldi	r24, 0x50	; 80
    1882:	8d b9       	out	0x0d, r24	; 13
    1884:	08 95       	ret

00001886 <spi_sendByte>:
}

//отправка байта
void spi_sendByte(uint8_t byte)
{
	SPDR = byte;				//записываем байт в регистр
    1886:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1<<SPIF)));	//подождем пока данные передадутся
    1888:	77 9b       	sbis	0x0e, 7	; 14
    188a:	fe cf       	rjmp	.-4      	; 0x1888 <spi_sendByte+0x2>
}
    188c:	08 95       	ret

0000188e <spi_changeByte>:

//прием/отправка байта
uint8_t spi_changeByte(uint8_t byte)
{
	SPDR = byte;				//записываем байт в регистр
    188e:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1<<SPIF)));	//подождем пока данные передадутся (обменяются)
    1890:	77 9b       	sbis	0x0e, 7	; 14
    1892:	fe cf       	rjmp	.-4      	; 0x1890 <spi_changeByte+0x2>
	return SPDR;				//возвращаем принятое значение
    1894:	8f b1       	in	r24, 0x0f	; 15
}
    1896:	08 95       	ret

00001898 <NRF24_ReadReg>:

//функция чтения регистра модуля
uint8_t NRF24_ReadReg(uint8_t addr)
{
    1898:	cf 93       	push	r28
    189a:	c8 2f       	mov	r28, r24
	uint8_t dt=0, cmd;								//переменные данных и команды
	CS_ON();											//ногу cs к земле
    189c:	97 98       	cbi	0x12, 7	; 18
	dt = spi_changeByte(addr);						//Прием/отправкадайта адреса регистра
    189e:	f7 df       	rcall	.-18     	; 0x188e <spi_changeByte>
	//если адрес равен адрес регистра статус то и возварщаем его состояние
	if (addr!=STATUS)//а если не равен
    18a0:	c7 30       	cpi	r28, 0x07	; 7
    18a2:	11 f0       	breq	.+4      	; 0x18a8 <NRF24_ReadReg+0x10>
	{
		cmd=0xFF;									//команда NOP для получения данных
		dt = spi_changeByte(cmd);					//
    18a4:	8f ef       	ldi	r24, 0xFF	; 255
    18a6:	f3 df       	rcall	.-26     	; 0x188e <spi_changeByte>
	}
	CS_OFF();											//поднимаем ногу CS
    18a8:	97 9a       	sbi	0x12, 7	; 18
	return dt;	//возвращаемое значение
}
    18aa:	cf 91       	pop	r28
    18ac:	08 95       	ret

000018ae <NRF24_WriteReg>:
//------------------------------------------------
//функция записи регистра в модуль
void NRF24_WriteReg(uint8_t addr, uint8_t dt)
{
    18ae:	cf 93       	push	r28
    18b0:	c6 2f       	mov	r28, r22
	addr |= W_REGISTER;//включим бит записи в адрес
	CS_ON();
    18b2:	97 98       	cbi	0x12, 7	; 18
	spi_sendByte(addr);									//
    18b4:	80 62       	ori	r24, 0x20	; 32
    18b6:	e7 df       	rcall	.-50     	; 0x1886 <spi_sendByte>
	spi_sendByte(dt);										//
    18b8:	8c 2f       	mov	r24, r28
    18ba:	e5 df       	rcall	.-54     	; 0x1886 <spi_sendByte>
	CS_OFF();
    18bc:	97 9a       	sbi	0x12, 7	; 18
}
    18be:	cf 91       	pop	r28
    18c0:	08 95       	ret

000018c2 <NRF24_ToggleFeatures>:

//------------------------------------------------
void NRF24_ToggleFeatures(void)							//активация команд R_RX_PL_WID, W_ACK_PAYLOAD и W_TX_PAYLOAD_NOACK
{	//есть в даташите "без плюса"
	uint8_t dt[1] = {ACTIVATE};
	CS_ON();
    18c2:	97 98       	cbi	0x12, 7	; 18
	spi_sendByte(dt[0]);
    18c4:	80 e5       	ldi	r24, 0x50	; 80
    18c6:	df df       	rcall	.-66     	; 0x1886 <spi_sendByte>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    18c8:	82 e0       	ldi	r24, 0x02	; 2
    18ca:	8a 95       	dec	r24
    18cc:	f1 f7       	brne	.-4      	; 0x18ca <NRF24_ToggleFeatures+0x8>
    18ce:	00 c0       	rjmp	.+0      	; 0x18d0 <NRF24_ToggleFeatures+0xe>
	_delay_us(1);
	dt[0] = 0x73;
	spi_sendByte(dt[0]);
    18d0:	83 e7       	ldi	r24, 0x73	; 115
    18d2:	d9 df       	rcall	.-78     	; 0x1886 <spi_sendByte>
	CS_OFF();
    18d4:	97 9a       	sbi	0x12, 7	; 18
    18d6:	08 95       	ret

000018d8 <NRF24_Read_Buf>:
}

//-----------------------------------------------
void NRF24_Read_Buf(uint8_t addr,uint8_t *pBuf,uint8_t bytes)
{//чтение буфера (несколько байт)
    18d8:	ef 92       	push	r14
    18da:	ff 92       	push	r15
    18dc:	0f 93       	push	r16
    18de:	1f 93       	push	r17
    18e0:	cf 93       	push	r28
    18e2:	df 93       	push	r29
    18e4:	18 2f       	mov	r17, r24
    18e6:	06 2f       	mov	r16, r22
    18e8:	e7 2e       	mov	r14, r23
    18ea:	f4 2e       	mov	r15, r20
	CS_ON();
    18ec:	97 98       	cbi	0x12, 7	; 18
	spi_sendByte(addr);
    18ee:	cb df       	rcall	.-106    	; 0x1886 <spi_sendByte>
    18f0:	c0 2f       	mov	r28, r16
    18f2:	de 2d       	mov	r29, r14
    18f4:	ce 01       	movw	r24, r28
    18f6:	8f 0d       	add	r24, r15
    18f8:	91 1d       	adc	r25, r1
    18fa:	7c 01       	movw	r14, r24
	for (uint8_t i = 0 ; i < bytes ; i++) 		//для нужного количества байт
    18fc:	ce 15       	cp	r28, r14
    18fe:	df 05       	cpc	r29, r15
    1900:	21 f0       	breq	.+8      	; 0x190a <NRF24_Read_Buf+0x32>
	{																					//
		pBuf[i] = spi_changeByte(addr);
    1902:	81 2f       	mov	r24, r17
    1904:	c4 df       	rcall	.-120    	; 0x188e <spi_changeByte>
    1906:	89 93       	st	Y+, r24
    1908:	f9 cf       	rjmp	.-14     	; 0x18fc <NRF24_Read_Buf+0x24>
	}
	CS_OFF();
    190a:	97 9a       	sbi	0x12, 7	; 18
}
    190c:	df 91       	pop	r29
    190e:	cf 91       	pop	r28
    1910:	1f 91       	pop	r17
    1912:	0f 91       	pop	r16
    1914:	ff 90       	pop	r15
    1916:	ef 90       	pop	r14
    1918:	08 95       	ret

0000191a <NRF24_Write_Buf>:

//------------------------------------------------
void NRF24_Write_Buf(uint8_t addr,uint8_t *pBuf,uint8_t bytes)
{//запись буфера
    191a:	ff 92       	push	r15
    191c:	0f 93       	push	r16
    191e:	1f 93       	push	r17
    1920:	cf 93       	push	r28
    1922:	df 93       	push	r29
    1924:	f6 2e       	mov	r15, r22
    1926:	07 2f       	mov	r16, r23
    1928:	14 2f       	mov	r17, r20
	addr |= W_REGISTER;//включим бит записи в адрес
	CS_ON();
    192a:	97 98       	cbi	0x12, 7	; 18
	spi_sendByte(addr);
    192c:	80 62       	ori	r24, 0x20	; 32
    192e:	ab df       	rcall	.-170    	; 0x1886 <spi_sendByte>
    1930:	82 e0       	ldi	r24, 0x02	; 2
    1932:	8a 95       	dec	r24
    1934:	f1 f7       	brne	.-4      	; 0x1932 <NRF24_Write_Buf+0x18>
    1936:	00 c0       	rjmp	.+0      	; 0x1938 <NRF24_Write_Buf+0x1e>
    1938:	cf 2d       	mov	r28, r15
    193a:	d0 2f       	mov	r29, r16
    193c:	ce 01       	movw	r24, r28
    193e:	81 0f       	add	r24, r17
    1940:	91 1d       	adc	r25, r1
    1942:	8c 01       	movw	r16, r24
	_delay_us(1);
	for (uint8_t i = 0 ; i < bytes ; i++) 		//для нужного количества байт
    1944:	c0 17       	cp	r28, r16
    1946:	d1 07       	cpc	r29, r17
    1948:	19 f0       	breq	.+6      	; 0x1950 <NRF24_Write_Buf+0x36>
	{
		spi_sendByte(pBuf[i]);
    194a:	89 91       	ld	r24, Y+
    194c:	9c df       	rcall	.-200    	; 0x1886 <spi_sendByte>
    194e:	fa cf       	rjmp	.-12     	; 0x1944 <NRF24_Write_Buf+0x2a>
	}
	CS_OFF();
    1950:	97 9a       	sbi	0x12, 7	; 18
}
    1952:	df 91       	pop	r29
    1954:	cf 91       	pop	r28
    1956:	1f 91       	pop	r17
    1958:	0f 91       	pop	r16
    195a:	ff 90       	pop	r15
    195c:	08 95       	ret

0000195e <NRF24_FlushRX>:

//------------------------------------------------
void NRF24_FlushRX(void)
{//очистка буфера приема
	uint8_t dt[1] = {FLUSH_RX};
	CS_ON();
    195e:	97 98       	cbi	0x12, 7	; 18
	spi_sendByte(dt[0]);
    1960:	82 ee       	ldi	r24, 0xE2	; 226
    1962:	91 df       	rcall	.-222    	; 0x1886 <spi_sendByte>
    1964:	82 e0       	ldi	r24, 0x02	; 2
    1966:	8a 95       	dec	r24
    1968:	f1 f7       	brne	.-4      	; 0x1966 <NRF24_FlushRX+0x8>
    196a:	00 c0       	rjmp	.+0      	; 0x196c <NRF24_FlushRX+0xe>
	_delay_us(1); //пауза в микросекунду для завершения процесса
	CS_OFF();
    196c:	97 9a       	sbi	0x12, 7	; 18
    196e:	08 95       	ret

00001970 <NRF24_FlushTX>:

//------------------------------------------------
void NRF24_FlushTX(void)
{//очистка буфера передачи
	uint8_t dt[1] = {FLUSH_TX};
	CS_ON();
    1970:	97 98       	cbi	0x12, 7	; 18
	spi_sendByte(dt[0]);
    1972:	81 ee       	ldi	r24, 0xE1	; 225
    1974:	88 df       	rcall	.-240    	; 0x1886 <spi_sendByte>
    1976:	82 e0       	ldi	r24, 0x02	; 2
    1978:	8a 95       	dec	r24
    197a:	f1 f7       	brne	.-4      	; 0x1978 <NRF24_FlushTX+0x8>
    197c:	00 c0       	rjmp	.+0      	; 0x197e <NRF24_FlushTX+0xe>
	_delay_us(1); //пауза в микросекунду для завершения процесса
	CS_OFF();
    197e:	97 9a       	sbi	0x12, 7	; 18
    1980:	08 95       	ret

00001982 <NRF24L01_RX_Mode>:

//------------------------------------------------
void NRF24L01_RX_Mode(void)
{//режим приемника
	uint8_t regval=0x00;
	regval = NRF24_ReadReg(CONFIG);	//сохраняем значение регистра конфигурации
    1982:	80 e0       	ldi	r24, 0x00	; 0
    1984:	89 df       	rcall	.-238    	; 0x1898 <NRF24_ReadReg>
	//разбудим модуль и переведём его в режим приёмника, включив биты PWR_UP и PRIM_RX
	regval |= (1<<PWR_UP)|(1<<PRIM_RX);
	NRF24_WriteReg(CONFIG,regval);	//возвращаем значение регистра статуса
    1986:	68 2f       	mov	r22, r24
    1988:	63 60       	ori	r22, 0x03	; 3
    198a:	80 e0       	ldi	r24, 0x00	; 0
    198c:	90 df       	rcall	.-224    	; 0x18ae <NRF24_WriteReg>
	
	NRF24_Write_Buf(TX_ADDR, TX_ADDRESS1, TX_ADR_WIDTH);		//записываем  адрес передатчика
    198e:	43 e0       	ldi	r20, 0x03	; 3
    1990:	60 e6       	ldi	r22, 0x60	; 96
    1992:	70 e0       	ldi	r23, 0x00	; 0
    1994:	80 e1       	ldi	r24, 0x10	; 16
    1996:	c1 df       	rcall	.-126    	; 0x191a <NRF24_Write_Buf>
	NRF24_Write_Buf(RX_ADDR_P0, TX_ADDRESS1, TX_ADR_WIDTH);	//записываем адрес приемника
    1998:	43 e0       	ldi	r20, 0x03	; 3
    199a:	60 e6       	ldi	r22, 0x60	; 96
    199c:	70 e0       	ldi	r23, 0x00	; 0
    199e:	8a e0       	ldi	r24, 0x0A	; 10
    19a0:	bc df       	rcall	.-136    	; 0x191a <NRF24_Write_Buf>
	
	CE_SET();
    19a2:	c0 9a       	sbi	0x18, 0	; 24
    19a4:	8b e2       	ldi	r24, 0x2B	; 43
    19a6:	91 e0       	ldi	r25, 0x01	; 1
    19a8:	01 97       	sbiw	r24, 0x01	; 1
    19aa:	f1 f7       	brne	.-4      	; 0x19a8 <NRF24L01_RX_Mode+0x26>
    19ac:	00 c0       	rjmp	.+0      	; 0x19ae <NRF24L01_RX_Mode+0x2c>
    19ae:	00 00       	nop
	_delay_us(150); //Задержка минимум 130 мкс
	// Flush buffers
	NRF24_FlushRX();
    19b0:	d6 df       	rcall	.-84     	; 0x195e <NRF24_FlushRX>
	NRF24_FlushTX();
    19b2:	de cf       	rjmp	.-68     	; 0x1970 <NRF24_FlushTX>

000019b4 <NRF24L01_TX_Mode>:
}

//------------------------------------------------
void NRF24L01_TX_Mode(uint8_t *pBuf)
{//режим передатчика
	NRF24_Write_Buf(TX_ADDR, TX_ADDRESS0, TX_ADR_WIDTH);		//записываем адрес передатчика
    19b4:	43 e0       	ldi	r20, 0x03	; 3
    19b6:	63 e6       	ldi	r22, 0x63	; 99
    19b8:	70 e0       	ldi	r23, 0x00	; 0
    19ba:	80 e1       	ldi	r24, 0x10	; 16
    19bc:	ae df       	rcall	.-164    	; 0x191a <NRF24_Write_Buf>
	NRF24_Write_Buf(RX_ADDR_P0, TX_ADDRESS0, TX_ADR_WIDTH);	//записываем адрес приемника
    19be:	43 e0       	ldi	r20, 0x03	; 3
    19c0:	63 e6       	ldi	r22, 0x63	; 99
    19c2:	70 e0       	ldi	r23, 0x00	; 0
    19c4:	8a e0       	ldi	r24, 0x0A	; 10
    19c6:	a9 df       	rcall	.-174    	; 0x191a <NRF24_Write_Buf>
	CE_RESET();
    19c8:	c0 98       	cbi	0x18, 0	; 24
	// Flush buffers
	NRF24_FlushRX();
    19ca:	c9 df       	rcall	.-110    	; 0x195e <NRF24_FlushRX>
	NRF24_FlushTX();
    19cc:	d1 cf       	rjmp	.-94     	; 0x1970 <NRF24_FlushTX>

000019ce <NRF24_Transmit>:
}

//------------------------------------------------
void NRF24_Transmit(uint8_t addr,uint8_t *pBuf,uint8_t bytes)
{//передача данных в модуль
    19ce:	ff 92       	push	r15
    19d0:	0f 93       	push	r16
    19d2:	1f 93       	push	r17
    19d4:	cf 93       	push	r28
    19d6:	df 93       	push	r29
    19d8:	f6 2e       	mov	r15, r22
    19da:	07 2f       	mov	r16, r23
    19dc:	14 2f       	mov	r17, r20
	CE_RESET();
    19de:	c0 98       	cbi	0x18, 0	; 24
	CS_ON();
    19e0:	97 98       	cbi	0x12, 7	; 18
	spi_sendByte(addr);
    19e2:	51 df       	rcall	.-350    	; 0x1886 <spi_sendByte>
    19e4:	82 e0       	ldi	r24, 0x02	; 2
    19e6:	8a 95       	dec	r24
    19e8:	f1 f7       	brne	.-4      	; 0x19e6 <NRF24_Transmit+0x18>
    19ea:	00 c0       	rjmp	.+0      	; 0x19ec <NRF24_Transmit+0x1e>
    19ec:	cf 2d       	mov	r28, r15
    19ee:	d0 2f       	mov	r29, r16
    19f0:	ce 01       	movw	r24, r28
    19f2:	81 0f       	add	r24, r17
    19f4:	91 1d       	adc	r25, r1
    19f6:	8c 01       	movw	r16, r24
	_delay_us(1); //пауза в микросекунду для завершения процесса
	for (uint8_t i = 0 ; i < bytes ; i++)
    19f8:	c0 17       	cp	r28, r16
    19fa:	d1 07       	cpc	r29, r17
    19fc:	19 f0       	breq	.+6      	; 0x1a04 <NRF24_Transmit+0x36>
	{
		spi_sendByte(pBuf[i]);
    19fe:	89 91       	ld	r24, Y+
    1a00:	42 df       	rcall	.-380    	; 0x1886 <spi_sendByte>
    1a02:	fa cf       	rjmp	.-12     	; 0x19f8 <NRF24_Transmit+0x2a>
	}
	CS_OFF();
    1a04:	97 9a       	sbi	0x12, 7	; 18
	CE_SET();
    1a06:	c0 9a       	sbi	0x18, 0	; 24
}
    1a08:	df 91       	pop	r29
    1a0a:	cf 91       	pop	r28
    1a0c:	1f 91       	pop	r17
    1a0e:	0f 91       	pop	r16
    1a10:	ff 90       	pop	r15
    1a12:	08 95       	ret

00001a14 <NRF24L01_Send>:

//------------------------------------------------
uint8_t NRF24L01_Send(uint8_t *pBuf)
{//отправка данных в эфир
    1a14:	cf 93       	push	r28
    1a16:	df 93       	push	r29
    1a18:	ec 01       	movw	r28, r24
	uint8_t regval=0x00;						//переменная для отправки в конфигурационный регистр
	NRF24L01_TX_Mode(pBuf);					//включаем режим передачи
    1a1a:	cc df       	rcall	.-104    	; 0x19b4 <NRF24L01_TX_Mode>
	regval = NRF24_ReadReg(CONFIG);	//сохраняем значения конфигурационного региста
    1a1c:	80 e0       	ldi	r24, 0x00	; 0
    1a1e:	3c df       	rcall	.-392    	; 0x1898 <NRF24_ReadReg>
    1a20:	8e 7f       	andi	r24, 0xFE	; 254
	//если модуль ушел в спящий режим, то разбудим его, включив бит PWR_UP и выключив PRIM_RX
	regval |= (1<<PWR_UP);
	regval &= ~(1<<PRIM_RX);
	NRF24_WriteReg(CONFIG,regval);//записываем новое значение конфигурационного регистра
    1a22:	68 2f       	mov	r22, r24
    1a24:	62 60       	ori	r22, 0x02	; 2
    1a26:	80 e0       	ldi	r24, 0x00	; 0
    1a28:	42 df       	rcall	.-380    	; 0x18ae <NRF24_WriteReg>
    1a2a:	8b e2       	ldi	r24, 0x2B	; 43
    1a2c:	91 e0       	ldi	r25, 0x01	; 1
    1a2e:	01 97       	sbiw	r24, 0x01	; 1
    1a30:	f1 f7       	brne	.-4      	; 0x1a2e <NRF24L01_Send+0x1a>
    1a32:	00 c0       	rjmp	.+0      	; 0x1a34 <NRF24L01_Send+0x20>
    1a34:	00 00       	nop
	_delay_us(150); //Задержка минимум 130 мкс
	//Отправим данные в воздух
	NRF24_Transmit(WR_TX_PLOAD, pBuf, TX_PLOAD_WIDTH);//отправка данных
    1a36:	40 e2       	ldi	r20, 0x20	; 32
    1a38:	be 01       	movw	r22, r28
    1a3a:	80 ea       	ldi	r24, 0xA0	; 160
    1a3c:	c8 df       	rcall	.-112    	; 0x19ce <NRF24_Transmit>
	CE_SET();
    1a3e:	c0 9a       	sbi	0x18, 0	; 24
    1a40:	98 e2       	ldi	r25, 0x28	; 40
    1a42:	9a 95       	dec	r25
    1a44:	f1 f7       	brne	.-4      	; 0x1a42 <NRF24L01_Send+0x2e>
	_delay_us(15); //minimum 10us high pulse (Page 21)
	CE_RESET();
    1a46:	c0 98       	cbi	0x18, 0	; 24
    1a48:	87 ee       	ldi	r24, 0xE7	; 231
    1a4a:	93 e0       	ldi	r25, 0x03	; 3
    1a4c:	01 97       	sbiw	r24, 0x01	; 1
    1a4e:	f1 f7       	brne	.-4      	; 0x1a4c <NRF24L01_Send+0x38>
    1a50:	00 c0       	rjmp	.+0      	; 0x1a52 <NRF24L01_Send+0x3e>
    1a52:	00 00       	nop
	_delay_us(500);
	NRF24L01_RX_Mode();				//переход в режим приема
    1a54:	96 df       	rcall	.-212    	; 0x1982 <NRF24L01_RX_Mode>
	return 0;
}
    1a56:	80 e0       	ldi	r24, 0x00	; 0
    1a58:	df 91       	pop	r29
    1a5a:	cf 91       	pop	r28
    1a5c:	08 95       	ret

00001a5e <nrf24_init>:

//------------------------------------------------
void nrf24_init(void)
{//инициализация
	CE_RESET();							//опускаем к земле вывод ce
    1a5e:	c0 98       	cbi	0x18, 0	; 24
    1a60:	8f e0       	ldi	r24, 0x0F	; 15
    1a62:	97 e2       	ldi	r25, 0x27	; 39
    1a64:	01 97       	sbiw	r24, 0x01	; 1
    1a66:	f1 f7       	brne	.-4      	; 0x1a64 <nrf24_init+0x6>
    1a68:	00 c0       	rjmp	.+0      	; 0x1a6a <nrf24_init+0xc>
    1a6a:	00 00       	nop
	_delay_us(5000);					//задержка 5 мс
	//записываем конфигурационный байт,
	NRF24_WriteReg(CONFIG, 0x0a);		// Set PWR_UP bit, enable CRC(1 byte) &Prim_RX:0 (Transmitter)
    1a6c:	6a e0       	ldi	r22, 0x0A	; 10
    1a6e:	80 e0       	ldi	r24, 0x00	; 0
    1a70:	1e df       	rcall	.-452    	; 0x18ae <NRF24_WriteReg>
    1a72:	8f e0       	ldi	r24, 0x0F	; 15
    1a74:	97 e2       	ldi	r25, 0x27	; 39
    1a76:	01 97       	sbiw	r24, 0x01	; 1
    1a78:	f1 f7       	brne	.-4      	; 0x1a76 <nrf24_init+0x18>
    1a7a:	00 c0       	rjmp	.+0      	; 0x1a7c <nrf24_init+0x1e>
    1a7c:	00 00       	nop
	_delay_us(5000);
	NRF24_WriteReg(EN_AA, 0x00);		// Enable Pipe0
    1a7e:	60 e0       	ldi	r22, 0x00	; 0
    1a80:	81 e0       	ldi	r24, 0x01	; 1
    1a82:	15 df       	rcall	.-470    	; 0x18ae <NRF24_WriteReg>
	NRF24_WriteReg(EN_RXADDR, 0x01);	// Enable Pipe0
    1a84:	61 e0       	ldi	r22, 0x01	; 1
    1a86:	82 e0       	ldi	r24, 0x02	; 2
    1a88:	12 df       	rcall	.-476    	; 0x18ae <NRF24_WriteReg>
	NRF24_WriteReg(SETUP_AW, 0x01);		// Setup address width=3 bytes
    1a8a:	61 e0       	ldi	r22, 0x01	; 1
    1a8c:	83 e0       	ldi	r24, 0x03	; 3
    1a8e:	0f df       	rcall	.-482    	; 0x18ae <NRF24_WriteReg>
	NRF24_WriteReg(SETUP_RETR, 0x00);	// 1500us, 15 retrans
    1a90:	60 e0       	ldi	r22, 0x00	; 0
    1a92:	84 e0       	ldi	r24, 0x04	; 4
    1a94:	0c df       	rcall	.-488    	; 0x18ae <NRF24_WriteReg>
	NRF24_ToggleFeatures();				//активация команд
    1a96:	15 df       	rcall	.-470    	; 0x18c2 <NRF24_ToggleFeatures>
	NRF24_WriteReg(FEATURE, 0x07);			//установка стандартных значений регистра FEATURE
    1a98:	67 e0       	ldi	r22, 0x07	; 7
    1a9a:	8d e1       	ldi	r24, 0x1D	; 29
    1a9c:	08 df       	rcall	.-496    	; 0x18ae <NRF24_WriteReg>
	NRF24_WriteReg(DYNPD, 0);			//отключение динамического размера полезной нагрузки
    1a9e:	60 e0       	ldi	r22, 0x00	; 0
    1aa0:	8c e1       	ldi	r24, 0x1C	; 28
    1aa2:	05 df       	rcall	.-502    	; 0x18ae <NRF24_WriteReg>
	NRF24_WriteReg(STATUS, 0x70);		//Reset flags for IRQ
    1aa4:	60 e7       	ldi	r22, 0x70	; 112
    1aa6:	87 e0       	ldi	r24, 0x07	; 7
    1aa8:	02 df       	rcall	.-508    	; 0x18ae <NRF24_WriteReg>
	NRF24_WriteReg(RF_CH, 76);			// частота 2476 MHz
    1aaa:	6c e4       	ldi	r22, 0x4C	; 76
    1aac:	85 e0       	ldi	r24, 0x05	; 5
    1aae:	ff de       	rcall	.-514    	; 0x18ae <NRF24_WriteReg>
	NRF24_WriteReg(RF_SETUP, 0x06);		//TX_PWR:0dBm, Datarate:1Mbps
    1ab0:	66 e0       	ldi	r22, 0x06	; 6
    1ab2:	86 e0       	ldi	r24, 0x06	; 6
    1ab4:	fc de       	rcall	.-520    	; 0x18ae <NRF24_WriteReg>
	NRF24_Write_Buf(TX_ADDR, TX_ADDRESS0, TX_ADR_WIDTH);//запись адреса передачи
    1ab6:	43 e0       	ldi	r20, 0x03	; 3
    1ab8:	63 e6       	ldi	r22, 0x63	; 99
    1aba:	70 e0       	ldi	r23, 0x00	; 0
    1abc:	80 e1       	ldi	r24, 0x10	; 16
    1abe:	2d df       	rcall	.-422    	; 0x191a <NRF24_Write_Buf>
	NRF24_Write_Buf(RX_ADDR_P1, TX_ADDRESS0, TX_ADR_WIDTH);//запись адреса приема
    1ac0:	43 e0       	ldi	r20, 0x03	; 3
    1ac2:	63 e6       	ldi	r22, 0x63	; 99
    1ac4:	70 e0       	ldi	r23, 0x00	; 0
    1ac6:	8b e0       	ldi	r24, 0x0B	; 11
    1ac8:	28 df       	rcall	.-432    	; 0x191a <NRF24_Write_Buf>
	NRF24_WriteReg(RX_PW_P0, TX_PLOAD_WIDTH); //Number of bytes in RX payload in data pipe 1
    1aca:	60 e2       	ldi	r22, 0x20	; 32
    1acc:	81 e1       	ldi	r24, 0x11	; 17
    1ace:	ef de       	rcall	.-546    	; 0x18ae <NRF24_WriteReg>
	//пока уходим в режим приёмника
	NRF24L01_RX_Mode();					//режим приема
    1ad0:	58 df       	rcall	.-336    	; 0x1982 <NRF24L01_RX_Mode>
	LED_OFF();
    1ad2:	96 98       	cbi	0x12, 6	; 18
    1ad4:	08 95       	ret

00001ad6 <nrf24_receive>:

//--------------------------------------------------
void nrf24_receive(void)
{
	uint8_t status = 0x01;	//переменная статус
	status = NRF24_ReadReg(STATUS);	//чтение значения регистра статуса
    1ad6:	87 e0       	ldi	r24, 0x07	; 7
    1ad8:	df de       	rcall	.-578    	; 0x1898 <NRF24_ReadReg>
	if(status & RX_DR)				//если есть данные на прием
    1ada:	86 ff       	sbrs	r24, 6
    1adc:	0b c0       	rjmp	.+22     	; 0x1af4 <nrf24_receive+0x1e>
	{
		NRF24_Read_Buf(RD_RX_PLOAD,rx_buf,TX_PLOAD_WIDTH);//чтение буфера
    1ade:	40 e2       	ldi	r20, 0x20	; 32
    1ae0:	6c e8       	ldi	r22, 0x8C	; 140
    1ae2:	70 e0       	ldi	r23, 0x00	; 0
    1ae4:	81 e6       	ldi	r24, 0x61	; 97
    1ae6:	f8 de       	rcall	.-528    	; 0x18d8 <NRF24_Read_Buf>
		NRF24_WriteReg(STATUS, 0x40);	//запись в регистр статуса 1 в шестой бит, обнуление остальных
    1ae8:	60 e4       	ldi	r22, 0x40	; 64
    1aea:	87 e0       	ldi	r24, 0x07	; 7
    1aec:	e0 de       	rcall	.-576    	; 0x18ae <NRF24_WriteReg>
		f_rx = 1;						//поднимаем флаг приема
    1aee:	81 e0       	ldi	r24, 0x01	; 1
    1af0:	80 93 6b 00 	sts	0x006B, r24	; 0x80006b <f_rx>
    1af4:	08 95       	ret

00001af6 <main>:

static void (*jump_to_app)(void) = 0x0000;

int main(void)
{
	port_init();							//инициализация портов
    1af6:	b3 de       	rcall	.-666    	; 0x185e <port_init>
	spi_init();								//инициализация SPI
    1af8:	bd de       	rcall	.-646    	; 0x1874 <spi_init>
	nrf24_init();
    1afa:	b1 df       	rcall	.-158    	; 0x1a5e <nrf24_init>
	uint8_t blink_counter = 2;
	uint16_t load_pause = 0;

	while (blink_counter)
	{
		LED_ON();
    1afc:	96 9a       	sbi	0x12, 6	; 18
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1afe:	2f e7       	ldi	r18, 0x7F	; 127
    1b00:	88 e3       	ldi	r24, 0x38	; 56
    1b02:	91 e0       	ldi	r25, 0x01	; 1
    1b04:	21 50       	subi	r18, 0x01	; 1
    1b06:	80 40       	sbci	r24, 0x00	; 0
    1b08:	90 40       	sbci	r25, 0x00	; 0
    1b0a:	e1 f7       	brne	.-8      	; 0x1b04 <main+0xe>
    1b0c:	00 c0       	rjmp	.+0      	; 0x1b0e <main+0x18>
    1b0e:	00 00       	nop
		_delay_ms(50);
		LED_OFF();
    1b10:	96 98       	cbi	0x12, 6	; 18
    1b12:	ef e7       	ldi	r30, 0x7F	; 127
    1b14:	f8 e3       	ldi	r31, 0x38	; 56
    1b16:	21 e0       	ldi	r18, 0x01	; 1
    1b18:	e1 50       	subi	r30, 0x01	; 1
    1b1a:	f0 40       	sbci	r31, 0x00	; 0
    1b1c:	20 40       	sbci	r18, 0x00	; 0
    1b1e:	e1 f7       	brne	.-8      	; 0x1b18 <main+0x22>
    1b20:	00 c0       	rjmp	.+0      	; 0x1b22 <main+0x2c>
    1b22:	00 00       	nop
	uint8_t blink_counter = 2;
	uint16_t load_pause = 0;

	while (blink_counter)
	{
		LED_ON();
    1b24:	96 9a       	sbi	0x12, 6	; 18
    1b26:	8f e7       	ldi	r24, 0x7F	; 127
    1b28:	98 e3       	ldi	r25, 0x38	; 56
    1b2a:	e1 e0       	ldi	r30, 0x01	; 1
    1b2c:	81 50       	subi	r24, 0x01	; 1
    1b2e:	90 40       	sbci	r25, 0x00	; 0
    1b30:	e0 40       	sbci	r30, 0x00	; 0
    1b32:	e1 f7       	brne	.-8      	; 0x1b2c <main+0x36>
    1b34:	00 c0       	rjmp	.+0      	; 0x1b36 <main+0x40>
    1b36:	00 00       	nop
		_delay_ms(50);
		LED_OFF();
    1b38:	96 98       	cbi	0x12, 6	; 18
    1b3a:	ff e7       	ldi	r31, 0x7F	; 127
    1b3c:	28 e3       	ldi	r18, 0x38	; 56
    1b3e:	81 e0       	ldi	r24, 0x01	; 1
    1b40:	f1 50       	subi	r31, 0x01	; 1
    1b42:	20 40       	sbci	r18, 0x00	; 0
    1b44:	80 40       	sbci	r24, 0x00	; 0
    1b46:	e1 f7       	brne	.-8      	; 0x1b40 <main+0x4a>
    1b48:	00 c0       	rjmp	.+0      	; 0x1b4a <main+0x54>
    1b4a:	00 00       	nop
    1b4c:	e1 2c       	mov	r14, r1
    1b4e:	f1 2c       	mov	r15, r1
    1b50:	c0 e0       	ldi	r28, 0x00	; 0
    1b52:	d0 e0       	ldi	r29, 0x00	; 0
					f_wait = 1;
				}

				if (rx_buf[1] == 'F')		//
				{
					LED_TGL();
    1b54:	90 e4       	ldi	r25, 0x40	; 64
    1b56:	49 2e       	mov	r4, r25

	do 
		{
		data = *tmp++;
		data |= *tmp++ << 8;
		boot_page_fill(baddr, data);	// call asm routine.
    1b58:	55 24       	eor	r5, r5
    1b5a:	53 94       	inc	r5
    1b5c:	66 24       	eor	r6, r6
    1b5e:	63 94       	inc	r6
		baddr += 2;			// Select next word in memory
		size -= 2;			// Reduce number of bytes to write by two
		} 
	while (size);				// Loop until all bytes written

	boot_page_write(pagestart);
    1b60:	25 e0       	ldi	r18, 0x05	; 5
    1b62:	32 2e       	mov	r3, r18
	boot_spm_busy_wait();
	boot_rww_enable();		// Re-enable the RWW section
    1b64:	31 e1       	ldi	r19, 0x11	; 17
    1b66:	23 2e       	mov	r2, r19
						gBuffer[i] = rx_buf[i+4];
					}

					writeFlashPage(address, size);
					//_delay_ms(100);
					tx_buf[0] = BUT_ADDR;
    1b68:	17 e0       	ldi	r17, 0x07	; 7
					tx_buf[1] = 'N';
    1b6a:	0e e4       	ldi	r16, 0x4E	; 78
{
	// erase only main section (bootloader protection)
	uint32_t addr = 0;
	while (APP_END > addr) 
	{
		boot_page_erase(addr);		// Perform page erase
    1b6c:	43 e0       	ldi	r20, 0x03	; 3
    1b6e:	74 2e       	mov	r7, r20
		{
			if (rx_buf[0] == BUT_ADDR)		//если первый принятый байт совпадает с адресом кнопки
			{
				if (rx_buf[1] == 'J')
				{
					jump_to_app();
    1b70:	c1 2c       	mov	r12, r1
    1b72:	d1 2c       	mov	r13, r1

	//wdt_enable(WDTO_1S);

	while (1) 
	{
		nrf24_receive();
    1b74:	b0 df       	rcall	.-160    	; 0x1ad6 <nrf24_receive>

		if(f_rx == 1)						//если флаг приема поднят
    1b76:	80 91 6b 00 	lds	r24, 0x006B	; 0x80006b <f_rx>
    1b7a:	81 30       	cpi	r24, 0x01	; 1
    1b7c:	09 f0       	breq	.+2      	; 0x1b80 <main+0x8a>
    1b7e:	83 c0       	rjmp	.+262    	; 0x1c86 <main+0x190>
		{
			if (rx_buf[0] == BUT_ADDR)		//если первый принятый байт совпадает с адресом кнопки
    1b80:	80 91 8c 00 	lds	r24, 0x008C	; 0x80008c <rx_buf>
    1b84:	87 30       	cpi	r24, 0x07	; 7
    1b86:	09 f0       	breq	.+2      	; 0x1b8a <main+0x94>
    1b88:	7c c0       	rjmp	.+248    	; 0x1c82 <main+0x18c>
			{
				if (rx_buf[1] == 'J')
    1b8a:	80 91 8d 00 	lds	r24, 0x008D	; 0x80008d <rx_buf+0x1>
    1b8e:	8a 34       	cpi	r24, 0x4A	; 74
    1b90:	11 f4       	brne	.+4      	; 0x1b96 <main+0xa0>
				{
					jump_to_app();
    1b92:	f6 01       	movw	r30, r12
    1b94:	09 95       	icall
				}

				if (rx_buf[1] == 'E')	
    1b96:	80 91 8d 00 	lds	r24, 0x008D	; 0x80008d <rx_buf+0x1>
    1b9a:	85 34       	cpi	r24, 0x45	; 69
    1b9c:	91 f4       	brne	.+36     	; 0x1bc2 <main+0xcc>
    1b9e:	e0 e0       	ldi	r30, 0x00	; 0
    1ba0:	f0 e0       	ldi	r31, 0x00	; 0
{
	// erase only main section (bootloader protection)
	uint32_t addr = 0;
	while (APP_END > addr) 
	{
		boot_page_erase(addr);		// Perform page erase
    1ba2:	70 92 57 00 	sts	0x0057, r7	; 0x800057 <__TEXT_REGION_LENGTH__+0x7fe057>
    1ba6:	e8 95       	spm
		boot_spm_busy_wait();		// Wait until the memory is erased.
    1ba8:	07 b6       	in	r0, 0x37	; 55
    1baa:	00 fc       	sbrc	r0, 0
    1bac:	fd cf       	rjmp	.-6      	; 0x1ba8 <main+0xb2>
    1bae:	e0 5c       	subi	r30, 0xC0	; 192
    1bb0:	ff 4f       	sbci	r31, 0xFF	; 255

static inline void eraseFlash(void)
{
	// erase only main section (bootloader protection)
	uint32_t addr = 0;
	while (APP_END > addr) 
    1bb2:	e1 15       	cp	r30, r1
    1bb4:	28 e1       	ldi	r18, 0x18	; 24
    1bb6:	f2 07       	cpc	r31, r18
    1bb8:	a1 f7       	brne	.-24     	; 0x1ba2 <main+0xac>
	{
		boot_page_erase(addr);		// Perform page erase
		boot_spm_busy_wait();		// Wait until the memory is erased.
		addr += SPM_PAGESIZE;
	}
	boot_rww_enable();
    1bba:	20 92 57 00 	sts	0x0057, r2	; 0x800057 <__TEXT_REGION_LENGTH__+0x7fe057>
    1bbe:	e8 95       	spm
    1bc0:	0c c0       	rjmp	.+24     	; 0x1bda <main+0xe4>
				if (rx_buf[1] == 'E')	
				{
					eraseFlash();
				}

				if (rx_buf[1] == 'W')	
    1bc2:	87 35       	cpi	r24, 0x57	; 87
    1bc4:	51 f4       	brne	.+20     	; 0x1bda <main+0xe4>
				{
					LED_ON();
    1bc6:	96 9a       	sbi	0x12, 6	; 18
					tx_buf[0] = BUT_ADDR;
    1bc8:	10 93 6c 00 	sts	0x006C, r17	; 0x80006c <tx_buf>
					tx_buf[1] = 'W';
    1bcc:	80 93 6d 00 	sts	0x006D, r24	; 0x80006d <tx_buf+0x1>
					NRF24L01_Send(tx_buf);
    1bd0:	8c e6       	ldi	r24, 0x6C	; 108
    1bd2:	90 e0       	ldi	r25, 0x00	; 0
    1bd4:	1f df       	rcall	.-450    	; 0x1a14 <NRF24L01_Send>
					f_wait = 1;
    1bd6:	60 92 66 00 	sts	0x0066, r6	; 0x800066 <__data_end>
				}

				if (rx_buf[1] == 'F')		//
    1bda:	80 91 8d 00 	lds	r24, 0x008D	; 0x80008d <rx_buf+0x1>
    1bde:	86 34       	cpi	r24, 0x46	; 70
    1be0:	09 f0       	breq	.+2      	; 0x1be4 <main+0xee>
    1be2:	4f c0       	rjmp	.+158    	; 0x1c82 <main+0x18c>
				{
					LED_TGL();
    1be4:	82 b3       	in	r24, 0x12	; 18
    1be6:	84 25       	eor	r24, r4
    1be8:	82 bb       	out	0x12, r24	; 18
					pagebuf_t size;
					size = rx_buf[2];
    1bea:	60 91 8e 00 	lds	r22, 0x008E	; 0x80008e <rx_buf+0x2>
					address = rx_buf[3]; //
    1bee:	80 91 8f 00 	lds	r24, 0x008F	; 0x80008f <rx_buf+0x3>
    1bf2:	28 2f       	mov	r18, r24
    1bf4:	30 e0       	ldi	r19, 0x00	; 0
    1bf6:	30 93 69 00 	sts	0x0069, r19	; 0x800069 <address+0x1>
    1bfa:	20 93 68 00 	sts	0x0068, r18	; 0x800068 <address>
    1bfe:	a0 e9       	ldi	r26, 0x90	; 144
    1c00:	b0 e0       	ldi	r27, 0x00	; 0

					for (uint8_t i = 0; i < size; i++)
    1c02:	ec ea       	ldi	r30, 0xAC	; 172
    1c04:	f0 e0       	ldi	r31, 0x00	; 0
    1c06:	90 e0       	ldi	r25, 0x00	; 0
    1c08:	96 17       	cp	r25, r22
    1c0a:	21 f0       	breq	.+8      	; 0x1c14 <main+0x11e>
					{
						gBuffer[i] = rx_buf[i+4];
    1c0c:	2d 91       	ld	r18, X+
    1c0e:	21 93       	st	Z+, r18
					LED_TGL();
					pagebuf_t size;
					size = rx_buf[2];
					address = rx_buf[3]; //

					for (uint8_t i = 0; i < size; i++)
    1c10:	9f 5f       	subi	r25, 0xFF	; 255
    1c12:	fa cf       	rjmp	.-12     	; 0x1c08 <main+0x112>
	boot_rww_enable();
}

static inline uint16_t writeFlashPage(uint16_t waddr, pagebuf_t size)
{
	uint32_t pagestart = (uint32_t)waddr<<1;
    1c14:	90 e0       	ldi	r25, 0x00	; 0
    1c16:	a0 e0       	ldi	r26, 0x00	; 0
    1c18:	b0 e0       	ldi	r27, 0x00	; 0
    1c1a:	4c 01       	movw	r8, r24
    1c1c:	5d 01       	movw	r10, r26
    1c1e:	88 0c       	add	r8, r8
    1c20:	99 1c       	adc	r9, r9
    1c22:	aa 1c       	adc	r10, r10
    1c24:	bb 1c       	adc	r11, r11
	uint32_t baddr = pagestart;
	uint16_t data;
	uint8_t *tmp = gBuffer;
    1c26:	20 91 ac 00 	lds	r18, 0x00AC	; 0x8000ac <gBuffer>
    1c2a:	ac ea       	ldi	r26, 0xAC	; 172
    1c2c:	b0 e0       	ldi	r27, 0x00	; 0
    1c2e:	a4 01       	movw	r20, r8

	do 
		{
		data = *tmp++;
		data |= *tmp++ << 8;
		boot_page_fill(baddr, data);	// call asm routine.
    1c30:	c4 01       	movw	r24, r8
    1c32:	8c 5a       	subi	r24, 0xAC	; 172
    1c34:	90 40       	sbci	r25, 0x00	; 0
    1c36:	fc 01       	movw	r30, r24
    1c38:	ea 0f       	add	r30, r26
    1c3a:	fb 1f       	adc	r31, r27
    1c3c:	11 96       	adiw	r26, 0x01	; 1
    1c3e:	7c 91       	ld	r23, X
    1c40:	11 97       	sbiw	r26, 0x01	; 1
    1c42:	30 e0       	ldi	r19, 0x00	; 0
    1c44:	37 2b       	or	r19, r23
    1c46:	09 01       	movw	r0, r18
    1c48:	50 92 57 00 	sts	0x0057, r5	; 0x800057 <__TEXT_REGION_LENGTH__+0x7fe057>
    1c4c:	e8 95       	spm
    1c4e:	11 24       	eor	r1, r1

		baddr += 2;			// Select next word in memory
		size -= 2;			// Reduce number of bytes to write by two
    1c50:	62 50       	subi	r22, 0x02	; 2
    1c52:	12 96       	adiw	r26, 0x02	; 2
		} 
	while (size);				// Loop until all bytes written
    1c54:	66 23       	and	r22, r22
    1c56:	11 f0       	breq	.+4      	; 0x1c5c <main+0x166>
	uint8_t *tmp = gBuffer;

	do 
		{
		data = *tmp++;
		data |= *tmp++ << 8;
    1c58:	2c 91       	ld	r18, X
    1c5a:	ed cf       	rjmp	.-38     	; 0x1c36 <main+0x140>
		baddr += 2;			// Select next word in memory
		size -= 2;			// Reduce number of bytes to write by two
		} 
	while (size);				// Loop until all bytes written

	boot_page_write(pagestart);
    1c5c:	fa 01       	movw	r30, r20
    1c5e:	30 92 57 00 	sts	0x0057, r3	; 0x800057 <__TEXT_REGION_LENGTH__+0x7fe057>
    1c62:	e8 95       	spm
	boot_spm_busy_wait();
    1c64:	07 b6       	in	r0, 0x37	; 55
    1c66:	00 fc       	sbrc	r0, 0
    1c68:	fd cf       	rjmp	.-6      	; 0x1c64 <main+0x16e>
	boot_rww_enable();		// Re-enable the RWW section
    1c6a:	20 92 57 00 	sts	0x0057, r2	; 0x800057 <__TEXT_REGION_LENGTH__+0x7fe057>
    1c6e:	e8 95       	spm
						gBuffer[i] = rx_buf[i+4];
					}

					writeFlashPage(address, size);
					//_delay_ms(100);
					tx_buf[0] = BUT_ADDR;
    1c70:	10 93 6c 00 	sts	0x006C, r17	; 0x80006c <tx_buf>
					tx_buf[1] = 'N';
    1c74:	00 93 6d 00 	sts	0x006D, r16	; 0x80006d <tx_buf+0x1>
					NRF24L01_Send(tx_buf);
    1c78:	8c e6       	ldi	r24, 0x6C	; 108
    1c7a:	90 e0       	ldi	r25, 0x00	; 0
    1c7c:	cb de       	rcall	.-618    	; 0x1a14 <NRF24L01_Send>
					load_pause = 0;
    1c7e:	c0 e0       	ldi	r28, 0x00	; 0
    1c80:	d0 e0       	ldi	r29, 0x00	; 0
				}

			}

			f_rx = 0;						//опускаем флаг приема
    1c82:	10 92 6b 00 	sts	0x006B, r1	; 0x80006b <f_rx>
		}

		wdt_reset();
    1c86:	a8 95       	wdr

		if (!f_wait)
    1c88:	80 91 66 00 	lds	r24, 0x0066	; 0x800066 <__data_end>
    1c8c:	81 11       	cpse	r24, r1
    1c8e:	13 c0       	rjmp	.+38     	; 0x1cb6 <main+0x1c0>
		{
			if (cnt++ >= WAIT_VALUE) 
    1c90:	47 01       	movw	r8, r14
    1c92:	ff ef       	ldi	r31, 0xFF	; 255
    1c94:	8f 1a       	sub	r8, r31
    1c96:	9f 0a       	sbc	r9, r31
    1c98:	28 ee       	ldi	r18, 0xE8	; 232
    1c9a:	e2 16       	cp	r14, r18
    1c9c:	23 e0       	ldi	r18, 0x03	; 3
    1c9e:	f2 06       	cpc	r15, r18
    1ca0:	10 f0       	brcs	.+4      	; 0x1ca6 <main+0x1b0>
			{
				jump_to_app();			// Jump to application sector
    1ca2:	f6 01       	movw	r30, r12
    1ca4:	09 95       	icall
    1ca6:	8f ec       	ldi	r24, 0xCF	; 207
    1ca8:	97 e0       	ldi	r25, 0x07	; 7
    1caa:	01 97       	sbiw	r24, 0x01	; 1
    1cac:	f1 f7       	brne	.-4      	; 0x1caa <main+0x1b4>
    1cae:	00 c0       	rjmp	.+0      	; 0x1cb0 <main+0x1ba>
    1cb0:	00 00       	nop

		wdt_reset();

		if (!f_wait)
		{
			if (cnt++ >= WAIT_VALUE) 
    1cb2:	74 01       	movw	r14, r8
    1cb4:	5f cf       	rjmp	.-322    	; 0x1b74 <main+0x7e>
			}
			_delay_ms(1);		
		}
		else
		{
			load_pause++;
    1cb6:	21 96       	adiw	r28, 0x01	; 1
			if (load_pause >= 1000)
    1cb8:	c8 3e       	cpi	r28, 0xE8	; 232
    1cba:	93 e0       	ldi	r25, 0x03	; 3
    1cbc:	d9 07       	cpc	r29, r25
    1cbe:	08 f4       	brcc	.+2      	; 0x1cc2 <main+0x1cc>
    1cc0:	59 cf       	rjmp	.-334    	; 0x1b74 <main+0x7e>
			{
				tx_buf[0] = BUT_ADDR;
    1cc2:	10 93 6c 00 	sts	0x006C, r17	; 0x80006c <tx_buf>
				tx_buf[1] = 'N';
    1cc6:	00 93 6d 00 	sts	0x006D, r16	; 0x80006d <tx_buf+0x1>
				NRF24L01_Send(tx_buf);
    1cca:	8c e6       	ldi	r24, 0x6C	; 108
    1ccc:	90 e0       	ldi	r25, 0x00	; 0
    1cce:	a2 de       	rcall	.-700    	; 0x1a14 <NRF24L01_Send>
    1cd0:	ef ec       	ldi	r30, 0xCF	; 207
    1cd2:	f7 e0       	ldi	r31, 0x07	; 7
    1cd4:	31 97       	sbiw	r30, 0x01	; 1
    1cd6:	f1 f7       	brne	.-4      	; 0x1cd4 <main+0x1de>
    1cd8:	00 c0       	rjmp	.+0      	; 0x1cda <main+0x1e4>
    1cda:	00 00       	nop
				_delay_ms(1);
				load_pause = 0;
    1cdc:	c0 e0       	ldi	r28, 0x00	; 0
    1cde:	d0 e0       	ldi	r29, 0x00	; 0
    1ce0:	49 cf       	rjmp	.-366    	; 0x1b74 <main+0x7e>

00001ce2 <_exit>:
    1ce2:	f8 94       	cli

00001ce4 <__stop_program>:
    1ce4:	ff cf       	rjmp	.-2      	; 0x1ce4 <__stop_program>
