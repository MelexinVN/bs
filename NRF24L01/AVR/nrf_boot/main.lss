
main.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000436  00001800  00001800  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000006  00800060  00001c36  000004ca  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000009c  00800066  00800066  000004d0  2**0
                  ALLOC
  3 .stab         00001230  00000000  00000000  000004d0  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      0000140b  00000000  00000000  00001700  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000030  00000000  00000000  00002b0b  2**0
                  CONTENTS, READONLY
  6 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00002b3c  2**2
                  CONTENTS, READONLY
  7 .debug_info   0000048c  00000000  00000000  00002b78  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 0000044e  00000000  00000000  00003004  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000001a  00000000  00000000  00003452  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000017a  00000000  00000000  0000346c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00001800 <__vectors>:
    1800:	12 c0       	rjmp	.+36     	; 0x1826 <__ctors_end>
    1802:	2c c0       	rjmp	.+88     	; 0x185c <__bad_interrupt>
    1804:	2b c0       	rjmp	.+86     	; 0x185c <__bad_interrupt>
    1806:	2a c0       	rjmp	.+84     	; 0x185c <__bad_interrupt>
    1808:	29 c0       	rjmp	.+82     	; 0x185c <__bad_interrupt>
    180a:	28 c0       	rjmp	.+80     	; 0x185c <__bad_interrupt>
    180c:	27 c0       	rjmp	.+78     	; 0x185c <__bad_interrupt>
    180e:	26 c0       	rjmp	.+76     	; 0x185c <__bad_interrupt>
    1810:	25 c0       	rjmp	.+74     	; 0x185c <__bad_interrupt>
    1812:	24 c0       	rjmp	.+72     	; 0x185c <__bad_interrupt>
    1814:	23 c0       	rjmp	.+70     	; 0x185c <__bad_interrupt>
    1816:	22 c0       	rjmp	.+68     	; 0x185c <__bad_interrupt>
    1818:	21 c0       	rjmp	.+66     	; 0x185c <__bad_interrupt>
    181a:	20 c0       	rjmp	.+64     	; 0x185c <__bad_interrupt>
    181c:	1f c0       	rjmp	.+62     	; 0x185c <__bad_interrupt>
    181e:	1e c0       	rjmp	.+60     	; 0x185c <__bad_interrupt>
    1820:	1d c0       	rjmp	.+58     	; 0x185c <__bad_interrupt>
    1822:	1c c0       	rjmp	.+56     	; 0x185c <__bad_interrupt>
    1824:	1b c0       	rjmp	.+54     	; 0x185c <__bad_interrupt>

00001826 <__ctors_end>:
    1826:	11 24       	eor	r1, r1
    1828:	1f be       	out	0x3f, r1	; 63
    182a:	cf e5       	ldi	r28, 0x5F	; 95
    182c:	d4 e0       	ldi	r29, 0x04	; 4
    182e:	de bf       	out	0x3e, r29	; 62
    1830:	cd bf       	out	0x3d, r28	; 61

00001832 <__do_copy_data>:
    1832:	10 e0       	ldi	r17, 0x00	; 0
    1834:	a0 e6       	ldi	r26, 0x60	; 96
    1836:	b0 e0       	ldi	r27, 0x00	; 0
    1838:	e6 e3       	ldi	r30, 0x36	; 54
    183a:	fc e1       	ldi	r31, 0x1C	; 28
    183c:	02 c0       	rjmp	.+4      	; 0x1842 <__do_copy_data+0x10>
    183e:	05 90       	lpm	r0, Z+
    1840:	0d 92       	st	X+, r0
    1842:	a6 36       	cpi	r26, 0x66	; 102
    1844:	b1 07       	cpc	r27, r17
    1846:	d9 f7       	brne	.-10     	; 0x183e <__do_copy_data+0xc>

00001848 <__do_clear_bss>:
    1848:	21 e0       	ldi	r18, 0x01	; 1
    184a:	a6 e6       	ldi	r26, 0x66	; 102
    184c:	b0 e0       	ldi	r27, 0x00	; 0
    184e:	01 c0       	rjmp	.+2      	; 0x1852 <.do_clear_bss_start>

00001850 <.do_clear_bss_loop>:
    1850:	1d 92       	st	X+, r1

00001852 <.do_clear_bss_start>:
    1852:	a2 30       	cpi	r26, 0x02	; 2
    1854:	b2 07       	cpc	r27, r18
    1856:	e1 f7       	brne	.-8      	; 0x1850 <.do_clear_bss_loop>
    1858:	48 d1       	rcall	.+656    	; 0x1aea <main>
    185a:	eb c1       	rjmp	.+982    	; 0x1c32 <_exit>

0000185c <__bad_interrupt>:
    185c:	d1 cf       	rjmp	.-94     	; 0x1800 <__vectors>

0000185e <port_init>:
void port_init(void)//Инициализация портов
{
	// Input/Output Ports initialization
	// Port B initialization
	// Function: Bit7=In Bit6=In Bit5=Out Bit4=In Bit3=Out Bit2=Out Bit1=In Bit0=Out
	DDRB=(0<<DDB7) | (0<<DDB6) | (1<<DDB5) | (0<<DDB4) | (1<<DDB3) | (1<<DDB2) | (0<<DDB1) | (1<<DDB0);
    185e:	8d e2       	ldi	r24, 0x2D	; 45
    1860:	87 bb       	out	0x17, r24	; 23
	// State: Bit7=T Bit6=T Bit5=0 Bit4=T Bit3=0 Bit2=0 Bit1=T Bit0=0
	PORTB=(0<<PORTB7) | (0<<PORTB6) | (0<<PORTB5) | (0<<PORTB4) | (0<<PORTB3) | (0<<PORTB2) | (0<<PORTB1) | (1<<PORTB0);
    1862:	81 e0       	ldi	r24, 0x01	; 1
    1864:	88 bb       	out	0x18, r24	; 24

	// Port C initialization
	// Function: Bit6=In Bit5=In Bit4=In Bit3=In Bit2=In Bit1=In Bit0=In
	DDRC=(0<<DDC6) | (0<<DDC5) | (0<<DDC4) | (0<<DDC3) | (0<<DDC2) | (0<<DDC1) | (0<<DDC0);
    1866:	14 ba       	out	0x14, r1	; 20
	// State: Bit6=T Bit5=T Bit4=T Bit3=T Bit2=T Bit1=T Bit0=T
	PORTC=(0<<PORTC6) | (0<<PORTC5) | (0<<PORTC4) | (0<<PORTC3) | (0<<PORTC2) | (0<<PORTC1) | (0<<PORTC0);
    1868:	15 ba       	out	0x15, r1	; 21

	// Port D initialization
	// Function: Bit7=Out Bit6=Out Bit5=In Bit4=In Bit3=In Bit2=In Bit1=In Bit0=In
	DDRD=(1<<DDD7) | (1<<DDD6) | (0<<DDD5) | (0<<DDD4) | (0<<DDD3) | (0<<DDD2) | (0<<DDD1) | (0<<DDD0);
    186a:	80 ec       	ldi	r24, 0xC0	; 192
    186c:	81 bb       	out	0x11, r24	; 17
	// State: Bit7=0 Bit6=0 Bit5=T Bit4=T Bit3=P Bit2=T Bit1=T Bit0=T
	PORTD=(1<<PORTD7) | (0<<PORTD6) | (0<<PORTD5) | (0<<PORTD4) | (1<<PORTD3) | (0<<PORTD2) | (0<<PORTD1) | (0<<PORTD0);
    186e:	88 e8       	ldi	r24, 0x88	; 136
    1870:	82 bb       	out	0x12, r24	; 18
    1872:	08 95       	ret

00001874 <spi_init>:
}

//инициализация SPI
void spi_init(void)
{
	DDRB |= ((1<<PORTB2)|(1<<PORTB3)|(1<<PORTB5)); //ножки SPI на выход
    1874:	87 b3       	in	r24, 0x17	; 23
    1876:	8c 62       	ori	r24, 0x2C	; 44
    1878:	87 bb       	out	0x17, r24	; 23
	PORTB &= ~((1<<PORTB2)|(1<<PORTB3)|(1<<PORTB5)); //низкий уровень
    187a:	88 b3       	in	r24, 0x18	; 24
    187c:	83 7d       	andi	r24, 0xD3	; 211
    187e:	88 bb       	out	0x18, r24	; 24
	SPCR=(0<<SPIE) | (1<<SPE) | (0<<DORD) | (1<<MSTR) | (0<<CPOL) | (0<<CPHA) | (0<<SPR1) | (0<<SPR0);
    1880:	80 e5       	ldi	r24, 0x50	; 80
    1882:	8d b9       	out	0x0d, r24	; 13
    1884:	08 95       	ret

00001886 <spi_sendByte>:
}

//отправка байта
void spi_sendByte(uint8_t byte)
{
	SPDR = byte;				//записываем байт в регистр
    1886:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1<<SPIF)));	//подождем пока данные передадутся
    1888:	77 9b       	sbis	0x0e, 7	; 14
    188a:	fe cf       	rjmp	.-4      	; 0x1888 <spi_sendByte+0x2>
}
    188c:	08 95       	ret

0000188e <spi_changeByte>:

//прием/отправка байта
uint8_t spi_changeByte(uint8_t byte)
{
	SPDR = byte;				//записываем байт в регистр
    188e:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1<<SPIF)));	//подождем пока данные передадутся (обменяются)
    1890:	77 9b       	sbis	0x0e, 7	; 14
    1892:	fe cf       	rjmp	.-4      	; 0x1890 <spi_changeByte+0x2>
	return SPDR;				//возвращаем принятое значение
    1894:	8f b1       	in	r24, 0x0f	; 15
}
    1896:	08 95       	ret

00001898 <NRF24_ReadReg>:

//функция чтения регистра модуля
uint8_t NRF24_ReadReg(uint8_t addr)
{
    1898:	cf 93       	push	r28
    189a:	c8 2f       	mov	r28, r24
	uint8_t dt=0, cmd;								//переменные данных и команды
	CS_ON();											//ногу cs к земле
    189c:	97 98       	cbi	0x12, 7	; 18
	dt = spi_changeByte(addr);						//Прием/отправкадайта адреса регистра
    189e:	f7 df       	rcall	.-18     	; 0x188e <spi_changeByte>
	//если адрес равен адрес регистра статус то и возварщаем его состояние
	if (addr!=STATUS)//а если не равен
    18a0:	c7 30       	cpi	r28, 0x07	; 7
    18a2:	11 f0       	breq	.+4      	; 0x18a8 <NRF24_ReadReg+0x10>
	{
		cmd=0xFF;									//команда NOP для получения данных
		dt = spi_changeByte(cmd);					//
    18a4:	8f ef       	ldi	r24, 0xFF	; 255
    18a6:	f3 df       	rcall	.-26     	; 0x188e <spi_changeByte>
	}
	CS_OFF();											//поднимаем ногу CS
    18a8:	97 9a       	sbi	0x12, 7	; 18
	return dt;	//возвращаемое значение
}
    18aa:	cf 91       	pop	r28
    18ac:	08 95       	ret

000018ae <NRF24_WriteReg>:
//------------------------------------------------
//функция записи регистра в модуль
void NRF24_WriteReg(uint8_t addr, uint8_t dt)
{
    18ae:	cf 93       	push	r28
    18b0:	c6 2f       	mov	r28, r22
	addr |= W_REGISTER;//включим бит записи в адрес
	CS_ON();
    18b2:	97 98       	cbi	0x12, 7	; 18
	spi_sendByte(addr);									//
    18b4:	80 62       	ori	r24, 0x20	; 32
    18b6:	e7 df       	rcall	.-50     	; 0x1886 <spi_sendByte>
	spi_sendByte(dt);										//
    18b8:	8c 2f       	mov	r24, r28
    18ba:	e5 df       	rcall	.-54     	; 0x1886 <spi_sendByte>
	CS_OFF();
    18bc:	97 9a       	sbi	0x12, 7	; 18
}
    18be:	cf 91       	pop	r28
    18c0:	08 95       	ret

000018c2 <NRF24_ToggleFeatures>:

//------------------------------------------------
void NRF24_ToggleFeatures(void)							//активация команд R_RX_PL_WID, W_ACK_PAYLOAD и W_TX_PAYLOAD_NOACK
{	//есть в даташите "без плюса"
	uint8_t dt[1] = {ACTIVATE};
	CS_ON();
    18c2:	97 98       	cbi	0x12, 7	; 18
	spi_sendByte(dt[0]);
    18c4:	80 e5       	ldi	r24, 0x50	; 80
    18c6:	df df       	rcall	.-66     	; 0x1886 <spi_sendByte>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    18c8:	82 e0       	ldi	r24, 0x02	; 2
    18ca:	8a 95       	dec	r24
    18cc:	f1 f7       	brne	.-4      	; 0x18ca <NRF24_ToggleFeatures+0x8>
    18ce:	00 c0       	rjmp	.+0      	; 0x18d0 <NRF24_ToggleFeatures+0xe>
	_delay_us(1);
	dt[0] = 0x73;
	spi_sendByte(dt[0]);
    18d0:	83 e7       	ldi	r24, 0x73	; 115
    18d2:	d9 df       	rcall	.-78     	; 0x1886 <spi_sendByte>
	CS_OFF();
    18d4:	97 9a       	sbi	0x12, 7	; 18
    18d6:	08 95       	ret

000018d8 <NRF24_Read_Buf>:
}

//-----------------------------------------------
void NRF24_Read_Buf(uint8_t addr,uint8_t *pBuf,uint8_t bytes)
{//чтение буфера (несколько байт)
    18d8:	ef 92       	push	r14
    18da:	ff 92       	push	r15
    18dc:	0f 93       	push	r16
    18de:	1f 93       	push	r17
    18e0:	cf 93       	push	r28
    18e2:	df 93       	push	r29
    18e4:	18 2f       	mov	r17, r24
    18e6:	06 2f       	mov	r16, r22
    18e8:	e7 2e       	mov	r14, r23
    18ea:	f4 2e       	mov	r15, r20
	CS_ON();
    18ec:	97 98       	cbi	0x12, 7	; 18
	spi_sendByte(addr);
    18ee:	cb df       	rcall	.-106    	; 0x1886 <spi_sendByte>
    18f0:	c0 2f       	mov	r28, r16
    18f2:	de 2d       	mov	r29, r14
    18f4:	ce 01       	movw	r24, r28
    18f6:	8f 0d       	add	r24, r15
    18f8:	91 1d       	adc	r25, r1
    18fa:	7c 01       	movw	r14, r24
	for (uint8_t i = 0 ; i < bytes ; i++) 		//для нужного количества байт
    18fc:	ce 15       	cp	r28, r14
    18fe:	df 05       	cpc	r29, r15
    1900:	21 f0       	breq	.+8      	; 0x190a <NRF24_Read_Buf+0x32>
	{																					//
		pBuf[i] = spi_changeByte(addr);
    1902:	81 2f       	mov	r24, r17
    1904:	c4 df       	rcall	.-120    	; 0x188e <spi_changeByte>
    1906:	89 93       	st	Y+, r24
    1908:	f9 cf       	rjmp	.-14     	; 0x18fc <NRF24_Read_Buf+0x24>
	}
	CS_OFF();
    190a:	97 9a       	sbi	0x12, 7	; 18
}
    190c:	df 91       	pop	r29
    190e:	cf 91       	pop	r28
    1910:	1f 91       	pop	r17
    1912:	0f 91       	pop	r16
    1914:	ff 90       	pop	r15
    1916:	ef 90       	pop	r14
    1918:	08 95       	ret

0000191a <NRF24_Write_Buf>:

//------------------------------------------------
void NRF24_Write_Buf(uint8_t addr,uint8_t *pBuf,uint8_t bytes)
{//запись буфера
    191a:	ff 92       	push	r15
    191c:	0f 93       	push	r16
    191e:	1f 93       	push	r17
    1920:	cf 93       	push	r28
    1922:	df 93       	push	r29
    1924:	f6 2e       	mov	r15, r22
    1926:	07 2f       	mov	r16, r23
    1928:	14 2f       	mov	r17, r20
	addr |= W_REGISTER;//включим бит записи в адрес
	CS_ON();
    192a:	97 98       	cbi	0x12, 7	; 18
	spi_sendByte(addr);
    192c:	80 62       	ori	r24, 0x20	; 32
    192e:	ab df       	rcall	.-170    	; 0x1886 <spi_sendByte>
    1930:	82 e0       	ldi	r24, 0x02	; 2
    1932:	8a 95       	dec	r24
    1934:	f1 f7       	brne	.-4      	; 0x1932 <NRF24_Write_Buf+0x18>
    1936:	00 c0       	rjmp	.+0      	; 0x1938 <NRF24_Write_Buf+0x1e>
    1938:	cf 2d       	mov	r28, r15
    193a:	d0 2f       	mov	r29, r16
    193c:	ce 01       	movw	r24, r28
    193e:	81 0f       	add	r24, r17
    1940:	91 1d       	adc	r25, r1
    1942:	8c 01       	movw	r16, r24
	_delay_us(1);
	for (uint8_t i = 0 ; i < bytes ; i++) 		//для нужного количества байт
    1944:	c0 17       	cp	r28, r16
    1946:	d1 07       	cpc	r29, r17
    1948:	19 f0       	breq	.+6      	; 0x1950 <NRF24_Write_Buf+0x36>
	{
		spi_sendByte(pBuf[i]);
    194a:	89 91       	ld	r24, Y+
    194c:	9c df       	rcall	.-200    	; 0x1886 <spi_sendByte>
    194e:	fa cf       	rjmp	.-12     	; 0x1944 <NRF24_Write_Buf+0x2a>
	}
	CS_OFF();
    1950:	97 9a       	sbi	0x12, 7	; 18
}
    1952:	df 91       	pop	r29
    1954:	cf 91       	pop	r28
    1956:	1f 91       	pop	r17
    1958:	0f 91       	pop	r16
    195a:	ff 90       	pop	r15
    195c:	08 95       	ret

0000195e <NRF24_FlushRX>:

//------------------------------------------------
void NRF24_FlushRX(void)
{//очистка буфера приема
	uint8_t dt[1] = {FLUSH_RX};
	CS_ON();
    195e:	97 98       	cbi	0x12, 7	; 18
	spi_sendByte(dt[0]);
    1960:	82 ee       	ldi	r24, 0xE2	; 226
    1962:	91 df       	rcall	.-222    	; 0x1886 <spi_sendByte>
    1964:	82 e0       	ldi	r24, 0x02	; 2
    1966:	8a 95       	dec	r24
    1968:	f1 f7       	brne	.-4      	; 0x1966 <NRF24_FlushRX+0x8>
    196a:	00 c0       	rjmp	.+0      	; 0x196c <NRF24_FlushRX+0xe>
	_delay_us(1); //пауза в микросекунду для завершения процесса
	CS_OFF();
    196c:	97 9a       	sbi	0x12, 7	; 18
    196e:	08 95       	ret

00001970 <NRF24_FlushTX>:

//------------------------------------------------
void NRF24_FlushTX(void)
{//очистка буфера передачи
	uint8_t dt[1] = {FLUSH_TX};
	CS_ON();
    1970:	97 98       	cbi	0x12, 7	; 18
	spi_sendByte(dt[0]);
    1972:	81 ee       	ldi	r24, 0xE1	; 225
    1974:	88 df       	rcall	.-240    	; 0x1886 <spi_sendByte>
    1976:	82 e0       	ldi	r24, 0x02	; 2
    1978:	8a 95       	dec	r24
    197a:	f1 f7       	brne	.-4      	; 0x1978 <NRF24_FlushTX+0x8>
    197c:	00 c0       	rjmp	.+0      	; 0x197e <NRF24_FlushTX+0xe>
	_delay_us(1); //пауза в микросекунду для завершения процесса
	CS_OFF();
    197e:	97 9a       	sbi	0x12, 7	; 18
    1980:	08 95       	ret

00001982 <NRF24L01_RX_Mode>:

//------------------------------------------------
void NRF24L01_RX_Mode(void)
{//режим приемника
	uint8_t regval=0x00;
	regval = NRF24_ReadReg(CONFIG);	//сохраняем значение регистра конфигурации
    1982:	80 e0       	ldi	r24, 0x00	; 0
    1984:	89 df       	rcall	.-238    	; 0x1898 <NRF24_ReadReg>
	//разбудим модуль и переведём его в режим приёмника, включив биты PWR_UP и PRIM_RX
	regval |= (1<<PWR_UP)|(1<<PRIM_RX);
	NRF24_WriteReg(CONFIG,regval);	//возвращаем значение регистра статуса
    1986:	68 2f       	mov	r22, r24
    1988:	63 60       	ori	r22, 0x03	; 3
    198a:	80 e0       	ldi	r24, 0x00	; 0
    198c:	90 df       	rcall	.-224    	; 0x18ae <NRF24_WriteReg>
	
	NRF24_Write_Buf(TX_ADDR, TX_ADDRESS1, TX_ADR_WIDTH);		//записываем  адрес передатчика
    198e:	43 e0       	ldi	r20, 0x03	; 3
    1990:	60 e6       	ldi	r22, 0x60	; 96
    1992:	70 e0       	ldi	r23, 0x00	; 0
    1994:	80 e1       	ldi	r24, 0x10	; 16
    1996:	c1 df       	rcall	.-126    	; 0x191a <NRF24_Write_Buf>
	NRF24_Write_Buf(RX_ADDR_P0, TX_ADDRESS1, TX_ADR_WIDTH);	//записываем адрес приемника
    1998:	43 e0       	ldi	r20, 0x03	; 3
    199a:	60 e6       	ldi	r22, 0x60	; 96
    199c:	70 e0       	ldi	r23, 0x00	; 0
    199e:	8a e0       	ldi	r24, 0x0A	; 10
    19a0:	bc df       	rcall	.-136    	; 0x191a <NRF24_Write_Buf>
	
	CE_SET();
    19a2:	c0 9a       	sbi	0x18, 0	; 24
    19a4:	8b e2       	ldi	r24, 0x2B	; 43
    19a6:	91 e0       	ldi	r25, 0x01	; 1
    19a8:	01 97       	sbiw	r24, 0x01	; 1
    19aa:	f1 f7       	brne	.-4      	; 0x19a8 <NRF24L01_RX_Mode+0x26>
    19ac:	00 c0       	rjmp	.+0      	; 0x19ae <NRF24L01_RX_Mode+0x2c>
    19ae:	00 00       	nop
	_delay_us(150); //Задержка минимум 130 мкс
	// Flush buffers
	NRF24_FlushRX();
    19b0:	d6 df       	rcall	.-84     	; 0x195e <NRF24_FlushRX>
	NRF24_FlushTX();
    19b2:	de cf       	rjmp	.-68     	; 0x1970 <NRF24_FlushTX>

000019b4 <NRF24L01_TX_Mode>:
}

//------------------------------------------------
void NRF24L01_TX_Mode(uint8_t *pBuf)
{//режим передатчика
	NRF24_Write_Buf(TX_ADDR, TX_ADDRESS0, TX_ADR_WIDTH);		//записываем адрес передатчика
    19b4:	43 e0       	ldi	r20, 0x03	; 3
    19b6:	63 e6       	ldi	r22, 0x63	; 99
    19b8:	70 e0       	ldi	r23, 0x00	; 0
    19ba:	80 e1       	ldi	r24, 0x10	; 16
    19bc:	ae df       	rcall	.-164    	; 0x191a <NRF24_Write_Buf>
	NRF24_Write_Buf(RX_ADDR_P0, TX_ADDRESS0, TX_ADR_WIDTH);	//записываем адрес приемника
    19be:	43 e0       	ldi	r20, 0x03	; 3
    19c0:	63 e6       	ldi	r22, 0x63	; 99
    19c2:	70 e0       	ldi	r23, 0x00	; 0
    19c4:	8a e0       	ldi	r24, 0x0A	; 10
    19c6:	a9 df       	rcall	.-174    	; 0x191a <NRF24_Write_Buf>
	CE_RESET();
    19c8:	c0 98       	cbi	0x18, 0	; 24
	// Flush buffers
	NRF24_FlushRX();
    19ca:	c9 df       	rcall	.-110    	; 0x195e <NRF24_FlushRX>
	NRF24_FlushTX();
    19cc:	d1 cf       	rjmp	.-94     	; 0x1970 <NRF24_FlushTX>

000019ce <NRF24_Transmit>:
}

//------------------------------------------------
void NRF24_Transmit(uint8_t addr,uint8_t *pBuf,uint8_t bytes)
{//передача данных в модуль
    19ce:	ff 92       	push	r15
    19d0:	0f 93       	push	r16
    19d2:	1f 93       	push	r17
    19d4:	cf 93       	push	r28
    19d6:	df 93       	push	r29
    19d8:	f6 2e       	mov	r15, r22
    19da:	07 2f       	mov	r16, r23
    19dc:	14 2f       	mov	r17, r20
	CE_RESET();
    19de:	c0 98       	cbi	0x18, 0	; 24
	CS_ON();
    19e0:	97 98       	cbi	0x12, 7	; 18
	spi_sendByte(addr);
    19e2:	51 df       	rcall	.-350    	; 0x1886 <spi_sendByte>
    19e4:	82 e0       	ldi	r24, 0x02	; 2
    19e6:	8a 95       	dec	r24
    19e8:	f1 f7       	brne	.-4      	; 0x19e6 <NRF24_Transmit+0x18>
    19ea:	00 c0       	rjmp	.+0      	; 0x19ec <NRF24_Transmit+0x1e>
    19ec:	cf 2d       	mov	r28, r15
    19ee:	d0 2f       	mov	r29, r16
    19f0:	ce 01       	movw	r24, r28
    19f2:	81 0f       	add	r24, r17
    19f4:	91 1d       	adc	r25, r1
    19f6:	8c 01       	movw	r16, r24
	_delay_us(1); //пауза в микросекунду для завершения процесса
	for (uint8_t i = 0 ; i < bytes ; i++)
    19f8:	c0 17       	cp	r28, r16
    19fa:	d1 07       	cpc	r29, r17
    19fc:	19 f0       	breq	.+6      	; 0x1a04 <NRF24_Transmit+0x36>
	{
		spi_sendByte(pBuf[i]);
    19fe:	89 91       	ld	r24, Y+
    1a00:	42 df       	rcall	.-380    	; 0x1886 <spi_sendByte>
    1a02:	fa cf       	rjmp	.-12     	; 0x19f8 <NRF24_Transmit+0x2a>
	}
	CS_OFF();
    1a04:	97 9a       	sbi	0x12, 7	; 18
	CE_SET();
    1a06:	c0 9a       	sbi	0x18, 0	; 24
}
    1a08:	df 91       	pop	r29
    1a0a:	cf 91       	pop	r28
    1a0c:	1f 91       	pop	r17
    1a0e:	0f 91       	pop	r16
    1a10:	ff 90       	pop	r15
    1a12:	08 95       	ret

00001a14 <NRF24L01_Send>:

//------------------------------------------------
uint8_t NRF24L01_Send(uint8_t *pBuf)
{//отправка данных в эфир
    1a14:	cf 93       	push	r28
    1a16:	df 93       	push	r29
    1a18:	ec 01       	movw	r28, r24
	uint8_t regval=0x00;						//переменная для отправки в конфигурационный регистр
	NRF24L01_TX_Mode(pBuf);					//включаем режим передачи
    1a1a:	cc df       	rcall	.-104    	; 0x19b4 <NRF24L01_TX_Mode>
	regval = NRF24_ReadReg(CONFIG);	//сохраняем значения конфигурационного региста
    1a1c:	80 e0       	ldi	r24, 0x00	; 0
    1a1e:	3c df       	rcall	.-392    	; 0x1898 <NRF24_ReadReg>
    1a20:	8e 7f       	andi	r24, 0xFE	; 254
	//если модуль ушел в спящий режим, то разбудим его, включив бит PWR_UP и выключив PRIM_RX
	regval |= (1<<PWR_UP);
	regval &= ~(1<<PRIM_RX);
	NRF24_WriteReg(CONFIG,regval);//записываем новое значение конфигурационного регистра
    1a22:	68 2f       	mov	r22, r24
    1a24:	62 60       	ori	r22, 0x02	; 2
    1a26:	80 e0       	ldi	r24, 0x00	; 0
    1a28:	42 df       	rcall	.-380    	; 0x18ae <NRF24_WriteReg>
    1a2a:	8b e2       	ldi	r24, 0x2B	; 43
    1a2c:	91 e0       	ldi	r25, 0x01	; 1
    1a2e:	01 97       	sbiw	r24, 0x01	; 1
    1a30:	f1 f7       	brne	.-4      	; 0x1a2e <NRF24L01_Send+0x1a>
    1a32:	00 c0       	rjmp	.+0      	; 0x1a34 <NRF24L01_Send+0x20>
    1a34:	00 00       	nop
	_delay_us(150); //Задержка минимум 130 мкс
	//Отправим данные в воздух
	NRF24_Transmit(WR_TX_PLOAD, pBuf, TX_PLOAD_WIDTH);//отправка данных
    1a36:	40 e2       	ldi	r20, 0x20	; 32
    1a38:	be 01       	movw	r22, r28
    1a3a:	80 ea       	ldi	r24, 0xA0	; 160
    1a3c:	c8 df       	rcall	.-112    	; 0x19ce <NRF24_Transmit>
	CE_SET();
    1a3e:	c0 9a       	sbi	0x18, 0	; 24
    1a40:	98 e2       	ldi	r25, 0x28	; 40
    1a42:	9a 95       	dec	r25
    1a44:	f1 f7       	brne	.-4      	; 0x1a42 <NRF24L01_Send+0x2e>
	_delay_us(15); //minimum 10us high pulse (Page 21)
	CE_RESET();
    1a46:	c0 98       	cbi	0x18, 0	; 24
	NRF24L01_RX_Mode();				//переход в режим приема
    1a48:	9c df       	rcall	.-200    	; 0x1982 <NRF24L01_RX_Mode>
	return 0;
}
    1a4a:	80 e0       	ldi	r24, 0x00	; 0
    1a4c:	df 91       	pop	r29
    1a4e:	cf 91       	pop	r28
    1a50:	08 95       	ret

00001a52 <nrf24_init>:

//------------------------------------------------
void nrf24_init(void)
{//инициализация
	CE_RESET();							//опускаем к земле вывод ce
    1a52:	c0 98       	cbi	0x18, 0	; 24
    1a54:	8f e0       	ldi	r24, 0x0F	; 15
    1a56:	97 e2       	ldi	r25, 0x27	; 39
    1a58:	01 97       	sbiw	r24, 0x01	; 1
    1a5a:	f1 f7       	brne	.-4      	; 0x1a58 <nrf24_init+0x6>
    1a5c:	00 c0       	rjmp	.+0      	; 0x1a5e <nrf24_init+0xc>
    1a5e:	00 00       	nop
	_delay_us(5000);					//задержка 5 мс
	//записываем конфигурационный байт,
	NRF24_WriteReg(CONFIG, 0x0a);		// Set PWR_UP bit, enable CRC(1 byte) &Prim_RX:0 (Transmitter)
    1a60:	6a e0       	ldi	r22, 0x0A	; 10
    1a62:	80 e0       	ldi	r24, 0x00	; 0
    1a64:	24 df       	rcall	.-440    	; 0x18ae <NRF24_WriteReg>
    1a66:	8f e0       	ldi	r24, 0x0F	; 15
    1a68:	97 e2       	ldi	r25, 0x27	; 39
    1a6a:	01 97       	sbiw	r24, 0x01	; 1
    1a6c:	f1 f7       	brne	.-4      	; 0x1a6a <nrf24_init+0x18>
    1a6e:	00 c0       	rjmp	.+0      	; 0x1a70 <nrf24_init+0x1e>
    1a70:	00 00       	nop
	_delay_us(5000);
	NRF24_WriteReg(EN_AA, 0x00);		// Enable Pipe0
    1a72:	60 e0       	ldi	r22, 0x00	; 0
    1a74:	81 e0       	ldi	r24, 0x01	; 1
    1a76:	1b df       	rcall	.-458    	; 0x18ae <NRF24_WriteReg>
	NRF24_WriteReg(EN_RXADDR, 0x01);	// Enable Pipe0
    1a78:	61 e0       	ldi	r22, 0x01	; 1
    1a7a:	82 e0       	ldi	r24, 0x02	; 2
    1a7c:	18 df       	rcall	.-464    	; 0x18ae <NRF24_WriteReg>
	NRF24_WriteReg(SETUP_AW, 0x01);		// Setup address width=3 bytes
    1a7e:	61 e0       	ldi	r22, 0x01	; 1
    1a80:	83 e0       	ldi	r24, 0x03	; 3
    1a82:	15 df       	rcall	.-470    	; 0x18ae <NRF24_WriteReg>
	NRF24_WriteReg(SETUP_RETR, 0x00);	// 1500us, 15 retrans
    1a84:	60 e0       	ldi	r22, 0x00	; 0
    1a86:	84 e0       	ldi	r24, 0x04	; 4
    1a88:	12 df       	rcall	.-476    	; 0x18ae <NRF24_WriteReg>
	NRF24_ToggleFeatures();				//активация команд
    1a8a:	1b df       	rcall	.-458    	; 0x18c2 <NRF24_ToggleFeatures>
	NRF24_WriteReg(FEATURE, 0x07);			//установка стандартных значений регистра FEATURE
    1a8c:	67 e0       	ldi	r22, 0x07	; 7
    1a8e:	8d e1       	ldi	r24, 0x1D	; 29
    1a90:	0e df       	rcall	.-484    	; 0x18ae <NRF24_WriteReg>
	NRF24_WriteReg(DYNPD, 0);			//отключение динамического размера полезной нагрузки
    1a92:	60 e0       	ldi	r22, 0x00	; 0
    1a94:	8c e1       	ldi	r24, 0x1C	; 28
    1a96:	0b df       	rcall	.-490    	; 0x18ae <NRF24_WriteReg>
	NRF24_WriteReg(STATUS, 0x70);		//Reset flags for IRQ
    1a98:	60 e7       	ldi	r22, 0x70	; 112
    1a9a:	87 e0       	ldi	r24, 0x07	; 7
    1a9c:	08 df       	rcall	.-496    	; 0x18ae <NRF24_WriteReg>
	NRF24_WriteReg(RF_CH, 76);			// частота 2476 MHz
    1a9e:	6c e4       	ldi	r22, 0x4C	; 76
    1aa0:	85 e0       	ldi	r24, 0x05	; 5
    1aa2:	05 df       	rcall	.-502    	; 0x18ae <NRF24_WriteReg>
	NRF24_WriteReg(RF_SETUP, 0x06);		//TX_PWR:0dBm, Datarate:1Mbps
    1aa4:	66 e0       	ldi	r22, 0x06	; 6
    1aa6:	86 e0       	ldi	r24, 0x06	; 6
    1aa8:	02 df       	rcall	.-508    	; 0x18ae <NRF24_WriteReg>
	NRF24_Write_Buf(TX_ADDR, TX_ADDRESS0, TX_ADR_WIDTH);//запись адреса передачи
    1aaa:	43 e0       	ldi	r20, 0x03	; 3
    1aac:	63 e6       	ldi	r22, 0x63	; 99
    1aae:	70 e0       	ldi	r23, 0x00	; 0
    1ab0:	80 e1       	ldi	r24, 0x10	; 16
    1ab2:	33 df       	rcall	.-410    	; 0x191a <NRF24_Write_Buf>
	NRF24_Write_Buf(RX_ADDR_P1, TX_ADDRESS0, TX_ADR_WIDTH);//запись адреса приема
    1ab4:	43 e0       	ldi	r20, 0x03	; 3
    1ab6:	63 e6       	ldi	r22, 0x63	; 99
    1ab8:	70 e0       	ldi	r23, 0x00	; 0
    1aba:	8b e0       	ldi	r24, 0x0B	; 11
    1abc:	2e df       	rcall	.-420    	; 0x191a <NRF24_Write_Buf>
	NRF24_WriteReg(RX_PW_P0, TX_PLOAD_WIDTH); //Number of bytes in RX payload in data pipe 1
    1abe:	60 e2       	ldi	r22, 0x20	; 32
    1ac0:	81 e1       	ldi	r24, 0x11	; 17
    1ac2:	f5 de       	rcall	.-534    	; 0x18ae <NRF24_WriteReg>
	//пока уходим в режим приёмника
	NRF24L01_RX_Mode();					//режим приема
    1ac4:	5e df       	rcall	.-324    	; 0x1982 <NRF24L01_RX_Mode>
	LED_OFF();
    1ac6:	96 98       	cbi	0x12, 6	; 18
    1ac8:	08 95       	ret

00001aca <nrf24_receive>:

//--------------------------------------------------
void nrf24_receive(void)
{
	uint8_t status = 0x01;	//переменная статус
	status = NRF24_ReadReg(STATUS);	//чтение значения регистра статуса
    1aca:	87 e0       	ldi	r24, 0x07	; 7
    1acc:	e5 de       	rcall	.-566    	; 0x1898 <NRF24_ReadReg>
	if(status & RX_DR)				//если есть данные на прием
    1ace:	86 ff       	sbrs	r24, 6
    1ad0:	0b c0       	rjmp	.+22     	; 0x1ae8 <nrf24_receive+0x1e>
	{
		NRF24_Read_Buf(RD_RX_PLOAD,rx_buf,TX_PLOAD_WIDTH);//чтение буфера
    1ad2:	40 e2       	ldi	r20, 0x20	; 32
    1ad4:	6c e8       	ldi	r22, 0x8C	; 140
    1ad6:	70 e0       	ldi	r23, 0x00	; 0
    1ad8:	81 e6       	ldi	r24, 0x61	; 97
    1ada:	fe de       	rcall	.-516    	; 0x18d8 <NRF24_Read_Buf>
		NRF24_WriteReg(STATUS, 0x40);	//запись в регистр статуса 1 в шестой бит, обнуление остальных
    1adc:	60 e4       	ldi	r22, 0x40	; 64
    1ade:	87 e0       	ldi	r24, 0x07	; 7
    1ae0:	e6 de       	rcall	.-564    	; 0x18ae <NRF24_WriteReg>
		f_rx = 1;						//поднимаем флаг приема
    1ae2:	81 e0       	ldi	r24, 0x01	; 1
    1ae4:	80 93 6b 00 	sts	0x006B, r24	; 0x80006b <f_rx>
    1ae8:	08 95       	ret

00001aea <main>:

static void (*jump_to_app)(void) = 0x0000;

int main(void)
{
	port_init();							//инициализация портов
    1aea:	b9 de       	rcall	.-654    	; 0x185e <port_init>
	spi_init();								//инициализация SPI
    1aec:	c3 de       	rcall	.-634    	; 0x1874 <spi_init>
	nrf24_init();
    1aee:	b1 df       	rcall	.-158    	; 0x1a52 <nrf24_init>

	uint8_t blink_counter = 2;
	while (blink_counter)
	{
		LED_ON();
    1af0:	96 9a       	sbi	0x12, 6	; 18
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1af2:	2f ef       	ldi	r18, 0xFF	; 255
    1af4:	80 e7       	ldi	r24, 0x70	; 112
    1af6:	92 e0       	ldi	r25, 0x02	; 2
    1af8:	21 50       	subi	r18, 0x01	; 1
    1afa:	80 40       	sbci	r24, 0x00	; 0
    1afc:	90 40       	sbci	r25, 0x00	; 0
    1afe:	e1 f7       	brne	.-8      	; 0x1af8 <main+0xe>
    1b00:	00 c0       	rjmp	.+0      	; 0x1b02 <main+0x18>
    1b02:	00 00       	nop
		_delay_ms(100);
		LED_OFF();
    1b04:	96 98       	cbi	0x12, 6	; 18
    1b06:	af ef       	ldi	r26, 0xFF	; 255
    1b08:	b0 e7       	ldi	r27, 0x70	; 112
    1b0a:	e2 e0       	ldi	r30, 0x02	; 2
    1b0c:	a1 50       	subi	r26, 0x01	; 1
    1b0e:	b0 40       	sbci	r27, 0x00	; 0
    1b10:	e0 40       	sbci	r30, 0x00	; 0
    1b12:	e1 f7       	brne	.-8      	; 0x1b0c <main+0x22>
    1b14:	00 c0       	rjmp	.+0      	; 0x1b16 <main+0x2c>
    1b16:	00 00       	nop
	nrf24_init();

	uint8_t blink_counter = 2;
	while (blink_counter)
	{
		LED_ON();
    1b18:	96 9a       	sbi	0x12, 6	; 18
    1b1a:	ff ef       	ldi	r31, 0xFF	; 255
    1b1c:	20 e7       	ldi	r18, 0x70	; 112
    1b1e:	82 e0       	ldi	r24, 0x02	; 2
    1b20:	f1 50       	subi	r31, 0x01	; 1
    1b22:	20 40       	sbci	r18, 0x00	; 0
    1b24:	80 40       	sbci	r24, 0x00	; 0
    1b26:	e1 f7       	brne	.-8      	; 0x1b20 <main+0x36>
    1b28:	00 c0       	rjmp	.+0      	; 0x1b2a <main+0x40>
    1b2a:	00 00       	nop
		_delay_ms(100);
		LED_OFF();
    1b2c:	96 98       	cbi	0x12, 6	; 18
    1b2e:	9f ef       	ldi	r25, 0xFF	; 255
    1b30:	a0 e7       	ldi	r26, 0x70	; 112
    1b32:	b2 e0       	ldi	r27, 0x02	; 2
    1b34:	91 50       	subi	r25, 0x01	; 1
    1b36:	a0 40       	sbci	r26, 0x00	; 0
    1b38:	b0 40       	sbci	r27, 0x00	; 0
    1b3a:	e1 f7       	brne	.-8      	; 0x1b34 <main+0x4a>
    1b3c:	00 c0       	rjmp	.+0      	; 0x1b3e <main+0x54>
    1b3e:	00 00       	nop

	do 
		{
		data = *tmp++;
		data |= *tmp++ << 8;
		boot_page_fill(baddr, data);	// call asm routine.
    1b40:	d1 e0       	ldi	r29, 0x01	; 1
		baddr += 2;			// Select next word in memory
		size -= 2;			// Reduce number of bytes to write by two
		} 
	while (size);				// Loop until all bytes written

	boot_page_write(pagestart);
    1b42:	15 e0       	ldi	r17, 0x05	; 5
	boot_spm_busy_wait();
	boot_rww_enable();		// Re-enable the RWW section
    1b44:	c1 e1       	ldi	r28, 0x11	; 17
{
	// erase only main section (bootloader protection)
	uint32_t addr = 0;
	while (APP_END > addr) 
	{
		boot_page_erase(addr);		// Perform page erase
    1b46:	03 e0       	ldi	r16, 0x03	; 3

	uint16_t cnt = 0;

	while (1) 
	{
		nrf24_receive();
    1b48:	c0 df       	rcall	.-128    	; 0x1aca <nrf24_receive>

		if(f_rx == 1)						//если флаг приема поднят
    1b4a:	90 91 6b 00 	lds	r25, 0x006B	; 0x80006b <f_rx>
    1b4e:	91 30       	cpi	r25, 0x01	; 1
    1b50:	d9 f7       	brne	.-10     	; 0x1b48 <main+0x5e>
		{
			if (rx_buf[0] == BUT_ADDR)		//если первый принятый байт совпадает с адресом кнопки
    1b52:	80 91 8c 00 	lds	r24, 0x008C	; 0x80008c <rx_buf>
    1b56:	87 30       	cpi	r24, 0x07	; 7
    1b58:	09 f0       	breq	.+2      	; 0x1b5c <main+0x72>
    1b5a:	68 c0       	rjmp	.+208    	; 0x1c2c <main+0x142>
			{
				
				if (rx_buf[1] == 'E')	
    1b5c:	80 91 8d 00 	lds	r24, 0x008D	; 0x80008d <rx_buf+0x1>
    1b60:	85 34       	cpi	r24, 0x45	; 69
    1b62:	91 f4       	brne	.+36     	; 0x1b88 <main+0x9e>
    1b64:	e0 e0       	ldi	r30, 0x00	; 0
    1b66:	f0 e0       	ldi	r31, 0x00	; 0
{
	// erase only main section (bootloader protection)
	uint32_t addr = 0;
	while (APP_END > addr) 
	{
		boot_page_erase(addr);		// Perform page erase
    1b68:	00 93 57 00 	sts	0x0057, r16	; 0x800057 <__TEXT_REGION_LENGTH__+0x7fe057>
    1b6c:	e8 95       	spm
		boot_spm_busy_wait();		// Wait until the memory is erased.
    1b6e:	07 b6       	in	r0, 0x37	; 55
    1b70:	00 fc       	sbrc	r0, 0
    1b72:	fd cf       	rjmp	.-6      	; 0x1b6e <main+0x84>
    1b74:	e0 5c       	subi	r30, 0xC0	; 192
    1b76:	ff 4f       	sbci	r31, 0xFF	; 255

static inline void eraseFlash(void)
{
	// erase only main section (bootloader protection)
	uint32_t addr = 0;
	while (APP_END > addr) 
    1b78:	e1 15       	cp	r30, r1
    1b7a:	28 e1       	ldi	r18, 0x18	; 24
    1b7c:	f2 07       	cpc	r31, r18
    1b7e:	a1 f7       	brne	.-24     	; 0x1b68 <main+0x7e>
	{
		boot_page_erase(addr);		// Perform page erase
		boot_spm_busy_wait();		// Wait until the memory is erased.
		addr += SPM_PAGESIZE;
	}
	boot_rww_enable();
    1b80:	c0 93 57 00 	sts	0x0057, r28	; 0x800057 <__TEXT_REGION_LENGTH__+0x7fe057>
    1b84:	e8 95       	spm
    1b86:	09 c0       	rjmp	.+18     	; 0x1b9a <main+0xb0>
				if (rx_buf[1] == 'E')	
				{
					eraseFlash();
				}

				if (rx_buf[1] == 'W')	
    1b88:	87 35       	cpi	r24, 0x57	; 87
    1b8a:	39 f4       	brne	.+14     	; 0x1b9a <main+0xb0>
				{
					f_wait = 1;
    1b8c:	90 93 66 00 	sts	0x0066, r25	; 0x800066 <__data_end>
					tx_buf[0] = 'W';
    1b90:	80 93 6c 00 	sts	0x006C, r24	; 0x80006c <tx_buf>
					NRF24L01_Send(tx_buf);
    1b94:	8c e6       	ldi	r24, 0x6C	; 108
    1b96:	90 e0       	ldi	r25, 0x00	; 0
    1b98:	3d df       	rcall	.-390    	; 0x1a14 <NRF24L01_Send>
				}

				if (rx_buf[1] == 'F')		//
    1b9a:	80 91 8d 00 	lds	r24, 0x008D	; 0x80008d <rx_buf+0x1>
    1b9e:	86 34       	cpi	r24, 0x46	; 70
    1ba0:	09 f0       	breq	.+2      	; 0x1ba4 <main+0xba>
    1ba2:	44 c0       	rjmp	.+136    	; 0x1c2c <main+0x142>
				{
					LED_ON();
    1ba4:	96 9a       	sbi	0x12, 6	; 18
					pagebuf_t size;
					size = rx_buf[2];
    1ba6:	f0 90 8e 00 	lds	r15, 0x008E	; 0x80008e <rx_buf+0x2>
					address = rx_buf[3]; //
    1baa:	80 91 8f 00 	lds	r24, 0x008F	; 0x80008f <rx_buf+0x3>
    1bae:	28 2f       	mov	r18, r24
    1bb0:	30 e0       	ldi	r19, 0x00	; 0
    1bb2:	30 93 69 00 	sts	0x0069, r19	; 0x800069 <address+0x1>
    1bb6:	20 93 68 00 	sts	0x0068, r18	; 0x800068 <address>
    1bba:	a0 e9       	ldi	r26, 0x90	; 144
    1bbc:	b0 e0       	ldi	r27, 0x00	; 0

					for (uint8_t i = 0; i < size; i++)
    1bbe:	ec ea       	ldi	r30, 0xAC	; 172
    1bc0:	f0 e0       	ldi	r31, 0x00	; 0
    1bc2:	90 e0       	ldi	r25, 0x00	; 0
    1bc4:	9f 15       	cp	r25, r15
    1bc6:	21 f0       	breq	.+8      	; 0x1bd0 <main+0xe6>
					{
						gBuffer[i] = rx_buf[i+4];
    1bc8:	2d 91       	ld	r18, X+
    1bca:	21 93       	st	Z+, r18
					LED_ON();
					pagebuf_t size;
					size = rx_buf[2];
					address = rx_buf[3]; //

					for (uint8_t i = 0; i < size; i++)
    1bcc:	9f 5f       	subi	r25, 0xFF	; 255
    1bce:	fa cf       	rjmp	.-12     	; 0x1bc4 <main+0xda>
	boot_rww_enable();
}

static inline uint16_t writeFlashPage(uint16_t waddr, pagebuf_t size)
{
	uint32_t pagestart = (uint32_t)waddr<<1;
    1bd0:	90 e0       	ldi	r25, 0x00	; 0
    1bd2:	a0 e0       	ldi	r26, 0x00	; 0
    1bd4:	b0 e0       	ldi	r27, 0x00	; 0
    1bd6:	88 0f       	add	r24, r24
    1bd8:	99 1f       	adc	r25, r25
    1bda:	aa 1f       	adc	r26, r26
    1bdc:	bb 1f       	adc	r27, r27
	uint32_t baddr = pagestart;
	uint16_t data;
	uint8_t *tmp = gBuffer;
    1bde:	20 91 ac 00 	lds	r18, 0x00AC	; 0x8000ac <gBuffer>
    1be2:	4c ea       	ldi	r20, 0xAC	; 172
    1be4:	50 e0       	ldi	r21, 0x00	; 0
    1be6:	bc 01       	movw	r22, r24

	do 
		{
		data = *tmp++;
		data |= *tmp++ << 8;
		boot_page_fill(baddr, data);	// call asm routine.
    1be8:	8c 5a       	subi	r24, 0xAC	; 172
    1bea:	90 40       	sbci	r25, 0x00	; 0
    1bec:	fc 01       	movw	r30, r24
    1bee:	e4 0f       	add	r30, r20
    1bf0:	f5 1f       	adc	r31, r21
    1bf2:	da 01       	movw	r26, r20
    1bf4:	11 96       	adiw	r26, 0x01	; 1
    1bf6:	ec 90       	ld	r14, X
    1bf8:	30 e0       	ldi	r19, 0x00	; 0
    1bfa:	3e 29       	or	r19, r14
    1bfc:	09 01       	movw	r0, r18
    1bfe:	d0 93 57 00 	sts	0x0057, r29	; 0x800057 <__TEXT_REGION_LENGTH__+0x7fe057>
    1c02:	e8 95       	spm
    1c04:	11 24       	eor	r1, r1

		baddr += 2;			// Select next word in memory
		size -= 2;			// Reduce number of bytes to write by two
    1c06:	fa 94       	dec	r15
    1c08:	fa 94       	dec	r15
    1c0a:	4e 5f       	subi	r20, 0xFE	; 254
    1c0c:	5f 4f       	sbci	r21, 0xFF	; 255
		} 
	while (size);				// Loop until all bytes written
    1c0e:	ff 20       	and	r15, r15
    1c10:	19 f0       	breq	.+6      	; 0x1c18 <main+0x12e>
	uint8_t *tmp = gBuffer;

	do 
		{
		data = *tmp++;
		data |= *tmp++ << 8;
    1c12:	fa 01       	movw	r30, r20
    1c14:	20 81       	ld	r18, Z
    1c16:	ea cf       	rjmp	.-44     	; 0x1bec <main+0x102>
		baddr += 2;			// Select next word in memory
		size -= 2;			// Reduce number of bytes to write by two
		} 
	while (size);				// Loop until all bytes written

	boot_page_write(pagestart);
    1c18:	fb 01       	movw	r30, r22
    1c1a:	10 93 57 00 	sts	0x0057, r17	; 0x800057 <__TEXT_REGION_LENGTH__+0x7fe057>
    1c1e:	e8 95       	spm
	boot_spm_busy_wait();
    1c20:	07 b6       	in	r0, 0x37	; 55
    1c22:	00 fc       	sbrc	r0, 0
    1c24:	fd cf       	rjmp	.-6      	; 0x1c20 <main+0x136>
	boot_rww_enable();		// Re-enable the RWW section
    1c26:	c0 93 57 00 	sts	0x0057, r28	; 0x800057 <__TEXT_REGION_LENGTH__+0x7fe057>
    1c2a:	e8 95       	spm
					writeFlashPage(address, size);
				}

			}

			f_rx = 0;						//опускаем флаг приема
    1c2c:	10 92 6b 00 	sts	0x006B, r1	; 0x80006b <f_rx>
    1c30:	8b cf       	rjmp	.-234    	; 0x1b48 <main+0x5e>

00001c32 <_exit>:
    1c32:	f8 94       	cli

00001c34 <__stop_program>:
    1c34:	ff cf       	rjmp	.-2      	; 0x1c34 <__stop_program>
